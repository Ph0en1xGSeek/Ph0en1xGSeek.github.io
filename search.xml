<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 456 Pattern]]></title>
    <url>%2F2020%2F02%2F10%2Fleetcode456%2F</url>
    <content type="text"><![CDATA[单调栈，找到132这种大小关系的子序列 暴力的方法需要O(N^3)的复杂度，但是利用单调栈就可以达到O(N) 从右向左扫描整个数组，其实我们只需要把当前扫描到的数当作(1)，维护当前最大的(2)即可，只要(1) &lt; (2)就是找到。 维护一个单调队列，栈顶小栈底大，每次pop时都相当于找到了一个(2)(3)pair，维护pop的值的最大值就是我们要的(3) C++ Code 1234567891011121314151617181920212223class Solution &#123;public: bool find132pattern(vector&lt;int&gt;&amp; nums) &#123; int sz = nums.size(); if(sz &lt; 3) &#123; return false; &#125; stack&lt;int&gt; st; int ak = INT_MIN; st.push(nums[sz-1]); for(int i = sz-1; i &gt;= 0; --i) &#123; if(nums[i] &lt; ak) &#123; return true; &#125; while(!st.empty() &amp;&amp; nums[i] &gt; st.top()) &#123; ak = max(ak, st.top()); st.pop(); &#125; st.push(nums[i]); &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 454 4Sum II]]></title>
    <url>%2F2020%2F02%2F10%2Fleetcode454%2F</url>
    <content type="text"><![CDATA[经典4Sum题，但是需要在4个数组中分别找到一个数来相加 暴力的方法需要O(N^4)的复杂度，普通的4Sum可以优化到O(N^3)，但是这题由于是在不同的数组中找，可以进一步的优化，把前两个数组里所有数的和放进一个哈希表，然后在后两个数组中找相反数的组合。 C++ Code 1234567891011121314151617181920212223class Solution &#123;public: bool find132pattern(vector&lt;int&gt;&amp; nums) &#123; int sz = nums.size(); if(sz &lt; 3) &#123; return false; &#125; stack&lt;int&gt; st; int ak = INT_MIN; st.push(nums[sz-1]); for(int i = sz-1; i &gt;= 0; --i) &#123; if(nums[i] &lt; ak) &#123; return true; &#125; while(!st.empty() &amp;&amp; nums[i] &gt; st.top()) &#123; ak = max(ak, st.top()); st.pop(); &#125; st.push(nums[i]); &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 446 Arithmetic Slices II - Subsequence]]></title>
    <url>%2F2020%2F02%2F07%2Fleetcode446%2F</url>
    <content type="text"><![CDATA[动态规划，求有多少子序列是等差数列 dp[i][diff]表示以第i位数为结尾的且相邻两个数差diff的数列个数（不是等差数列，因为长度为2也会被计算），由于diff的数量范围很大但是很稀疏，所以每一个dp[i]里都是一个哈希表。 其中+1表示前面的数列加上i位的数后的数列，前面表示把前面的数列都往后移一位，去掉第一个数，加上i为最后一个数。 结果的计算就是在dp的过程中把所有的dp[j][diff]累加起来，以为确定了右端点为i时左端点有dp[j][diff]种取法。同时也能保证数列的第三个数才开始算。 C++ Code 12345678910111213141516171819class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; A) &#123; int sz = A.size(); if(sz &lt;= 2) &#123; return 0; &#125; int cnt = 0; vector&lt;unordered_map&lt;long long, int&gt;&gt; dp(sz); for(int i = 1; i &lt; sz; ++i) &#123; for(int j = 0; j &lt; i; ++j) &#123; long long diff = (long long) A[i] - (long long)A[j]; dp[i][diff] += (dp[j][diff] + 1); cnt += dp[j][diff]; &#125; &#125; return cnt; &#125; &#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 332 Reconstruct Itinerary]]></title>
    <url>%2F2019%2F09%2F24%2Fleetcode332%2F</url>
    <content type="text"><![CDATA[给定连通图的一些边，问如何不重复走边遍历完这个图，并且边有一个名字，要使名字的字典序最小 想到用dfs来直接搜索，但是这题存在有环的问题，即一个节点会被遍历多次。如果采用至上而下的搜索，则会产生很多没用的搜索和回溯。可以采用至下而上的搜索策略，即如果一个所有的出度都被搜索过了，那么就可以入队。这样第一个入队的一定是终点。如果一个点有多个出度，即一个环的入口，那么只要用一个multiset来保证搜索出度是按照字典序就可以。 C++ Code 1234567891011121314151617181920212223class Solution &#123;public: void dfs(map&lt;string, multiset&lt;string&gt;&gt; &amp;mp, string cur, vector&lt;string&gt; &amp;result) &#123; while(mp[cur].size()) &#123; string nex = *(mp[cur].begin()); mp[cur].erase(mp[cur].begin()); dfs(mp, nex, result); &#125; result.push_back(cur); &#125; vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123; map&lt;string, multiset&lt;string&gt;&gt; mp; for(auto item: tickets) &#123; mp[item[0]].insert(item[1]); &#125; string cur = "JFK"; vector&lt;string&gt; result; dfs(mp, cur, result); reverse(result.begin(), result.end()); return result; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 330 Patching Array]]></title>
    <url>%2F2019%2F09%2F22%2Fleetcode330%2F</url>
    <content type="text"><![CDATA[给定数组和一个整数n，问需要补多少数，使这个数组内数组合的和可以覆盖1~n 贪心，每次都补入当前（数组中的前i-1个数）不能组合成的最小的数m。 假设数组中前i-1个数以及已经补入的数已经可以覆盖[1, m)，这时候第i个数： &lt;=m，那么与前面i-1个数的组合就可以覆盖[1, m+nums[i])，现在前i个数就可以达到m+nums[i] > m，那么补入m，前i-1个数可以达到2*m C++ Code 123456789101112131415161718class Solution &#123;public: int minPatches(vector&lt;int&gt;&amp; nums, int n) &#123; long long m = 1; int i = 0; int cnt = 0; int sz = nums.size(); while(m &lt;= n) &#123; if(i &lt; sz &amp;&amp; nums[i] &lt;= m) &#123; m += nums[i++]; &#125;else &#123; m &lt;&lt;= 1; ++cnt; &#125; &#125; return cnt; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 327 Count of Range Sum]]></title>
    <url>%2F2019%2F09%2F20%2Fleetcode327%2F</url>
    <content type="text"><![CDATA[求数组内有多少段区间和落在low和high的闭区间内，要求时间复杂度小于O(n^2) 先求出累计和sum，如果没有时间复杂度的限制的话，应该遍历，用后面的sum[j]减去前面的sum[i]，只要落在区间内就+1 但是要限制复杂度，所以我们想到利用排序来减少一些不必要的重复。可以利用分治思想，先计算出端点在每个子区间内的数量，然后再计算端点落在相邻不同区间的数量。在分治的同时，完成归并排序，不破坏两个相邻区间内数先后关系（必须要后面减前面），同时两个区间内部变为有序，使得搜索右端点不需要从新的左端点开始，而是从前面的位置继续即可。 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int mergeSort(vector&lt;long long&gt; &amp;sum, int lower, int upper, int left, int right) &#123; if(left+1 &gt;= right) &#123; return 0; &#125; int mid = (left + right) &gt;&gt; 1; int cnt = 0; cnt += mergeSort(sum, lower, upper, left, mid); cnt += mergeSort(sum, lower, upper, mid, right); int lower_pos = mid, upper_pos = mid; for(int i = left; i &lt; mid; ++i) &#123; while(lower_pos &lt; right &amp;&amp; sum[lower_pos] - sum[i] &lt; lower) ++lower_pos; while(upper_pos &lt; right &amp;&amp; sum[upper_pos] - sum[i] &lt;= upper) ++upper_pos; cnt += (upper_pos - lower_pos); &#125; vector&lt;long long&gt; tmp(right - left); for(int i = left; i &lt; right; ++i) &#123; tmp[i - left] = sum[i]; &#125; int i = 0, j = mid - left; int pos = left; while(i &lt; mid - left || j &lt; right - left) &#123; if(i &gt;= mid - left) &#123; sum[pos++] = tmp[j++]; &#125;else if(j &gt;= right - left) &#123; sum[pos++] = tmp[i++]; &#125;else if(tmp[i] &lt; tmp[j]) &#123; sum[pos++] = tmp[i++]; &#125;else &#123; sum[pos++] = tmp[j++]; &#125; &#125; // inplace_merge(sum.begin()+left, sum.begin()+mid, sum.begin()+right); return cnt; &#125; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int sz = nums.size(); vector&lt;long long&gt; sum(sz + 1, 0); for(int i = 1; i &lt; sz + 1; ++i) &#123; sum[i] = sum[i-1] + nums[i-1]; &#125; int ans = mergeSort(sum, lower, upper, 0, sz + 1); return ans; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 321 Create Maximum Number]]></title>
    <url>%2F2019%2F09%2F19%2Fleetcode321%2F</url>
    <content type="text"><![CDATA[给定两个数组，要求用这些数字组成一个长度为k的最大的数字，要求两个数组内的数字顺序不变。 枚举两个数组各处多少个数字，第一个数组出i个，第二个数组就出k-i个，然后取出的这两个数字本身就要最大。因为如果不是最大，那我换成最大的填到最终的数字中一定更大。 单个数组求去掉一定数字能得到的最大数字比较简单，用一个栈来维护，只要还能删掉数字并且准备入栈的数字比栈顶数字要大，那就将栈顶数字出栈。 两个数组的最大数字求得后，只需要用归并操作将两个数字合并就可以，不过要注意的是，如果两个队列顶的数字相同时，需要比较两个剩下的数组谁比较大，将较大的那个队列头归并。 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution &#123;public: vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; int sz1 = nums1.size(); int sz2 = nums2.size(); vector&lt;int&gt; ret; for(int i = max(0, k - sz2); i &lt;= min(k, sz1); ++i) &#123; ret = max(ret, mergeVec(maxVec(nums1, sz1 - i), maxVec(nums2, sz2 - (k - i)))); &#125; return ret; &#125; vector&lt;int&gt; maxVec(vector&lt;int&gt; &amp;nums, int drop) &#123; vector&lt;int&gt; ret; for(int i = 0; i &lt; nums.size(); ++i) &#123; while(!ret.empty() &amp;&amp; drop &gt; 0 &amp;&amp; ret.back() &lt; nums[i]) &#123; ret.pop_back(); --drop; &#125; ret.push_back(nums[i]); &#125; while(drop &gt; 0) &#123; ret.pop_back(); --drop; &#125; return ret; &#125; vector&lt;int&gt; mergeVec(const vector&lt;int&gt; &amp;v1, const vector&lt;int&gt; &amp;v2) &#123; vector&lt;int&gt; ret; int sz1 = v1.size(); int sz2 = v2.size(); int pos1 = 0, pos2 = 0; while(pos1 &lt; sz1 || pos2 &lt; sz2) &#123; if(pos2 == sz2) &#123; ret.push_back(v1[pos1++]); &#125;else if(pos1 == sz1) &#123; ret.push_back(v2[pos2++]); &#125;else if(v1[pos1] &lt; v2[pos2]) &#123; ret.push_back(v2[pos2++]); &#125;else if(v1[pos1] &gt; v2[pos2]) &#123; ret.push_back(v1[pos1++]); &#125;else &#123; ret.push_back(v1[pos1]); compare(v1, v2, pos1, pos2)? ++pos1: ++pos2; &#125; &#125; return ret; &#125; bool compare(const vector&lt;int&gt; &amp;v1, const vector&lt;int&gt; &amp;v2, int pos1, int pos2) &#123; for(int i = pos1, j = pos2; ;++i, ++j) &#123; if(i == v1.size()) &#123; return false; &#125;else if(j == v2.size()) &#123; return true; &#125;else if(v1[i] &lt; v2[j]) &#123; return false; &#125;else if(v1[i] &gt; v2[j]) &#123; return true; &#125; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 324 Wiggle Sort II]]></title>
    <url>%2F2019%2F09%2F19%2Fleetcode324%2F</url>
    <content type="text"><![CDATA[摇摆排序，要求nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]... 且时间复杂度为O(n)，额外空间为O(1) 如果没有时间复杂度要求，做法应该为先排序，然后将后半个数组穿插到前半个数组中。但如果不能够排序，我们就只能通过求中位数的方法来完成。再加上空间显示，则使用交换的方法来完成排序。 求中位数 算法为O(n)，使用一趟快速排序，将数组分为两份，然后在多的那部分中继续一趟快速排序，直到正好以中位数为sentinel，最多计算次数不超过2n。使用nth_element函数找到数组中第n大的数能够直接完成这个过程，完成后，中位数左边的数都比它小，右边的都比它大； 两个指针low，high，分别从奇数位正向遍历1、3、5……以及偶数位反向遍历……4、2、0。用(i*2 + 1) / (size - 1)来按照1、3、5……0、2、4……的顺序重排数组；然后按这个顺序开始，如果小于中位数，就放到low左边，如果大于中位数就放到high右边。 C++ Code 1234567891011121314151617181920class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; int sz = nums.size(); nth_element(nums.begin(), nums.begin() + sz / 2, nums.end()); auto index = [=](int pos) &#123;return (pos * 2 + 1) % (sz | 1);&#125;; int mid = nums[sz/2]; int low = 0, high = sz-1; int i = 0; while(i &lt;= high) &#123; if(nums[index(i)] &lt; mid) &#123; swap(nums[index(i)], nums[index(high--)]); &#125;else if(nums[index(i)] &gt; mid) &#123; swap(nums[index(i++)], nums[index(low++)]); &#125;else &#123; ++i; &#125; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 310 Minimum Height Trees]]></title>
    <url>%2F2019%2F09%2F14%2Fleetcode310%2F</url>
    <content type="text"><![CDATA[寻找以哪个节点作为根节点的时候树的高度最小。 作为根节点的节点一定在树的直径的中点。如果不在中点，那么一定有一个节点的距离根节点超过树的半径的距离。（树上路径唯一，直径连接两个叶子节点，那么如果根节点不在直径上，有一个节点至少需要走完半径后再走向根节点） 寻找直径的方法，两次bfs和分治法，以为这题需要得到路径所以我用的是两次bfs，第一次从任意一个点o出发找到离它最远的点p，第二次再从q出发找离它最远的点q，p-q就是直径。 证明：如果p-q不是直径，那么假设直径为a-b 1）a-b与o-p相交于m，由于p是距离o最远的点，所以om+mp &gt; om+ma，mp&gt;ma，b-p&gt;a-b，与a-b直径矛盾 2）a-b与o-p不相交，那么两条路径间通过m-n连通，om+mp &gt; om+mn+nb，mp&gt;mn+nb，an+mn+mp &gt; an+mn+nb &gt; ab 与a-b直径矛盾 分治法的话就是从叶子节点开始，计算节点距离叶子节点的距离，父节点的最大距离=max(子节点) + 1，树形dp。还需要缓存下第二大距离，最后最远距离+次远距离就是直径长。 C++ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution &#123;public: vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; vector&lt;vector&lt;int&gt;&gt; head(n); vector&lt;int&gt; f(n, -1); for(int i = 0; i &lt; edges.size(); ++i) &#123; head[edges[i][0]].push_back(edges[i][1]); head[edges[i][1]].push_back(edges[i][0]); &#125; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(make_pair(-1, 0)); int last_node; while(!q.empty()) &#123; int sz = q.size(); for(int i = 0; i &lt; sz; ++i) &#123; pair&lt;int, int&gt; cur = q.front(); q.pop(); last_node = cur.second; int father = cur.first; for(int j = 0; j &lt; head[last_node].size(); ++j) &#123; if(head[last_node][j] == father) continue; q.push(make_pair(last_node, head[last_node][j])); &#125; &#125; &#125; int cur_node; q.push(make_pair(-1, last_node)); while(!q.empty()) &#123; int sz = q.size(); for(int i = 0; i &lt; sz; ++i) &#123; pair&lt;int, int&gt; cur = q.front(); q.pop(); cur_node = cur.second; int father = cur.first; f[cur_node] = father; for(int j = 0; j &lt; head[cur_node].size(); ++j) &#123; if(head[cur_node][j] == father) continue; q.push(make_pair(cur_node, head[cur_node][j])); &#125; &#125; &#125; vector&lt;int&gt; path; while(cur_node != last_node) &#123; path.push_back(cur_node); cur_node = f[cur_node]; &#125; path.push_back(last_node); vector&lt;int&gt; ans; if(path.size() % 2 == 1) &#123; ans.push_back(path[path.size() / 2]); &#125; else &#123; ans.push_back(path[path.size() / 2]); ans.push_back(path[path.size() / 2 - 1]); &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 309 Best Time to Buy and Sell Stock with Cooldown]]></title>
    <url>%2F2019%2F09%2F13%2Fleetcode309%2F</url>
    <content type="text"><![CDATA[炒股，能够买卖多次，但是每次买完需要等一天才能再次买入，问最多能赚多少钱 炒股系列第四题了，还是用动态规划来做，b代表当前已买入的情况下的最大收益，s[i]表示第i天前已卖出时的最大收益，prev_s表示上次在第i天卖出时的最大收益。 b = max(b, prev_s[i-2] - prices[i]); s[i] = max(prev_s[i], s[i-1], b+prices[i])分别表示上一次在第i天卖出，在第i天不卖出和在第i天卖出的最大值。 C++ Code 12345678910111213141516171819202122232425262728class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int sz = prices.size(); if(sz == 0) &#123; return 0; &#125; vector&lt;int&gt; s(sz, -0x7fffffff); vector&lt;int&gt; prev_s; int b = -0x7fffffff; for(int i = 0; i &lt; sz; ++i) &#123; b = max(b, -prices[i]); if(i &gt; 0) s[i] = s[i-1]; s[i] = max(s[i], prices[i] + b); &#125; for(int j = 2; j &lt; sz; j += 2) &#123; b = -0x7fffffff; prev_s = s; for(int i = j; i &lt; sz; ++i) &#123; b = max(b, prev_s[i-2] - prices[i]); s[i] = max(s[i], s[i-1]); s[i] = max(s[i], b + prices[i]); &#125; &#125; return s[sz-1]; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 287 Find the Duplicate Number]]></title>
    <url>%2F2019%2F09%2F09%2Fleetcode287%2F</url>
    <content type="text"><![CDATA[找到一组数组中重复出现的数（只有一个），空间复杂度O(1)，时间复杂度O(n^2)以内。 其实可以看做一个链表，每个index中存储的数可以看作next指针，这样一来，如果有一个index有两个指针指向它，则链表中一定存在环。所以可以考虑使用检测链表带环的算法，即快慢指针的方法，快指针一次走两步，慢指针一次走一步。这样快慢指针先后进入环后，由于每次快一步套圈，迟早会追及。 假设a为入圈前需要走的距离，追及的地点与入圈点距离为c，还剩x重新回到入圈点，快指针比慢指针多走了n圈，那么追及的时，慢指针走了a+c而快指针走了a+c+n(x+c)（已经合并(x+c)项）。且a+c+n(x+c) = 2*(a+c) 所以a = x + (n-1)(x+c)，那么接下来让快指针也一次一步地从起点处开始出发，慢指针继续往前走，最终就能在入圈点汇合。入圈点就是我们要求的重复的数。 C++ Code 12345678910111213141516171819202122class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;= 1) &#123; return -1; &#125; int fast = nums[nums[0]]; int slow = nums[0]; while(fast != slow) &#123; fast = nums[nums[fast]]; slow = nums[slow]; &#125; fast = 0; while(fast != slow) &#123; fast = nums[fast]; slow = nums[slow]; &#125; return fast; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 264 Ugly Number II]]></title>
    <url>%2F2019%2F08%2F22%2Fleetcode264%2F</url>
    <content type="text"><![CDATA[每一个Ugly Number必定由之前的某一Ugly Number （除了1之外）乘以2，3，5得到。用三个指针分别指向当前x2 x3 x5还没有放进队列的最小数，然后每次从三个数分别x2 x3 x5后取最小值作为新的加入队列的数，并且检查更新三个指针的指。 C++ Code 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: int min3(int a, int b, int c) &#123; if(a &lt; b) &#123; if(a &lt; c) return a; else return c; &#125;else &#123; if(b &lt; c) return b; else return c; &#125; &#125; int nthUglyNumber(int n) &#123; int *arr = new int[n]; arr[0] = 1; int k = 1; int index2 = 0, index3 = 0, index5 = 0; while(k &lt; n) &#123; arr[k] = min3(arr[index2] * 2, arr[index3] * 3, arr[index5] * 5); if(arr[k] == arr[index2] * 2) ++index2; if(arr[k] == arr[index3] * 3) ++index3; if(arr[k] == arr[index5] * 5) ++index5; ++k; &#125; int ans = arr[k-1]; delete [] arr; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Transformer结构及其应用--GPT、BERT、MT-DNN、GPT-2]]></title>
    <url>%2F2019%2F06%2F12%2FTransformer_Application%2F</url>
    <content type="text"><![CDATA[本文首先详细介绍Transformer的基本结构，然后再通过GPT、BERT、MT-DNN以及GPT-2等基于Transformer的知名应用工作的介绍并附上GitHub链接，看看Transformer如何在各个模型中中大显神威。 本文首发于知乎专栏：SoftWiser 一、取代RNN——Transformer在介绍Transformer前我们来回顾一下RNN的结构 对RNN有一定了解的话，一定会知道，RNN有两个很明显的问题 效率问题：需要逐个词进行处理，后一个词要等到前一个词的隐状态输出以后才能开始处理 如果传递距离过长还会有梯度消失、梯度爆炸和遗忘问题 为了缓解传递间的梯度和遗忘问题，设计了各种各样的RNN cell，最著名的两个就是LSTM和GRU了 LSTM (Long Short Term Memory) GRU (Gated Recurrent Unit) 但是，引用网上一个博主的比喻，这么做就像是在给马车换车轮，为什么不直接换成汽车呢？ 于是就有了我们本文要介绍的核心结构——Transformer。Transformer 是Google Brain 2017的提出的一篇工作，它针对RNN的弱点进行重新设计，解决了RNN效率问题和传递中的缺陷等，在很多问题上都超过了RNN的表现。Transfromer的基本结构如下图所示，它是一个N进N出的结构，也就是说每个Transformer单元相当于一层的RNN层，接收一整个句子所有词作为输入，然后为句子中的每个词都做出一个输出。但是与RNN不同的是，Transformer能够同时处理句子中的所有词，并且任意两个词之间的操作距离都是1，这么一来就很好地解决了上面提到的RNN的效率问题和距离问题。 每个Transformer单元都有两个最重要的子层，分别是Self-Attention层与Feed Forward层，后面会对这两个层的详细结构做介绍。文章使用Transformer搭建了一个类似Seq2Seq的语言翻译模型，并为Encoder与Decoder设计了两种不同的Transformer结构。 Decoder Transformer相对于Encoder Transformer多了一个Encoder-Decoder Attention层，用来接收来自于Encoder的输出作为参数。最终只要按照下图的方式堆叠，就可以完成Transformer Seq2Seq的结构搭建。 举个例子介绍下如何使用这个Transformer Seq2Seq做翻译 首先，Transformer对原语言的句子进行编码，得到memory。 第一次解码时输入只有一个&lt;SOS&gt;标志，表示句子的开始。 解码器通过这个唯一的输入得到的唯一的输出，用于预测句子的第一个词。 第二次解码，将第一次的输出Append到输入中，输入就变成了&lt;SOS&gt;和句子的第一个词(ground truth或上一步的预测)，解码生成的第二个输出用于预测句子的第二个词。以此类推(过程与Seq2Seq非常类似) 了解了Transformer的大致结构以及如何用它来完成翻译任务后，接下来就看看Transformer的详细结构： 核心组件就是上面所提到的Self-Attention和Feed Forward Networks，但还有很多其他细节，接下来我们就开始逐个结构的来解读Transformer。 Self Attention Self Attention就是句子中的某个词对于本身的所有词做一次Attention。算出每个词对于这个词的权重，然后将这个词表示为所有词的加权和。每一次的Self Attention操作，就像是为每个词做了一次Convolution操作或Aggregation操作。具体操作如下： 首先，每个词都要通过三个矩阵Wq, Wk, Wv进行一次线性变化，一分为三，生成每个词自己的query, key, vector三个向量。以一个词为中心进行Self Attention时，都是用这个词的key向量与每个词的query向量做点积，再通过Softmax归一化出权重。然后通过这些权重算出所有词的vector的加权和，作为这个词的输出。具体过程如下图所示 归一化之前需要通过除以向量的维度dk来进行标准化，所以最终Self Attention用矩阵变换的方式可以表示为 最终每个Self Attention接受n个词向量的输入，输出n个Aggregated的向量。 上文提到Encoder中的Self Attention与Decoder中的有所不同，Encoder中的Q、K、V全部来自于上一层单元的输出，而Decoder只有Q来自于上一个Decoder单元的输出，K与V都来自于Encoder最后一层的输出。也就是说，Decoder是要通过当前状态与Encoder的输出算出权重后，将Encoder的编码加权得到下一层的状态。 Masked Attention 通过观察上面的结构图我们还可以发现Decoder与Encoder的另外一个不同，就是每个Decoder单元的输入层，要先经过一个Masked Attention层。那么Masked的与普通版本的Attention有什么区别呢？ Encoder因为要编码整个句子，所以每个词都需要考虑上下文的关系。所以每个词在计算的过程中都是可以看到句子中所有的词的。但是Decoder与Seq2Seq中的解码器类似，每个词都只能看到前面词的状态，所以是一个单向的Self-Attention结构。 Masked Attention的实现也非常简单，只要在普通的Self Attention的Softmax步骤之前，与(&amp;)上一个下三角矩阵M就好了 Multi-Head Attention Multi-Head Attention就是将上述的Attention做h遍，然后将h个输出进行concat得到最终的输出。这样做可以很好地提高算法的稳定性，在很多Attention相关的工作中都有相关的应用。Transformer的实现中，为了提高Multi-Head的效率，将W扩大了h倍，然后通过view(reshape)和transpose操作将相同词的不同head的k、q、v排列在一起进行同时计算，完成计算后再次通过reshape和transpose完成拼接，相当于对于所有的head进行了一个并行处理。 Position-wise Feed Forward Networks Encoder中和Decoder中经过Attention之后输出的n个向量（这里n是词的个数）都分别的输入到一个全连接层中，完成一个逐个位置的前馈网络。 Add &amp; Norm 是一个残差网络，将一层的输入与其标准化后的输出进行相加即可。Transformer中每一个Self Attention层与FFN层后面都会连一个Add &amp; Norm层。 Positional Encoding 由于Transformer中既不存在RNN，也不同于CNN，句子里的所有词都被同等的看待，所以词之间就没有了先后关系。换句话说，很可能会带上和词袋模型相同的不足。为了解决这个问题，Transformer提出了Positional Encoding的方案，就是给每个输入的词向量叠加一个固定的向量来表示它的位置。文中使用的Positional Encoding如下： 其中pos是词在句子中的位置，i是词向量中第i位，即将每个词的词向量为一行进行叠加，然后针对每一列都叠加上一个相位不同或波长逐渐增大的波，以此来唯一区分位置。 Transformer 工作流程 Transformer的工作流程就是上面介绍的每一个子流程的拼接 输入的词向量首先叠加上Positional Encoding，然后输入至Transformer内 每个Encoder Transformer会进行一次Multi-head self attention-&gt;Add &amp; Normalize-&gt;FFN-&gt;Add &amp; Normalize流程，然后将输出输入至下一个Encoder中 最后一个Encoder的输出将会作为memory保留 每个Decoder Transformer会进行一次Masked Multi-head self attention-&gt;Multi-head self attention-&gt;Add &amp; Normalize-&gt;FFN-&gt;Add &amp; Normalize流程，其中Multi-head self attention时的K、V至来自于Encoder的memory。根据任务要求输出需要的最后一层Embedding。 Transformer的输出向量可以用来做各种下游任务 GitHub链接：https://github.com/harvardnlp/annotated-transformer Post Scriptum 虽然在Transformer文章中提出了一种自然语言翻译的模型，很多文章把这个模型称为Transformer。但我们还是倾向于将文章中利用Self-Attention的Encoder或Decoder的子结构称为Transformer。文中和源码中还包含了很多其他的一些优化例如学习率动态变化，Residual Dropout以及Label Smoothing在这里就不再赘述，有兴趣的朋友可以阅读相关参考文献进行了解。 二、单向二阶段训练模型——OpenAI GPTGPT(Generative Pre-Training)，是OpenAI在2018年提出的模型，利用Transformer模型来解决各种自然语言问题，例如分类、推理、问答、相似度等应用的模型。GPT采用了Pre-training + Fine-tuning的训练模式，使得大量无标记的数据得以利用，大大提高了这些问题的效果。 GPT就是利用Transformer进行自然语言各种任务的尝试之一，主要有以下三个要点 Pre-Training的方式 单向Transformer模型 Fine-Tuning与不同输入数据结构的变化 如果已经理解了Transformer的原理，那么只需要再搞懂上面的三个内容就能够对GPT有更深的认识。 Pre-Training 训练方式 很多机器学习任务都需要带标签的数据集作为输入完成。但是我们身边存在大量没有标注的数据，例如文本、图片、代码等等。标注这些数据需要花费大量的人力和时间，标注的速度远远不及数据产生的速度，所以带有标签的数据往往只占有总数据集很小的一部分。随着算力的不断提高，计算机能够处理的数据量逐渐增大。如果不能很好利用这些无标签的数据就显得很浪费。 所以半监督学习和预训练+微调的二阶段模式整变得越来越受欢迎。最常见的二阶段方法就是Word2Vec，使用大量无标记的文本训练出带有一定语义信息的词向量，然后将这些词向量作为下游机器学习任务的输入，就能够大大提高下游模型的泛化能力。 但是Word2Vec有一个问题，就是单个单词只能有一个Embedding。这样一来，一词多义就不能很好地进行表示。 ELMo首先想到了在预训练阶段为每个词汇集其上下文信息，使用的是基于bi-LSTM的语言模型给词向量带上上下文语义信息： 上式分别代表了左右两向的LSTM-RNN，他们共享输入的词向量X以及RNN各层权重S，也就是使用双向RNN两向的输出，来同时预测下一个单词(右向的下一个，左向的上一个)，具体结构如下图所示： 但ELMo使用的是RNN来完成语言模型的预训练，那么如何使用Transformer来完成预训练呢？ 单向Transformer结构 OpenAI GPT采用了单向Transformer完成了这项预训练任务。 什么是单向Transformer？在Transformer的文章中，提到了Encoder与Decoder使用的Transformer Block是不同的。在Decoder Block中，使用了Masked Self-Attention，即句子中的每个词，都只能对包括自己在内的前面所有词进行Attention，这就是单向Transformer。GPT使用的Transformer结构就是将Encoder中的Self-Attention替换成了Masked Self-Attention，具体结构如下图所示： 由于采用的是单向的Transformer，只能看到上文的词，所以语言模型为： 而训练的过程其实非常的简单，就是将句子n个词的词向量(第一个为&lt;SOS&gt;)加上Positional Encoding后输入到前面提到的Transfromer中，n个输出分别预测该位置的下一个词(&lt;SOS&gt;预测句子中的第一个词，最后一个词的预测结果不用于语言模型的训练)。 由于使用了Masked Self-Attention，所以每个位置的词都不会“看见”后面的词，也就是预测的时候是看不见“答案”的，保证了模型的合理性，这也是为什么OpenAI采用了单向Transformer的原因。 Fine-Tuning与不同输入数据结构的变化 接下来就进入模型训练的第二步，运用少量的带标签数据对模型参数进行微调。 上一步中最后一个词的输出我们没有用到，在这一步中就要使用这一个输出来作为下游监督学习的输入。 为避免Fine-Tuning使得模型陷入过拟合，文中还提到了辅助训练目标的方法，类似于一个多任务模型或者半监督学习。具体方法就是在使用最后一个词的预测结果进行监督学习的同时，前面的词继续上一步的无监督训练，使得最终的损失函数成为： 针对不同任务，需要修改输入数据的格式： Classification：对于分类问题，不需要做什么修改 Entailment：对于推理问题，可以将先验与假设使用一个分隔符分开 Similarity：对于相似度问题，由于模型是单向的，但相似度与顺序无关。所以需要将两个句子顺序颠倒后两次输入的结果相加来做最后的推测 Multiple Choice：对于问答问题，则是将上下文、问题放在一起与答案分隔开，然后进行预测 GitHub链接：https://github.com/openai/finetune-transformer-lm Post Scriptum OpenAI GPT在Transformer的运用和二阶段训练方式上做出了很好的探索，也取得了非常不错的效果，为后面的BERT铺平了道路。 三、双向二阶段训练模型——BERTBERT(Bidirectional Encoder Representation from Transformer)，是Google Brain在2018年提出的基于Transformer的自然语言表示框架。一提出就获得了大量的关注。BERT与GPT一样，采取了Pre-training + Fine-tuning的训练方式，在分类、标注等任务下都获得了更好的效果。 BERT与GPT非常的相似，都是基于Transformer的二阶段训练模型，都分为Pre-Training与Fine-Tuning两个阶段，都在Pre-Training阶段无监督地训练出一个可通用的Transformer模型，然后在Fine-Tuning阶段对这个模型中的参数进行微调，使之能够适应不同的下游任务。 虽然BERT与GPT看上去非常的相似，但是它们的训练目标和模型结构和使用上还是有着些许的不同： GPT采用的是单向的Transformer，而BERT采用的是双向的Transformer，也就是不用进行Mask操作； 使用的结构的不同，直接导致了它们在Pre-Training阶段训练目标的不同； 双向Transformer BERT采用的是不经过Mask的Transformer，也就是与Transformer文章中的Encoder Transformer结构完全一样： GPT中因为要完成语言模型的训练，也就要求Pre-Training预测下一个词的时候只能够看见当前以及之前的词，这也是GPT放弃原本Transformer的双向结构转而采用单向结构的原因。 BERT为了能够同时得到上下文的信息，而不是像GPT一样完全放弃下文信息，采用了双向的Transformer。但是这样一来，就无法再像GPT一样采用正常的语言模型来预训练了，因为BERT的结构导致每个Transformer的输出都可以看见整个句子的，无论你用这个输出去预测什么，都会“看见”参考答案，也就是“see itself”的问题。ELMo中虽然采用的是双向RNN，但是两个RNN之间是独立的，所以可以避免see itself的问题。 Pre-Training阶段 那么BERT想用双向的Transformer模型，就不得不放弃GPT中所采用的语言模型来作为预训练的目标函数。取而代之的，BERT提出了一种完全不同的预训练方法。 Masked Language Model (MLM) 在Transformer中，我们即想要知道上文的信息，又想要知道下文的信息，但同时要保证整个模型不知道要预测词的信息，那么就干脆不要告诉模型这个词的信息就可以了。也就是说，BERT在输入的句子中，挖掉一些需要预测的词，然后通过上下文来分析句子，最终使用其相应位置的输出来预测被挖掉的词。这其实就像是在做完形填空 (Cloze)一样。 但是，直接将大量的词替换为&lt;MASK&gt;标签可能会造成一些问题，模型可能会认为只需要预测&lt;MASK&gt;相应的输出就行，其他位置的输出就无所谓。同时Fine-Tuning阶段的输入数据中并没有&lt;MASK&gt;标签，也有数据分布不同的问题。为了减轻这样训练带来的影响，BERT采用了如下的方式： 输入数据中随机选择15%的词用于预测，这15%的词中， 80%的词向量输入时被替换为&lt;MASK&gt; 10%的词的词向量在输入时被替换为其他词的词向量 另外10%保持不动 这样一来就相当于告诉模型，我可能给你答案，也可能不给你答案，也可能给你错误的答案，有&lt;MASK&gt;的地方我会检查你的答案，没&lt;MASK&gt;的地方我也可能检查你的答案，所以&lt;MASK&gt;标签对你来说没有什么特殊意义，所以无论如何，你都要好好预测所有位置的输出。 Next Sentence Prediction (NSP) BERT还提出了另外一种预训练方式NSP，与MLM同时进行，组成多任务预训练。这种预训练的方式就是往Transformer中输入连续的两个句子，左边的句子前面加上一个&lt;CLS&gt;标签，它的输出被用来判断两个句子之间是否是连续上下文关系。采用负采样的方法，正负样本各占50%。 为了区分两个句子的前后关系，BERT除了加入了Positional Encoding之外，还两外加入了一个在预训练时需要学习的Segment Embedding来区分两个句子。这样一来，BERT的输入就由词向量、位置向量、段向量三个部分相加组成。此外，两个句子之间使用&lt;SEP&gt;标签予以区分。 整体Pre-Training的示意图如下： Fine-Tuning阶段 BERT的Fine-Tuning阶段和GPT没有太大区别。因为采用了双向的Transformer所以放弃了GPT在Fine-Tuning阶段使用的辅助训练目标，也就是语言模型。此外就是将分类预测用的输出向量从GPT的最后一个词的输出位置改为了句子开头&lt;CLS&gt;的位置了。不同的任务Fine-Tuning的示意图如下： GitHub链接：https://github.com/google-research/bert Post Scriptum 个人认为，BERT只是GPT模型的一种trade-off，为了在两个阶段都能够同时获得句子上下文的信息，使用了双向Transformer模型。但是为此却要付出失去传统语言模型的代价，转而采用MLM+NSP这种更加复杂的方式进行预训练。 四、多任务模型——MT-DNNMT-DNN (Multi-Task Deep Neural Networks) 依然采用了BERT的二阶段训练方法以及双向Transformer。在Pre-Training阶段，MT-DNN与BERT几乎完全一样，但是在Fine-Tuning阶段，MT-DNN采用了多任务的微调方式。同时采用Transformer输出的上下文Embedding进行单句分类、文本对相似度、文本对分类以及问答等任务的训练。整个结构如下图所示： GitHub链接：https://github.com/namisan/mt-dnn 五、单向通用模型——GPT-2GPT-2继续沿用了原来在GPT种使用的单向Transformer模型，而这篇文章的目的就是尽可能利用单向Transformer的优势，做一些BERT使用的双向Transformer所做不到的事。那就是通过上文生成下文文本。 GPT-2的想法就是完全舍弃Fine-Tuning过程，转而使用一个容量更大、无监督训练、更加通用的语言模型来完成各种各样的任务。我们完全不需要去定义这个模型应该做什么任务，因为很多标签所蕴含的信息，就存在于语料当中。就像一个人如果博览群书，自然可以根据看过的内容轻松的做到自动摘要、问答、续写文章这些事。 严格来说GPT-2可能不算是一个多任务模型，但是它确实使用相同的模型、相同的参数完成了不同的任务。那么GPT-2是怎么使用语言模型完成多种任务的呢？ 通常我们针对特定任务训练的专用模型，给定输入，就可以返回这个任务相应的输出，也就是 那么如果我们希望设计一个通用的模型，这个模型在给定输入的同时还需要给定任务类型，然后根据给定输入与任务来做出相应的输出，那么模型就可以表示成下面这个样子 就好像原来我需要翻译一个句子，需要专门设计一个翻译模型，想要问答系统需要专门设计一个问答模型。但是如果一个模型足够聪明，并且能够根据你的上文生成下文，那我们就可以通过在输入中加入一些标识符就可以区分各种问题。比如可以直接问他：(‘自然语言处理’, 中文翻译)来得到我们需要的结果Nature Language Processing。在我的理解中GPT-2更像是一个无所不知的问答系统，通过告知一个给定任务的标识符，就可以对多种领域的问答、多种任务做出合适的回答。GPT-2满足零样本设置 (zero-shot setting)， 在训练的过程中不需要告诉他应该完成什么样的任务，预测是也能给出较为合理的回答。 那么GPT-2为了做到上面这些要求，做了哪些工作呢？ 拓宽并加大数据集 首先就是要让模型博览群书，如果训练样本都不够多，那还怎么进行推理？前面的工作都是针对某一个特定问题的，所以数据集都比较片面。GPT-2收集了一个规模更大、范围更广的数据集。同时呢，要保证这个数据集的质量，保留那些拥有高质量内容的网页。最终组成了一个800万个文本，40G的数据集WebText。 扩大网络容量 书多了脑袋容量也得带一些要不然记不住书里的东西。为了提高网络的容量，使其拥有更强的学习潜力，GPT-2将Transformer堆叠的层数增加到48层，隐层的维度为1600，参数量达到了15亿。 调整网络结构 GPT-2将词汇表提升到50257，最大的上下文大小 (context size) 从GPT的512提升到了1024，batchsize从512提升为1024。此外还对Transformer做出了小调整，标准化层放到没每个sub-block之前，最后一个Self-attention后又增加了一个标准化层；改变了残差层的初始化方法等等。 GitHub链接：https://github.com/openai/gpt-2 Post Scriptum GPT-2其实最惊人的是其极强的生成能力，而如此强大的生成能力主要还是要归功于其数据质量以及惊人参数量和数据规模。GPT-2的参数量大到用于实验的模型都还处于欠拟合状态，如果接着训练，效果还能进一步提升。 六、总结总上面这些关于Transformer工作的发展中，我也整理出了一些关于深度学习发展趋势的个人心得： 有监督模型向半监督甚至无监督方向发展 数据的规模的增长速度远远超过了数据的标注速度，这也就导致了大量无标签数据的产生。这些无标签的数据并非没有价值，相反，如果找到合适的“炼金术”，将可以从这些海量的数据中获取意想不到的价值。如何利用上这些无标签的数据来改善任务的表现变成了一个越来越无法轻视的问题。 从少量数据复杂模型到大量数据简单模型 深度神经网络的拟合能力非常的强大，一个简单的神经网络模型就足以拟合任何函数。但无奈使用越简单的网络结构完成同一个任务，对数据量的要求也更高。数据量越是上升，数据质量越是提高，往往对模型的要求就会越会降低。数据量越大，模型就越容易捕捉到符合真实世界分布的特征。Word2Vec就是一个例子，它所使用的目标函数非常的简单，但是由于使用了大量的文本，于是训练出的词向量中就包含了许多有趣的特性。 从专用模型向通用模型发展 GPT、BERT、MT-DNN、GPT-2都使用了经过预训练的通用模型来继续进行下游的机器学习任务，并不需要对模型本身再做太多的修改。如果一个模型的表达能力足够的强，训练时候使用的数据量足够的大，那么模型的通用性就会更强，就不需要针对特定的任务做太多的修改。最极端的情况就像是GPT-2这个样子，训练时甚至完全不需要知道后续的下游任务是什么，就能够训练出一个通用的多任务模型。 对数据的规模和质量提高 GPT、BERT、MT-DNN、GPT-2虽然先后刷榜，但是我认为成绩的提升中，数据规模的提升占有比结构调整更大的比重。随着模型的通用化和简单化，为提升模型的性能，今后更多的注意力将会从如何设计一个复杂、专用的模型转移到如何获取、清洗、精化出质量更加出众的、大量的数据上。数据的处理方式调整的作用将会大于模型结构调整的作用。 综上所述，DL竞赛迟早要成为大厂间拼资源、拼算力的较量。可能几年内就会出现一个新的课题：绿色AI，低碳AI，可持续AI。。。 以上😂 参考文献[1] Vaswani A, Shazeer N, Parmar N, et al. Attention is All you Need[J]. neural information processing systems, 2017: 5998-6008. [2] http://nlp.seas.harvard.edu/2018/04/03/attention.html [3] https://jalammar.github.io/illustrated-transformer/ [4] Radford, Alec, et al. “Improving language understanding by generative pre-training.” URL https://s3-us-west-2. amazonaws. com/openai-assets/research-covers/languageunsupervised/language understanding paper. pdf (2018). [5] Peters M E, Neumann M, Iyyer M, et al. DEEP CONTEXTUALIZED WORD REPRESENTATIONS[J]. north american chapter of the association for computational linguistics, 2018: 2227-2237. [6] Devlin J, Chang M, Lee K, et al. BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding[J]. arXiv: Computation and Language, 2018. [7] Liu X, He P, Chen W, et al. Multi-Task Deep Neural Networks for Natural Language Understanding.[J]. arXiv: Computation and Language, 2019. [8] Radford A, Wu J, Child R, et al. Language models are unsupervised multitask learners[J]. OpenAI Blog, 2019, 1(8).]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Representation Learning</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kick start 2018 Round A]]></title>
    <url>%2F2019%2F05%2F17%2Fkickstart2018A%2F</url>
    <content type="text"><![CDATA[Even Digits Lucky Dip Scrambled Words Even Digits 给一个数，找离他最近的不包含奇数位的数。 思路：从左到右找第一个奇数，首先判断是要找比他大的数还是比他小的数（+1还是-1）。这取决于后面的数以及这位数的情况。 如果这位数位9，一定是找比他小的，因为+1将会造成进位，高位为了保持偶数需要进两位，肯定比-1要大。 如果后面的数小于4444……（字典序比较一下），则找比他小的，奇数位-1，后面改成8888…… 如果后面的数大于4444……，则找比他大的，奇数位+1（不是9，不会进位），后面改成0000…… 最后相减获得答案 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using std::cin;using std::cout;using std::endl;using std::string;bool judge(char* ch, int pos, int len) &#123; for(int i = pos; i &lt; len; ++i) &#123; if(ch[i] &gt; '4') &#123; return true; &#125;else if(ch[i] &lt; '4') &#123; return false; &#125; &#125; return true;&#125;int main() &#123; int t; char num[20]; char new_num[20]; long long ans; int flag; while(cin &gt;&gt; t) &#123; for(int c = 1; c &lt;= t; ++c) &#123; getchar(); scanf("%s", num); flag = -1; for(int i = 0; i &lt; strlen(num); ++i) &#123; new_num[i] = num[i]; if((num[i] - '0') % 2 == 1) &#123; if(i == strlen(num) - 1) &#123; --new_num[i]; flag = 0; break; &#125;else if(!judge(num, i+1, strlen(num)) || (num[i] - '0') == 9)&#123; --new_num[i]; flag = 0; ++i; while(i &lt; strlen(num)) &#123; new_num[i] = '8'; ++i; &#125; break; &#125;else &#123; ++new_num[i]; flag = 1; ++i; while(i &lt; strlen(num)) &#123; new_num[i] = '0'; ++i; &#125; break; &#125; &#125; &#125; new_num[strlen(num)] = '\0'; int tui = 0; ans = 0; long long pos = 1; if(flag &lt; 0) &#123; printf("Case #%d: %lld\n", c, 0); &#125;else if(flag == 0)&#123; for(int i = strlen(num)-1; i &gt;= 0; --i) &#123; int tmp = num[i] - new_num[i] - tui; if(tmp &lt; 0) &#123; tui = 1; tmp += 10; &#125;else&#123; tui = 0; &#125; ans += tmp * pos; pos *= 10; &#125; printf("Case #%d: %lld\n", c, ans); &#125;else&#123; for(int i = strlen(num)-1; i &gt;= 0; --i) &#123; int tmp = new_num[i] - num[i] - tui; if(tmp &lt; 0) &#123; tui = 1; tmp += 10; &#125;else&#123; tui = 0; &#125; ans += tmp * pos; pos *= 10; &#125; printf("Case #%d: %lld\n", c, ans); &#125; &#125; &#125; return 0;&#125; Lucky Dip 给定一堆数，问给定放回机会数的情况下采取最优策略抽取的数的期望是多少。 最优策略是若当前抽出的数小于当前的期望，有机会放回则放回重抽。所以每多一次机会的情况就是小于当前期望的所有数的期望变成当前的期望，然后计算新的期望。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int t, n, k; scanf("%d", &amp;t); double sum; double tmp_e; for(int c = 1; c &lt;= t; ++c) &#123; scanf("%d%d", &amp;n, &amp;k); sum = 0; vector&lt;long long&gt; arr(n); vector&lt;long long&gt; suffix_sum(n); for(int i = 0; i &lt; n; ++i) &#123; scanf("%lld", &amp;arr[i]); sum += arr[i]; &#125; tmp_e = sum / n; sort(arr.begin(), arr.end()); suffix_sum[n-1] = arr[n-1]; for(int i = n-2; i &gt;= 0; --i) &#123; suffix_sum[i] = suffix_sum[i+1] + arr[i]; &#125; for(int i = 0; i &lt; k; ++i) &#123; int l = 0, r = n-1; while(l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if(arr[mid] &lt; tmp_e) &#123; l = mid + 1; &#125;else &#123; r = mid - 1; &#125; &#125; if(l == 0) &#123; tmp_e = arr[0]; break; &#125;else &#123; tmp_e = (l * tmp_e + suffix_sum[l]) / n; &#125; &#125; printf("Case #%d: %.6lf\n", c, tmp_e); &#125; return 0;&#125; Scrambled Words 给定一段文本的生成规则，生成文本后，给定一个字典，问有多少个字典中的词的乱序（除了首位字母之外，其他字母可以随意排列）在文本中出现。 由于字典中词不同的长度种类不会太多，题目中说总长度为1e5，那么长度数X*(X+1) &lt;= 1e5 所以统计不同的长度，使用字符串的首尾字符以及字符的频数来作为一个字符串的key建立hash表。 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;list&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;algorithm&gt;#include &lt;array&gt;#include &lt;set&gt;#include &lt;stdio.h&gt;#define NUM_CHARACTER 26using namespace std;struct Key &#123; char first; char last; array&lt;int, NUM_CHARACTER&gt; freq; Key(string &amp;s) &#123; freq.fill(0); first = s[0]; last = s[s.size()-1]; for(int j = 0; j &lt; s.size(); ++j) &#123; ++freq[s[j] - 'a']; &#125; &#125; bool operator==(const Key &amp;k) const &#123; return (first == k.first &amp;&amp; last == k.last &amp;&amp; freq == k.freq); &#125;&#125;;namespace std &#123; template&lt;&gt; struct hash&lt;Key&gt; &#123; size_t operator()(const Key &amp;k) const &#123; size_t ret = 17, seed = 31; ret = ret * seed + k.first; ret = ret * seed + k.last; for(auto item: k.freq) &#123; ret = ret * seed + item; &#125; return ret; &#125; &#125;;&#125;int main() &#123; int t, l, n; long long a, b, c, d; char s1, s2; string tmp; string text; scanf("%d", &amp;t); unordered_map&lt;Key, int&gt; mp; unordered_set&lt;int&gt; len_set; vector&lt;int&gt; x; for(int ca = 1; ca &lt;= t; ++ca) &#123; mp.clear(); len_set.clear(); scanf("%d", &amp;l); for(int i = 0; i &lt; l; ++i) &#123; cin &gt;&gt; tmp; len_set.insert(tmp.size()); Key key(tmp); ++mp[key]; &#125; cin &gt;&gt; s1 &gt;&gt; s2; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; x.resize(n); text.resize(n); text[0] = s1; text[1] = s2; x[0] = text[0]; x[1] = text[1]; for(int i = 2; i &lt; n; ++i) &#123; x[i] = (a * x[i-1] + b * x[i-2] + c) % d; s1 = (97 + (x[i] % 26)); text[i] = s1; &#125; int ans = 0; for(int len: len_set) &#123; if(len &gt; n) &#123; continue; &#125; int l_pos = 0; int r_pos = len-1; string tmp_str = text.substr(l_pos, len); Key len_key(tmp_str); while(r_pos &lt; text.size()) &#123; auto iter = mp.find(len_key); if(iter != mp.end()) &#123; ans += iter-&gt;second; mp.erase(iter); &#125; --len_key.freq[text[l_pos] - 'a']; ++l_pos; ++r_pos; if(r_pos &lt; text.size()) &#123; ++len_key.freq[text[r_pos] - 'a']; len_key.first = text[l_pos]; len_key.last = text[r_pos]; &#125; &#125; &#125; printf("Case #%d: %d\n", ca, ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>kick start</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kick start 2018 Round B]]></title>
    <url>%2F2019%2F05%2F17%2Fkickstart2018B%2F</url>
    <content type="text"><![CDATA[No Nine No Nine 给定一个区间[x1, x2]，确定区间内有多少个不包含9且不被9整除的数，由于两个端点都是非9数，就是求[0, x1], [0, x2]的差+1。 如果只找不包含9的数。其实就是找如果把九进制数当作十进制来看的话，落在这个区间内的九进制数有多少个0-8，10-18，…… 从十位(第1位)数开始往后，每位下面都包含完整9^i个数 算出来有多少个不包含9的数之后，就要去掉9的倍数，最后正好每组9个数中有1个是9的倍数 例如12345，剔除包含9的数之后剩下9个一组的00000-00008，00010-00018，……，12330-12338。每一组必定只有一个9的倍数，所以*8/9 最后再加上12340-12345中不是9的倍数的数就行。 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string&gt;using namespace std;long long solve(long long n) &#123; long long ans = 0; long long last_ans = 0; long long n_0 = n % 10; for(long long i = 0; i &lt;= n_0; ++i) &#123; if((n - i) % 9 != 0) &#123; ++last_ans; &#125; &#125; long long cnt = 9; n /= 10; while(n &gt; 0) &#123; long long pos = n % 10; ans += pos * cnt; n /= 10; cnt *= 9; &#125; ans = ans / 9 * 8; return last_ans + ans;&#125;int main() &#123; int t; cin &gt;&gt; t; long long f, l; for(int c = 1; c &lt;= t; ++c) &#123; cin &gt;&gt; f &gt;&gt; l; long long ans = solve(l) - solve(f) + 1; printf("Case #%d: %lld\n", c, ans); &#125; return 0;&#125; Sherlock and the Bit Strings 给定一个01字符串的长度以及一些限制(a, b, c)，保证[a, b]区间内的1的个数恰好为c，同时返回满足条件的第p个字典序解。 用动态规划，dp[i][j]代表前i个bit确定并且前i个中最后15个bit（题目中说b-a不超过15）与j的二进制表示相同时解的个数。用一个limits数组记录每个位置为右端点b的时候限制的区间长度（b-a+1）和限制数c。每次检查的时候都将送进来的j的后b-a+1位与1然后计算个数。 初始化：dp[n][j] = 1 if 不违背限制 else 0 递推：dp[i][j] = dp[i+1][(j&lt;&lt;1)&amp;((1&lt;&lt;16) - 1)] + dp[i+1][(j&lt;&lt;1))&amp;((1&lt;&lt;16) - 1) + 1] if j不违背限制 else 0 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;string.h&gt;#define N 100using namespace std;const long long max_p = 1e18;vector&lt;pair&lt;int, int&gt;&gt; limits[N+1];long long dp[N+1][1&lt;&lt;16];int cnt[1&lt;&lt;16];int shl[1&lt;&lt;16];bool check(int pos, int status) &#123; for(int i = 0; i &lt; limits[pos].size(); ++i) &#123; if(cnt[status &amp; ((1 &lt;&lt; limits[pos][i].first) - 1)] != limits[pos][i].second) &#123; return false; &#125; &#125; return true;&#125;int main() &#123; cnt[0] = 0; shl[0] = 0; for(int i = 1; i &lt; (1&lt;&lt;16); ++i) &#123; cnt[i] = cnt[i&gt;&gt;1] + (i &amp; 1); shl[i] = (i &lt;&lt; 1) &amp; ((1 &lt;&lt; 16) - 1); &#125; int t, n, k, a, b, c; long long p; scanf("%d", &amp;t); for(int ca = 1; ca &lt;= t; ++ca) &#123; scanf("%d%d%lld", &amp;n, &amp;k, &amp;p); for(int i = 1; i &lt;= n; ++i) &#123; limits[i].clear(); &#125; for(int i = 0; i &lt; k; ++i) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); limits[b].push_back(make_pair(b-a+1, c)); &#125; memset(dp, 0, sizeof(dp)); for(int j = 0; j &lt; (1&lt;&lt;16); ++j) &#123; if(check(n, j)) &#123; dp[n][j] = 1; &#125; &#125; for(int i = n-1; i &gt;= 1; --i) &#123; for(int j = 0; j &lt; (1&lt;&lt;16); ++j) &#123; if(check(i, j)) &#123; dp[i][j] = dp[i+1][shl[j]] + dp[i+1][shl[j] ^ 1]; if(dp[i][j] &gt; max_p) &#123; dp[i][j] = max_p+1; &#125; &#125; &#125; &#125; printf("Case #%d: ", ca); for(int i = 1, j = 0; i &lt;= n; ++i, j = shl[j]) &#123; if(dp[i][j] &gt;= p) &#123; printf("0"); &#125;else &#123; p -= dp[i][j]; j ^= 1; printf("1"); &#125; &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>kick start</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 134 Gas Station]]></title>
    <url>%2F2019%2F05%2F16%2Fleetcode134%2F</url>
    <content type="text"><![CDATA[其实就是找到序列中最大和序列，数量为gas[i] - cost[i]，寻找的方法一样，然后就是从先走这个最大序列和的序列，然后再走之前和为负的序列。要计算和为负的累计。 C++ Code 12345678910111213141516171819class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int ans = 0, left = 0, accumulate = 0; for(int i = 0; i &lt; gas.size(); i++)&#123; left += gas[i] - cost[i]; if(left &lt; 0)&#123; ans = i+1; accumulate += left; left = 0; &#125; &#125; if(left + accumulate &gt;= 0)&#123; return ans; &#125;else&#123; return -1; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 240 Search a 2D Matrix II]]></title>
    <url>%2F2019%2F05%2F03%2Fleetcode240%2F</url>
    <content type="text"><![CDATA[可以从右上角或者左下角开始。以右上角为例，若这个数比target大，那么这一列都不可能，若比target小，那么这一行都不可能。这样逐渐收缩都target的位置。如果到最后都没找到target，返回false C++ Code 123456789101112131415161718192021222324class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; int n = matrix.size(); if(n == 0) &#123; return false; &#125; int m = matrix[0].size(); if(m == 0) &#123; return false; &#125; int x = 0, y = m-1; while(x &lt; n &amp;&amp; y &gt;= 0) &#123; if(matrix[x][y] == target) &#123; return true; &#125;else if(matrix[x][y] &lt; target) &#123; ++x; &#125;else &#123; --y; &#125; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 239 Sliding Window Maximum]]></title>
    <url>%2F2019%2F05%2F02%2Fleetcode239%2F</url>
    <content type="text"><![CDATA[单调队列 设置一个双向队列，按顺序将数组的下标push到队列尾，保证下标的升序，每次都检查队列头的下标是否超出了窗口，超出则pop队列头。 另外push新的下标前，要将之前下标中存储的数比自己小的pop掉。这样就能够保证所有下标对应的数是降序的。每次论队列头就是当前窗口中最大的数。 C++ Code 12345678910111213141516171819class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ n = len(nums) if n % 2 == 0: half = n // 2 else: half = n // 2 + 1 cnt = &#123;&#125; for i in range(n): if not cnt.has_key(nums[i]): cnt[nums[i]] = 1 else: cnt[nums[i]] += 1 if cnt[nums[i]] &gt;= half: return nums[i]]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络表示学习(一)--DeepWalk、LINE、Node2Vec、HARP、GraphGAN]]></title>
    <url>%2F2019%2F04%2F30%2Fnetwork_struct%2F</url>
    <content type="text"><![CDATA[图结构数据是除了图片、文本、语音之外又一常见且重要的数据类型，例如社交网络数据、引用网络数据、和生物蛋白质数据等等。在针对图像、文本等数据的机器学习任务中，都有相对应的方法，将这些数据中的特征用一个稠密向量进行表示，然后再运用于各种各样的任务中去。网络表示学习就是将网络中结点的特征，嵌入(Embedding)至低位向量中的方法。学习到的这些向量将会保留图结构数据结点的相似性，使得一些下游机器学习任务，例如结点分类、结点聚类、连接预测、可视化等等的模型泛化性能得到增强。 本文首先将会介绍网络表示学习最为著名的四份工作：DeepWalk、LINE、Node2Vec和SDNE。 然后将会介绍两篇在AAAI18上的两篇网络结构表示学习的新工作HARP、GraphGAN 本文首发于知乎专栏：SoftWiser 一、DeepWalk: Online Learning of Social RepresentationsDeepWalk可以称得上是这个方向上最著名的工作了，几乎所有网络表示学习相关的论文，都会引用DeepWalk作为Baseline之一，同时DeepWalk也是很多相关工作所使用的底层方法之一。可见这份工作在网络表示学习领域的地位。 Method DeepWalk最主要的贡献就是他将Network Embedding与自然语言处理中重要的Word Embedding方法Word2Vec联系了起来，使得Network Embedding问题转化为了一个Word Embedding问题。 转化方法其实很简单，就是随机游走。如下图所示，DeepWalk通过从每个结点出发n_walks次，每一步都采取均匀采样的方式选择当前结点的邻接结点作为下一步的结点随机游走。当游走的路径长度达到walk_length后，停止一次游走。这样就生成了一个个游走的序列，每个序列都称为一个walk。每个walk都被当成Word2Vec中的一个句子，而每个结点都是Word2Vec中的一个词。 之后的算法几乎和Word2Vec的Skipgram版本完全一样。使用一个大小为window_size的滑动窗口作为一条walk的context，使用一个context中的中心词去推测所有context中的其他词，使用的目标函数也与Word2Vec一致。 Experiments DeepWalk选择Multi-Label Classification作为评价算法Performance的指标。评价中将通过DeepWalk学习获得的Embedding按照不同的比例划分为训练集与测试集。训练集作为N个one-vs-rest对率回归分类器的训练数据，将其中置信度最高的k个类别作为结点的预测类别。其中N为类别的个数，k为结点的标签数。 实验结果如下所示： 二、LINE: Large-scale Information Network Embedding虽然DeepWalk通过随机游走的方式，将图结构数据转化为了自然语言处理的任务来完成。但是，图结构中节点的关系往往比词上下文关系更加的复杂。通常部分的图结构数据中边具有权重，使用现有的Word2Vec方法无法很好的应对这个问题。此外，在现实世界数据中，图的规模往往过于庞大，以至于存下所有的walk的开销将十分惊人。 Method LINE不再采用随机游走的方法。相反，他在图上定义了两种相似度——一阶相似度与二阶相似度。 一阶相似度：一阶相似度就是要保证低维的嵌入中要保留两个结点之间的直接联系的紧密程度，换句话说就是保留结点之间的边权，若两个结点之间不存在边，那么他们之间的一阶相似度为0。例如下图中的6、7两个结点就拥有很高的一阶相似度。 二阶相似度：二阶相似度用一句俗话来概括就是“我朋友的朋友也可能是我的朋友”。他所比较的是两个结点邻居的相似程度。若两个结点拥有相同的邻居，他们也更加的相似。如果将邻居看作context，那么两个二阶相似度高的结点之间拥有相似的context。这一点与DeepWalk的目标一致。例如下图中的5、6两点拥有很高的二阶相似度。 LINE的目标就是保留这两种相似度。 LINE的一阶相似度 两个结点实际的一阶相似度表达如下： 其中W是所有边权重之和。而两个结点embedding之间的相似度为： 其中u是结点的embedding。即两个结点表示的内积套上一个 对率函数的结果。这样一来目标函数设为实际相似度与表示相似度之间的KL散度就可以了，这样一来，只要最小化KL散度(下式中约去了一些常数)，就能保证表示相似度尽量接近实际相似度。 LINE的二阶相似度 两个结点实际的二阶相似度表达式如下： 其中wij是边ij的权重，di是结点i的出度。两个结点embedding的相似度为： 其中V为结点i的所有邻居，这里与一阶相似度不同的地方是，对于邻居结点，使用了另一组的embedding，称作context。目标函数依旧是KL散度，也就是最终，拥有相似邻居的结点，将会拥有相近的embedding。 最终要获得同时包含有一阶相似度和二阶相似度的embedding，只需要将通过一阶相似度获得的embedding与通过二阶相似度获得的embedding拼接即可。 Experiments 同样也来看一下LINE在结点分类任务中的表现： 可以看到，当考虑到一阶相似度之后，也就是边的权重后，LINE的表现效果要略好于DeepWalk。 三、Node2Vec: Scalable Feature Learning for NetworksNode2Vec是一份基于DeepWalk的延伸工作，它改进了DeepWalk随机游走的策略。 Method Node2Vec认为，现有的方法无法很好的保留网络的结构信息，例如下图所示，有一些点之间的连接非常紧密(比如u, s1, s2, s3, s4)，他们之间就组成了一个社区(community)。网络中可能存在着各种各样的社区，而有的结点在社区中可能又扮演着相似的角色(比如u与s6)。 Node2Vec的优化目标为以下两个： 让同一个社区内的结点表示能够相互接近，或 在不同社区内扮演相似角色的结点表示也要相互接近。 为此，Node2Vec就要在DeepWalk现有的基础上，对随机游走的策略进行优化。Node2Vec提出了两种游走策略： 广度优先策略 深度优先策略 就如上图的标注所示，深度优先游走策略将会限制游走序列中出现重复的结点，防止游走掉头，促进游走向更远的地方进行。而广度优先游走策略相反将会促进游走不断的回头，去访问上一步结点的其他邻居结点。 这样一来，当使用广度优先策略时，游走将会在一个社区内长时间停留，使得一个社区内的结点互相成为context，这也就达到了第一条优化目标。相反，当使用深度优先的策略的时候，游走很难在同一个社区内停留，也就达到了第二条优化目标。 那么如何达到这样的两种随机游走策略呢，这里需要用到两个超参数p和q用来控制深度优先策略和广度优先策略的比重，如下图所示。 假设现在游走序列从t走到v，这时候需要算出三个系数，分别作为控制下一步走向方向的偏置α 其中d(t, x)代表t结点到下一步结点x的最短路，最多为2。 当d(t, x)=0时，表示下一步游走是回到上一步的结点； 当d(t, x)=1时，表示下一步游走跳向t的另外一个邻居结点； 当d(t, x)=2时，表示下一步游走向更远的结点移动。 而Node2Vec同时还考虑了边权w的影响，所以最终的偏置系数以及游走策略为 这样一来，就可以看出，超参数p控制的是重新访问原来结点的概率，也就是保守探索系数，而超参数q控制的是游走向更远方向的概率，也就是激进探索系数。如果q较大，那么游走策略则更偏向于广度优先策略，若q较小，则偏向于深度优先策略。 Experiments 多标签分类任务中可以看出，当调整好适当的p、q值之后，Node2Vec的效果要略好于DeepWalk 四、SDNE: Structural Deep Network EmbeddingLINE中提到了一阶相似度以及二阶相似度的概念，那么有没有什么办法，通过深度学习，直接将这两种相似度保留在Embedding中的方法呢？ SDNE提出了这样一个框架，能够使用深度自编码器，在训练的过程中，同时获得节点的一阶相似度和二阶相似度。首先，上面提到了二阶相似度其实是节点邻域的相似程度。换句话说，这样的相似度，其实就直接包含在邻接矩阵S的每一行中。所以SDNE直接使用一个深度自编码器，学习网络邻接矩阵的编码与重构，这样一来，二阶相似度就被保留在了Embedding中，训练相对应的损失函数为 其中x为邻接矩阵的每一行而hat{x}则代表了自编码器重构以后的邻接矩阵。B=1-S，即只针对不直接相邻的节点对进行训练。 接下来就是针对一阶相似度的损失函数了，其实很直接，因为我们最终是将自编码器的隐层当作最终的节点Embedding，所以可以直接像LINE里一样，直接使存在边的两个节点的Embedding相互接近就行了，具体的损失函数如下 y也就是我们获得的自编码器的隐层。 所以总体的结构如下所示 五、HARP: Hierarchical Representation Learning for Networks上面介绍了DeepWalk、LINE、Node2Vec三个网络表示学习中最为著名的三种算法。但是，这三个算法都有一个共同的弱点，那就是他们所捕捉的网络结点关系过近，都是局部邻居。LINE仅仅只考虑到了一阶邻居与二阶邻居之间的相似度关系。DeepWalk与Node2Vec虽然可以通过随机游走，获得较长的游走序列，但是游走的长度比起现在图数据的规模，随机游走的长度还是太短了。所以就需要想一种方法捕捉全局的相似度。 Method HARP采取的方式就是通过多次折叠，将原来的大图层层收缩为较小的图，使得通过较短的随机游走距离，就能够覆盖所有的网络结点，然后将小图作为DeepWalk、LINE或Node2Vec的输入，学习Embedding。最后将在收缩后的小图中学习到的Embedding作为折叠前的的图的Embedding的初始化，继续学习折叠前的图的Embedding。以此类推层层学得原来大图的Embedding。HARP的算法流程如下图所示。 图折叠算法 那么要理解HARP这个算法的关键，就在于图折叠算法。HARP的图折叠算法，主要有以下两种方法 边折叠 (Edge Collapsing) 边折叠算法选择尽可能多的边，这些边没有共同的顶点，即每个顶点只有一条与之连接的边被选中。然后，如下图(a)所示，这些边被折叠成为一个结点，成为了折叠后的新结点。 星折叠 (Star Collapsing) 虽然边折叠在最好的情况下每一轮折叠可以将结点的数量缩减一半，这样一来图折叠算法的总次数为O(logk)。但在某些特殊情况下却不能很好的发挥作用。如下图(b)所示，星形结构是网络中最常见结构之一，在这种结构中，如果使用边折叠算法，那么就至多只能折叠一条边，算法要执行的总次数则会退化为O(k)。所以，HARP采用了另外一种折叠策略，就是星折叠。如下图(c)所示，星状网络中有两种结点，中心结点和周围节点，星折叠方法就是将同一个中心结点的周围结点两两配对，折叠成一个结点，来尽量减少星状结构的周围结点，以增强边折叠的效率。 HARP在每次折叠的时候，先是使用星折叠减少星形结构，然后再执行一次边折叠。具体的图折叠算法流程如下面的伪代码所示。 Experiment 通过HARP的多标签分类结果可以看出，使用HARP的图折叠和层级训练的手段后，相较于其相应的底层算法，都有一定的提升。实际上，经过我本人的实验，在更大规模的图上(结点数量达到数十万甚至上百万时)，这样的提升将会更加明显。 六、GraphGAN: Graph Representation Learning with Generative Adversarial NetsGraphGAN这份工作，顾名思义，就是尝试使用生成对抗网络(Generative Adversarial Nets, GAN)来增强网络表示学习的表现。 Method 要是理解GAN，那么GraphGAN的大题模块及其作用应该就能够很容易地想到。GraphGAN一共包含两个主要的模块： 判别器 由于Network Embedding任务大多是无监督，结点本身不带有任何标签，所以判别器要判别的就是网络自身带有的信息，也就是连接信息。GraphGAN中的判别器实际上就是一个连接预测器，通过输入两个结点的Embedding来判定两个结点之间是否存在一条边。 生成器 生成器的作用就是通过合理的方式生成一些点对，然后将这些点对输入到判别器中，尽量让判别器将这两个点对误认为是在图上存在边的两个结点的Embedding。 之后的训练过程就是生成器与判别器较量的过程。生成器不断调整每个结点的Embedding以及自己的参数，使得按照自己的规则生成出来的两个就节点对能够被判别器判别成为存在连接。而判别器则通过调整自身的参数，使自己能够准确的将图中实际存在边的结点对判定为true而将生成器生成的结点对判定为false。他们两个共同组成GraphGAN的目标函数： Implemention 那么GraphGAN中的判别器与生成器具体是怎么实现的呢？ 前面介绍的DeepWalk、LINE、Node2Vec等方法都是先获得一些context，然后通过训练使得这些结点的Embedding相互接近，然后通过随机的负采样得到一些负样本，让这些负样本的结点之间的Embedding相互远离。事实上GraphGAN的判别器与前面工作的context训练非常相似，也是让ground truth的Embedding相互接近，让生成器生成的节点对的Embedding相互远离。 这样一来生成器看似是代替了原来负采样的过程，然而生成器却需要能够生成与ground truth尽量相似的数据，这就与原来的负采样不太一致。那么这是为什么呢？ 产生这样疑惑的原因是我们从以判别器为主的角度来看待这个模型。如果我们从生成器的角度来理解这个模型的时候，这些疑惑就会得到解释。判别器仅仅只是作为训练时的目标函数的实现，它起到的作用有两个，一是让ground truth相互接近，另外一个就是给生成器提供损失函数。而一个经过精心设计的生成器，就可以利用这样的损失函数，训练出我们需要的Embedding。 下面就来介绍一下GraphGAN的生成器是如何工作的。 首先，生成器要遵守以下三个原则： Normalized，即所有结点被当作负样本的概率之和为1； Graph-structure-aware，结点被选中负样本的概率随着据中心结点的最短路增大而减小； Computational efficient，不能针对所有结点来计算softmax，只能关联到一个结点的小子集。 算法开始前，需要生成每个结点的BFS树，然后为了选取某一个结点的负采样，需要沿着该结点的BFS树向下或向上遍历。从某个父节点转移到它的子节点或父节点的概率为： 然后，一个结点最终被选取为起始结点的负样本的概率为： 以下图为例子，给定一个图，现在要从vc这个点开始负采样，那么先以vc为根生成BFS树。然后再算出每个结点与其子结点的转移概率，通过这个概率采样子节点，直到哪个结点被遍历了两次，结束。输出这个重复遍历的结点作为负样本。这个遍历过程中涉及到的所有其他结点(绿色结点)都要在训练中训练到。 这样的作法复合上面提出的三种原则，论文中给出了详细的证明。 Experiment 同样来看看GraphGAN的多标签分类的实验结果 七、总结本文介绍了几种针对网络结构进行表示学习的方法，首先是DeepWalk、LINE、Node2Vec三个最为著名的工作。之后介绍了近两年的一些针对网络结构的网络表示方法HARP和GraphGAN，了解近些年针对结构的网络表示学习的一些新思路。但是，现实中的网络中的内容远远不止结构这么简单。网络中的结点可能有不同的类别，每种结点又可能有不同的属性。所以，还需要有针对利用网络中其他信息的相关研究。 八、参考文献[1] Perozzi B, Al-Rfou R, Skiena S. Deepwalk: Online learning of social representations[C]//Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2014: 701-710. [2] Tang J, Qu M, Wang M, et al. Line: Large-scale information network embedding[C]//Proceedings of the 24th international conference on world wide web. International World Wide Web Conferences Steering Committee, 2015: 1067-1077. [3] Grover A, Leskovec J. node2vec: Scalable feature learning for networks[C]//Proceedings of the 22nd ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2016: 855-864. [4] Wang D, Cui P, Zhu W, et al. Structural Deep Network Embedding[C]. knowledge discovery and data mining, 2016: 1225-1234. [5] Chen H, Perozzi B, Hu Y, et al. Harp: Hierarchical representation learning for networks[C]//Thirty-Second AAAI Conference on Artificial Intelligence. 2018. [6] Wang H, Wang J, Wang J, et al. Graphgan: Graph representation learning with generative adversarial nets[C]//Thirty-Second AAAI Conference on Artificial Intelligence. 2018.]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Representation Learning</tag>
        <tag>Network Embedding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习中的优化算法（Optimizer）理解与python实现]]></title>
    <url>%2F2019%2F04%2F27%2Foptimizer_nesterov%2F</url>
    <content type="text"><![CDATA[本篇笔记介绍深度学习中最简单的三种优化算法，SGD，Momentum，Nestrov的理解与实现 一、SGD随机梯度下降法不用多说，每一个参数按照梯度的方向来减小以追求最小化损失函数 更新方式 Python实现 1234567class SGD: def __init__(self, lr=0.01): self.lr = lr def update(self, params, grads): for key in params.keys(): params[key] -= self.lr * grads[key] 二 、Momentum在梯度下降的基础上加入了动量，即前面的梯度将会影响本轮的梯度方向 更新方式 Python实现 123456789101112131415class Momentum: def __init__(self, lr=0.01, momemtum=0.9): self.lr = lr self.momemtum = momemtum self.v = None def update(self, params, grads): if self.v is None: self.v = &#123;&#125; for key, val in params.items(): self.v[key] = np.zeros_like(val) for key in params.keys(): self.v[key] = self.momemtum * self.v[key] - self.lr * grads[key] params[key] += self.v[key] 三、NestrovNestrov也是一种动量更新的方式，但是与普通动量方式不同的是，Nestrov为了加速收敛，提前按照之前的动量走了一步，然后求导后按着梯度再走一步 更新方式 但是这样一来，就给实现带来了很大的麻烦，因为我们当前是在W的位置上，无法求得W+αv处的梯度，所以我们要进行一定改变。由于W与W+αv对参数来说没有什么区别，所以我们可以假设当前的参数就是W+αv。就像下图，按照Nestrov的本意，在0处应该先按照棕色的箭头走αv到1，然后求得1处的梯度，按照梯度走一步到2。 现在，我们假设当前的W就是1处的参数，但是，当前的动量v仍然是0处的动量，那么更新方式就可以写作 这样一来，动量v就更新到了下一步的2处的动量。但是下一轮的W相应的应该在3处，所以W还要再走一步αv，即完整的更新过程应该如下所示： 第二行的v是第一行更新的结果，为了统一v的表示，更新过程还可以写作： Python实现 123456789101112131415class Nestrov: def __init__(self, lr=0.01, momentum=0.9): self.lr = lr self.momentum = momentum self.v = None def update(self, params, grads): if self.v is None: self.v = &#123;&#125; for key, val in params.items(): self.v[key] = np.zeros_like(val) for key in params.keys(): self.v[key] = self.momentum * self.v[key] - self.lr * grads[key] params[key] += self.momentum * self.v[key] - self.lr * grads[key] 但是根据我看到的各个框架的代码，它们好像都把动量延迟更新了一步，所以实现起来有点不一样（或者说是上下两个式子的顺序进行了颠倒），我也找不到好的解释，但是再MNIST数据集上最终的结果要好于原来的实现。 Python实现 1234567891011121314151617class Nestrov: def __init__(self, lr=0.01, momentum=0.9): self.lr = lr self.momentum = momentum self.v = None def update(self, params, grads): if self.v is None: self.v = &#123;&#125; for key, val in params.items(): self.v[key] = np.zeros_like(val) for key in params.keys(): self.v[key] *= self.momentum self.v[key] -= self.lr * grads[key] params[key] += self.momentum * self.momentum * self.v[key] params[key] -= (1 + self.momentum) * self.lr * grads[key] 四、AdaGrad前面介绍了几种动量法，动量法旨在通过每个参数在之前的迭代中的梯度，来改变当前位置参数的梯度，在梯度稳定的地方能够加速更新的速度，在梯度不稳定的地方能够稳定梯度。 而AdaGrad则是一种完全不同的思路，它是一种自适应优化算法。它通过每个参数的历史梯度，动态更新每一个参数的学习率，使得每个参数的更新率都能够逐渐减小。前期梯度加大的，学习率减小得更快，梯度小的，学习率减小得更慢些。 更新过程为 其中δ用于防止除零错 Python实现 1234567891011121314class AdaGrad: def __init__(self, lr=0.01): self.lr = lr self.h = None def update(self, params, grads): if self.h is None: self.h = &#123;&#125; for key, val in params.items(): self.h[key] = np.zeros_like(val) for key in params.keys(): self.h[key] += grads[key] * grads[key] params[key] -= self.lr * grads[key] / (np.sqrt(self.h[key]) + 1e-7) 五、RMSpropAdaGrad有个问题，那就是学习率会不断地衰退。这样就会使得很多任务在达到最优解之前学习率就已经过量减小，所以RMSprop采用了使用指数衰减平均来慢慢丢弃先前得梯度历史。这样一来就能够防止学习率过早地减小。 更新过程如下： Python实现 12345678910111213141516class RMSprop: def __init__(self, lr=0.01, decay_rate=0.99): self.lr = lr self.decay_rate = decay_rate self.h = None def update(self, params, grads): if self.h is None: self.h = &#123;&#125; for key, val in params.items(): self.h[key] = np.zeros_like(val) for key in params.keys(): self.h[key] *= self.decay_rate self.h[key] += (1 - self.decay_rate) * grads[key] * grads[key] params[key] -= self.lr * grads[key] / (np.sqrt(self.h[key]) + 1e-7) 六、AdamAdam方法结合了上述的动量（Momentum）和自适应（Adaptive），同时对梯度和学习率进行动态调整。如果说动量相当于给优化过程增加了惯性，那么自适应过程就像是给优化过程加入了阻力。速度越快，阻力也会越大。 Adam首先计算了梯度的一阶矩估计和二阶矩估计，分别代表了原来的动量和自适应部分 β_1 与 β_2 是两个特有的超参数，一般设为0.9和0.999 但是，Adam还需要对计算出的矩估计进行修正 其中t是迭代的次数，修正的原因在Why is it important to include a bias correction term for the Adam optimizer for Deep Learning? 这个问题中有非常详细的解释。 简单来说就是由于m和v的初始指为0，所以第一轮的时候会非常偏向第二项，那么在后面计算更新值得时候根据β_1 与 β_2的初始值来看就会非常的大，需要将其修正回来。而且由于β_1 与 β_2很接近于1，所以如果不修正，对于最初的几轮迭代会有很严重的影响。 最后就是更新参数值，和AdaGrad几乎一样，只不过是用上了上面计算过的修正的矩估计 python实现 123456789101112131415161718192021222324class Adam: def __init__(self, lr=0.001, beta1=0.9, beta2=0.999): self.lr = lr self.beta1 = beta1 self.beta2 = beta2 self.iter = 0 self.m = None self.v = None def update(self, params, grads): if self.m is None: self.m, self.v = &#123;&#125;, &#123;&#125; for key, val in params.items(): self.m[key] = np.zeros_like(val) self.v[key] = np.zeros_like(val) self.iter += 1 lr_t = self.lr * np.sqrt(1.0 - self.beta2**self.iter) / (1.0 - self.beta1**self.iter) for key in params.keys(): self.m[key] += (1 - self.beta1) * (grads[key] - self.m[key]) self.v[key] += (1 - self.beta2) * (grads[key]**2 - self.v[key]) params[key] -= lr_t * self.m[key] / (np.sqrt(self.v[key]) + 1e-7) 七、参考《Deep Learning》花书 《深度学习入门——基于python的理论与实现》]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deep Learning</tag>
        <tag>Optimizer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 137 Single Number II]]></title>
    <url>%2F2019%2F04%2F03%2Fleetcode137%2F</url>
    <content type="text"><![CDATA[这题比起其他都是两个但有一个只出现一次要复杂一些，原来只需要统计（模2）出现0次，1次的情况，现在需要统计每一位出现了0次，1次和2次（模3）的状态。 用one two three来统计每一位出现次数，出现在three中的可以从one two中约去 每一个数，首先和one与一下，得到原来是1次，现在变成两次的情况，或到two中 再和one抑或，原来是0的变成1，原来是1的由于进入two了变成0 one和two与，得到出现三次的情况，把他们从one two中抑或掉或者与非掉就行 最后的one就是最后的结果（模3为1） C++ Code 1234567891011121314class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int one = 0, two = 0, three = 0; for(int i = 0; i &lt; nums.size(); i++)&#123; two |= (one &amp; nums[i]); one ^= nums[i]; three = (two &amp; one); one ^= three; two ^= three; &#125; return one; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 164 Maximum Gap（桶排序）]]></title>
    <url>%2F2019%2F04%2F03%2Fleetcode164%2F</url>
    <content type="text"><![CDATA[这题既然是hard，那么就肯定要求复杂度在O(1)内完成。 考虑桶排序的方法，n个数大小相差最多为m的，那么大小相邻的两个数之间的间隔不会大于m / (n+1) 然后只要按照这个间隔构造足够的桶，维护每个桶中的最大值和最小值，同一个桶中的数字间隔不会多余答案所以只需要考虑每个桶的最小值与前面出现的最大值之间的差值就可以了。 C++ Code 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); if(len &lt; 2)&#123; return 0; &#125; int mi = INT_MAX, mx = INT_MIN; for(int i = 0; i &lt; len; i++)&#123; mi = min(mi, nums[i]); mx = max(mx, nums[i]); &#125; if(mi == mx) return 0; double bracket_size = (mx - mi) * 1.0 / (len - 1.0); int bracket_num = floor((mx - mi) / bracket_size + 1); vector&lt;int&gt; bracket_mx(bracket_num, INT_MIN); vector&lt;int&gt; bracket_mi(bracket_num, INT_MAX); for(int i = 0; i &lt; len; i++)&#123; int pos = floor((nums[i] - mi) / bracket_size); bracket_mx[pos] = max(bracket_mx[pos], nums[i]); bracket_mi[pos] = min(bracket_mi[pos], nums[i]); &#125; int ans = INT_MIN; int pre_max = bracket_mx[0]; for(int i = 1; i &lt; bracket_num; i++)&#123; if(bracket_mi[i] != INT_MAX)&#123; ans = max(ans, bracket_mi[i] - pre_max); pre_max = bracket_mx[i]; &#125; &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 169 Majority Element]]></title>
    <url>%2F2019%2F04%2F03%2Fleetcode229%2F</url>
    <content type="text"><![CDATA[169 Majority Element 229 Majority Element II 摩尔投票法 摩尔投票法 可以看作同归于尽法。当选择超过半数的数的时候，每一次都选择一个数站上擂台，或者与当前擂台上的数不同，就与其同归于尽一个，最后再扫描统计一遍站在擂台上的数出现次数，若没有超过半数则不存在超过半数的数。 同理，若要寻找超过1/3的数。擂台就设为两个，同时与两个不同的数同归于尽，最后站在擂台上的两个数再分别统计次数，若超过1/3，则是要找的数。 LeetCode 169 Majority Element Python Code 12345678910111213141516171819class Solution(object): def majorityElement(self, nums): """ :type nums: List[int] :rtype: int """ n = len(nums) if n % 2 == 0: half = n // 2 else: half = n // 2 + 1 cnt = &#123;&#125; for i in range(n): if not cnt.has_key(nums[i]): cnt[nums[i]] = 1 else: cnt[nums[i]] += 1 if cnt[nums[i]] &gt;= half: return nums[i] LeetCode 229 Majority Element II C++ Code 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; int tmp1, tmp2; int cnt1 = 0, cnt2 = 0; for(int i = 0; i &lt; nums.size(); ++i) &#123; if(nums[i] == tmp1) &#123; ++cnt1; &#125;else if(nums[i] == tmp2) &#123; ++cnt2; &#125;else if(cnt1 == 0) &#123; tmp1 = nums[i]; cnt1 = 1; &#125;else if(cnt2 == 0) &#123; tmp2 = nums[i]; cnt2 = 1; &#125;else &#123; --cnt1; --cnt2; &#125; &#125; cnt1 = 0; cnt2 = 0; for(int i = 0; i &lt; nums.size(); ++i) &#123; if(nums[i] == tmp1) &#123; ++cnt1; &#125;else if(nums[i] == tmp2) &#123; ++cnt2; &#125; &#125; vector&lt;int&gt; res; if(cnt1 &gt; nums.size() / 3) &#123; res.push_back(tmp1); &#125; if(cnt2 &gt; nums.size() / 3) &#123; res.push_back(tmp2); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 123 Best Time to Buy and Sell Stock III]]></title>
    <url>%2F2019%2F03%2F29%2Fleetcode123%2F</url>
    <content type="text"><![CDATA[维护两个变量b与s，b[i]为前i日内买入的最大剩余钱量(可以为负)。s[i]为前i日卖出后的最大钱量。 s[i]由b[i]迭代而来，b[i]由前一轮的s[i]迭代而来，所以只用一轮循环就可以完成更新。 C++ Code 1234567891011121314151617class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.size() == 0)&#123; return 0; &#125; int b1 = -0x7fffffff, s1 = 0, b2 = -0x7fffffff, s2 = 0; for(int i = 0; i &lt; prices.size(); i++)&#123; b1 = max(b1, -prices[i]); s1 = max(s1, prices[i] + b1); b2 = max(b2, s1 - prices[i]); s2 = max(s2, prices[i] + b2); &#125; return s2; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 2089 不要62]]></title>
    <url>%2F2019%2F03%2F19%2Fhdu2089%2F</url>
    <content type="text"><![CDATA[数位dp，先预处理出所有i位数字的情况 dp[i][j]，i代表数字的位数，j代表状况 dp[i][0],表示不存在不吉利数字的个数 dp[i][1],表示不存在不吉利数字，且最高位为2的个数 dp[i][2],表示存在不吉利数字的个数 从数字的最高位开始，例如98765，从9这一位开始，不幸运的个数为ans。 这一位数字如果由0~8这九个数字打头之后都是有完整的i-1位数的，所以这一位只考虑填入0~8，然后这一位作为9的时候讨论下一位就行了。 加上之前就已经是不吉利的情况。直接ans+= 9*dp[i-1][2] 因为加上了这一位而变成不吉利的数的情况，一共分为三种情况。 这位如果可以填入4，那么ans += dp[i-1][0] 这位可以填入6，那么ans += dp[i-1][1] 如果这一位可以填入2，并且前一位是6，那么ans += dp[i][1] 最后该位填入arr[i]，进入下一位开始讨论。 算出ans之后，n-ans就是前n个数字中吉利的数字，算区间的话用头尾减一下就好了。 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cstring&gt;using namespace std;int dp[10][3];//dp[i][j]，i代表数字的位数，j代表状况//dp[i][0],表示不存在不吉利数字//dp[i][1],表示不存在不吉利数字，且最高位为2//dp[i][2],表示存在不吉利数字void init()&#123; memset(dp, 0, sizeof(dp)); dp[0][0] = 1; for(int i = 1; i &lt;= 6; i++)//最大999999 &#123; //最高位加上不含4的9个数字的状况，但因为会放6，所以要减去前一种开头为2的情况 dp[i][0] = 9 * dp[i-1][0] - dp[i-1][1]; //只有2 dp[i][1] = dp[i-1][0]; //已经含有的前面放什么数都可以，或者是放一个4，或者是在2前面放6 dp[i][2] = dp[i-1][0] + dp[i-1][1] + 10 * dp[i-1][2]; &#125;&#125;int solve(int n)///1到n（不算n）幸运数个数&#123; int counts = 0, tmp = n, flag = 0, arr[10], ans = 0;//ans为不幸运数 while(n) &#123; arr[++counts] = n % 10; n /= 10; &#125; arr[counts + 1] = 0; ///每一步都只计算到0~arr[i]-1开头的情况，然后这一位作为arr[i]开始计算下一位 for(int i = counts; i &gt;=1; i--) &#123; ///0~arr[i]-1打头有完整的i-1位数 ans += dp[i-1][2] * arr[i]; ///因为加上该位才变成不吉利的情况 if(flag) ///高位已经出现4或62了，所有数都要算 ans += dp[i-1][0] * arr[i]; else &#123; ///若该位大于4，就要加上4+ i-1位幸运数构成的不幸运数 if(arr[i] &gt; 4) ans += dp[i-1][0]; if(arr[i+1] == 6 &amp;&amp; arr[i] &gt; 2) ans += dp[i][1]; if(arr[i] &gt; 6) ans += dp[i-1][1]; &#125; if(arr[i] == 4 || (arr[i+1] == 6 &amp;&amp; arr[i] == 2)) flag = 1; &#125; return tmp - ans;&#125;int main()&#123; int n, m; init(); while(scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n+m) &#123; printf("%d\n", solve(m + 1) - solve(n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>hdu</tag>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 440 K-th Smallest in Lexicographical Order]]></title>
    <url>%2F2019%2F03%2F18%2Fleetcode440%2F</url>
    <content type="text"><![CDATA[按字典序排列1~n的数字字符串，找到第k个是什么数字 把所有的数字看作是在一个字典树上，每个结点最多有10个子节点 一个个结点搜索，可以预先计算出这个结点所有子节点的数目，并加起来与k作比较，还不够则搜索下一个兄弟结点，否则就遍历到子节点继续计算子节点数量。 prefix记录的是当前从根节点到当前结点的路径，prefix+1则是下一个兄弟结点的路径。 以样例输入为例。例如计算1的子节点数，那么先计算1~2之间的个数（1个），然后计算10~20之间的个数（4个）。。。 若prefix的子节点数量超过了还需要的数量，那么搜索prefix的第一个子节点，即prefix*10 与 prefix*10 + 1 C++ Code 12345678910111213141516171819202122232425class Solution &#123;public: int findKthNumber(int n, int k) &#123; long long prefix = 1; k--; while(k &gt; 0)&#123; long long from = prefix; long long to = prefix + 1; long long step = 0; while(from &lt;= n)&#123; step += min((long long)n+1, to) - from; from *= 10; to *= 10; &#125; if(step &lt;= k)&#123; k -= step; prefix++; &#125;else&#123; prefix *= 10; k--; &#125; &#125; return prefix; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 81 Search in Rotated Sorted Array II]]></title>
    <url>%2F2019%2F03%2F17%2Fleetcode81%2F</url>
    <content type="text"><![CDATA[与leetcode 33有所不同，会存在重复出现数字的情况 在二分中若num[mid] == nums[left]就无法判断mid这个数落在右边的那段里还是左边的那段里，这时候只能先保守地left++然后进入下一轮 若num[mid] &gt; num[left]，那么mid与left落在同一个单调段内，那么如果这时候target正好在num[mid] 与num[left]之间，那么可以很放心的把right移到mid-1的位置。否则可以将left移到mid+1的位置 若num[mid] &lt; num[right]，情况与2相反。 C++ Code 12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool search(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() == 0)&#123; return false; &#125; int left = 0, right = nums.size() - 1; while(left &lt;= right)&#123; int mid = (left + right) &gt;&gt; 1; if(nums[mid] == target) &#123; return true; &#125;else if(nums[mid] == nums[left])&#123; left++; continue; &#125;else if(nums[mid] &gt; nums[left])&#123; if(nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])&#123; right = mid - 1; &#125;else&#123; left = mid + 1; &#125; &#125;else&#123; if(nums[right] &gt;= target &amp;&amp; nums[mid] &lt; target)&#123; left = mid + 1; &#125;else&#123; right = mid - 1; &#125; &#125; &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 72 Edit Distance]]></title>
    <url>%2F2019%2F03%2F12%2Fleetcode72%2F</url>
    <content type="text"><![CDATA[编辑距离推导，动态规划。 给定两个字符串s、t，用增加、删除、替换三种操作，使得s变成t的最少次数。 动态规划，dp[i][j]表示s前i个字符变为t的前j个字符的编辑距离。 初始化：dp[0][j] = j, dp[i][0] = i 递推分为两种情况： s[i] == t[j] dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1]) 分别对应删掉s[i]再变为t，s变为t[0: j-1]再加上t[j]，以及s[0: i-1]变为t[0: j-1] 但是，第一种情况可以改为直接将s[0: i-1]变为t，然后将t[j]去掉(因为s[i]还保留着)，步数不变并且不少于s[0: i-1]变为t[0: j-1]。同理可证第二种情况的步数不少于s[0: i-1]变为t[0: j-1]。所以只需要从最后一种情况进行更新就行。 s[i] != t[j] dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + 1) 分别对应删掉s[i]再变为t，s变为t[0: j-1]再加上t[j]，以及s[0: i-1]变为t[0: j-1]再替换s[i] C++ Code 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int minDistance(string word1, string word2) &#123; int len1 = word1.length(); int len2 = word2.length(); vector&lt;vector&lt;int&gt; &gt; dp; for(int i = 0; i &lt;= len1; i++)&#123; vector&lt;int&gt; dpi; for(int j = 0; j &lt;= len2; j++)&#123; if(i == 0)&#123; dpi.push_back(j); &#125;else if(j == 0)&#123; dpi.push_back(i); &#125;else&#123; dpi.push_back(0); &#125; &#125; dp.push_back(dpi); &#125; for(int i = 1; i &lt;= len1; i++)&#123; for(int j = 1; j &lt;= len2; j++)&#123; if(word1[i-1] == word2[j-1])&#123; dp[i][j] = dp[i-1][j-1]; &#125;else&#123; int mi = min(dp[i-1][j], dp[i][j-1]); mi = min(mi, dp[i-1][j-1]); dp[i][j] = mi + 1; &#125; &#125; &#125; return dp[len1][len2]; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2151 Check the difficulty of problems]]></title>
    <url>%2F2019%2F02%2F28%2Fpoj2151%2F</url>
    <content type="text"><![CDATA[动态规划问题。需要使用动态规划求出下面几个值 p[i][j]: 队i完成j题的概率，是题目的输入 dp[i][j][k]: 队i在前j题中完成k题的概率 s[i][j]: 队i完成不多于j题的概率，dp[i][m][0~j]的累加 p1: 所有队都至少完成一题的概率，(1-s[i][0])累乘 p2: 所有队都做出1~n-1题的概率，(s[i][n-1]-s[i][0])累乘 显然，最终的结果是p1-p2 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#define M 32#define T 1002using namespace std;double p[T][M]; // probability of team i solves problem jdouble dp[T][M][M]; // probability of team i solves k of the first j problemsdouble s[T][M]; //probability of team i solves at most j problemsint main()&#123; int m, t, n; while(scanf("%d%d%d", &amp;m, &amp;t, &amp;n) &amp;&amp; m != 0)&#123; memset(dp, 0, sizeof(dp)); memset(s, 0, sizeof(s)); for(int i = 1; i &lt;= t; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; scanf("%lf", &amp;p[i][j]); &#125; &#125; for(int i = 1 ; i &lt;= t; i++)&#123; dp[i][0][0] = 1.0; for(int j = 1; j &lt;= m; j++)&#123; dp[i][j][0] = dp[i][j-1][0] * (1 - p[i][j]); for(int k = 1; k &lt;= j; k++)&#123; dp[i][j][k] = dp[i][j-1][k-1] * p[i][j] + dp[i][j-1][k] * (1 - p[i][j]); &#125; &#125; &#125; for(int i = 1; i &lt;= t; i++)&#123; s[i][0] = dp[i][m][0]; for(int j = 1; j &lt;= m; j++)&#123; s[i][j] = s[i][j-1] + dp[i][m][j]; &#125; &#125; double p1 = 1.0; for(int i = 1; i &lt;= t; i++)&#123; p1 *= (1-s[i][0]); &#125; double p2 = 1.0; for(int i = 1; i &lt;= t; i++)&#123; p2 *= (s[i][n-1] - s[i][0]); &#125; printf("%.3f\n", p1-p2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3274 Gold Balanced Lineup（哈希）]]></title>
    <url>%2F2019%2F02%2F27%2Fpoj3274%2F</url>
    <content type="text"><![CDATA[给定一串K位二进制数字，需要给出最大区间的大小，使得在这个区间内每一位数字的和相等。 设一个数组sum[i][k]用于记录从第一个数字到第i个数字中第k位数字的和，这样就可以简单地计算出任意一个区间内每一位数字的和，也就是要求出sum[j][k] - sum[i][k]对于所有k都相等的区间[i, j]。 但是这样直接搜索的复杂度是O(N2)，所以需要用哈希来简化。 sum[j][0] - sum[i][0] = sum[j][1] - sum[i][1] 有 sum[j][1] - sum[j][0] = sum[i][1] - sum[i][0] 所以只要结点满足第k位数的总数与第0位数的总数差相等就可以。这一步可以使用哈希策略，详见代码。 C++ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define N 100010#define K 32#define HASH 100000using namespace std;struct node&#123; int index; int num[K];&#125;;vector&lt;node&gt; table[HASH];int sum[K];int main()&#123; int n, k, feature, hash, ans; node tmp; while(~scanf("%d%d", &amp;n, &amp;k))&#123; memset(sum, 0, sizeof(sum)); memset(tmp.num, 0, sizeof(tmp.num)); ans = 0; tmp.index = 0; for(int i = 0; i &lt; HASH; i++)&#123; table[i].clear(); &#125; table[0].push_back(tmp); for(int i = 1; i &lt;= n; i++)&#123; hash = 0; scanf("%d", &amp;feature); for(int j = 0; j &lt; k; j++)&#123; if((feature &gt;&gt; j) &amp; 1)&#123; sum[j]++; &#125; if(j &gt; 0)&#123; tmp.num[j] = sum[j] - sum[0]; hash += tmp.num[j] * j; &#125; &#125; tmp.index = i; hash = abs(hash) % HASH; for(int j = 0; j &lt; table[hash].size(); j++)&#123; bool flag = true; for(int l = 0; l &lt; k; l++)&#123; if(table[hash][j].num[l] != tmp.num[l])&#123; flag = false; break; &#125; &#125; if(flag == true)&#123; ans = max(ans, tmp.index - table[hash][j].index); &#125; &#125; table[hash].push_back(tmp); &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Paxos made simple 阅读笔记]]></title>
    <url>%2F2019%2F01%2F10%2FPaxos%2F</url>
    <content type="text"><![CDATA[参考文献：Lamport L. Paxos made simple[J]. ACM Sigact News, 2001, 32(4): 18-25. 一、Paxos简介Paxos是Lamport提出的最著名的基于消息传递的一致性算法，在2006年Google将其运用于Chubby锁服务器上后便受到了巨大的关注。Paxos Made Simple这篇论文中Lamport用了比较通俗的叙述方式来讲解了Paxos这个模型，也是Paxos的基础版本，支持单提案的达成一致与提交。 在这个模型中进程一共有三种角色，分别是 提案者(Proposers) 接受者(Acceptors) 学习者(Learners) 而每一个进程不限于一种角色。 Paxos一共分为两个阶段(Phrase)，分别是 提案阶段在这个阶段内，提案者会向接受者发送准备请求(ready request)，准备请求中带有一个编号n。 接受阶段在提案阶段一个提案者收到了超过半数的接受着返回的准备请求的应答，那么提案者将会向回复他的接受者发送一个带有编号n以及提案的接受请求(accept request)。 这篇笔记将会介绍Paxos如此设计的思路以及过程的详细细节，后面还会将Paxos与近几年比较火的另一种一致性算法Raft进行简单的比较。 二、要求与假设Paxos是一个一致性算法，而一致性算法的目标是让所有的进程最终都能够对提案达成一致。所以实现Paxos的最终效果是若没有提出一个提案，那么就不会有提案被选中，而若有提案被提出，那么最终只有一个提案会被选中。文中提到了三个一致性的安全性(safety)需求： 只有提出的提案能最终能被选中 只有一个提案能被选中 除非一个提案真的被选中了，否则进程不会选择这个提案 而系统的活性(liveness)则是某些提出的提案最终能被选中，并且进程最终能够学到这个提案。 文章讨论基于以下几个假设： 每个实体的执行速度不同，甚至会在任何时候崩溃、重启。因为有可能在提案选择后失效，因此想要得到一个解，必须要实现持久化某些信息。 消息传递的事件可以任意长，可以重复或丢失，但不会被破坏(无拜占庭问题)。 三、选择提案要保证上述的只有一个提案被最终选中的要求，同时保证系统的鲁棒性，那么需要做到一个提案能够被超过半数的接受者(majority)接受，因为无法找到两个majority能够接受不同的提案，只有所有进程都遵守这一规则，才能最终只有一个提案被选中。而要保证一定要有一个提案被选中，接受者应该对第一个提案进行接受。如果只有一个提案被提出却不接受，就无法得到majority，这就得到了第一个需求： P1. 接受者必须接受它所接收到的第一个提案 但是这个要求在有两个或更多提案的时候可能会得不到一个majority，所以每个进程不能仅被允许接收这一个提案。于是每个提案除了要带有一个值(value)以外，还要带上一个互不相同的数(number)来区分它们。这样一来就可以允许选择多个不同的提案了。但是由于最终选出的提案的值必须唯一，所以要添加另外一个条件： P2. 如果值为v的提案被选择了，那么所有被选择的数更大的提案的值也是v 由于提案的值被选中，那么这个提案一定要被某些接受者接受，所以P2的可以改写为 P2a. 如果值为v的提案被选择了，那么所有被任何一个接受者接受的数更大的提案的值也是v 但是还存在这样一种情况，有些接受者(c)还没有接受到任何的提案，但是这时一个新的数更大但值不同提案被提出且被发送给了c，由于P1的要求，c必须接受这个提案，那么这样一来就违反了P2a，所以P2a还应该进一步修改为： P2b. 如果值为v的提案被选择了，那么任何一个提案者提出的数更大的提案的值也是v 根据提出-接受-选中的因果关系，可以得出P2b -&gt; P2a -&gt; P2，而要具体实现P2b，只需要满足另一个变体 P2c. 如果提出了一个值为v，数为n的提议，那么一定存在一个接受者majority集合S，满足下面的其中一个条件 S内不存在任何接受过数小于n的提案 v是S中接受者接受的数小于n的最大数提案的值v 为了维护P2c，提案者在提出数为n的提案的时候就需要去学习当前不大于n的最大数提案的值，这些提案有的已经被接受，有的还没被接受。如果已被接受的话，那么就直接让接受者告知提案者就行。如果还未接受，那就会造成困难，因为提案者无法预测未来。所以文中又做了一个限制，那就是提案者会请求接受者不再去接受那些数小于自己提案的数的提案。 而接受者这边，只要不违背安全性要求的请求都可以回复，也就是接受者可以回复所有的准备请求，除了前面承诺过的不再接受的提案的接受请求以外的其他请求也都可以回复，这就可以提出一个比P1更强的需求： P1a. 接受者可以接受一个数为n的提案，当且仅当接受者只要没有回复过大于n的准备请求 这里还有一些隐含的优化可以做，那就是虽然接受者可以回复一个数小于当前已经回复过的最大为n准备请求，但是这个没有必要，因为最终接受者也不会接受后续的接受请求，所以接受者可以直接忽略这样的请求。同时，对于已经和接受的提案相同的准备请求，也不予以回复。 要做这些优化，接受者也只需要记住两个变量，一个是当前已经回复过的最大的准备请求以及已经接受的数最大的提议。第一个用来确定是否要回复一个准备请求以及是否要接受一个提案，第二个用来告知后面更大数的提议者去修改自己的提议。 综合上面的推导，就可以合理地提出Paxos提出并一致通过提案的算法流程了： Phase1. 提案者要提出一个提案，赋予数n和值v，那么他将向至少过半数的(majority)接受者发送准备请求(prepare request) 接受者受到准备请求后，只要这个请求中的数n大于自己曾经回复过的最大的数，那么就向提案者发送回复信息，回复中包含两个内容 向提案者承诺不再接受小于n的提案 如果已经接受过提案，则把已经接受过的提案的值v返回给提案者 Phase2. 如果提案者收到了半数以上接受者对自己数为n的准备请求的回复，那么就可以向这些接受者发送自己的提案(n, v)，v要根据接受者的回复进行修改。如果接受者的回复中带有曾经接受过的提案的值，那就改成这个值，否则就按照原来提出的值v 接受者如果在这段事件内没有回复其他的准备请求(其他提议者提出了n更大的提议，改变了这个接受者记录的最大回复值)，那么就可以接受这个提案。 只要遵守上面的流程，就可以保证算法的正确性，提案者可以在任何时候废除自己的提案。作为优化，提案者可以在得知已经有n更大的提案提出时放弃自己现在的提案。 四、学习被选择的值上面一个章节主要是一个提案提出后要如何得到一致通过，就像是一个公司的董事会对一个方案进行讨论，当得出最终结果或是得到半数董事通过后，就要讲这个最终结果通知给下面的员工。在Paxos模型中，学习者(learner)就扮演着员工这样一个角色。文中提出了三种不同的由接受者将通过的提案通知学习者的方案。 第一种方法最简单，接受者在接受提案后，立即将自己接受的提案广播给所有的学习者。但是这么做，会产生大约n_{acceptor} * n_{learner}的信息量，信息量过大。所以要进行一定的优化，减少网络负载。 第二种方案是将方案都发送给指定的单个学习者，再由这个学习者转发给所有其他的学习者(不存在拜占庭问题)来避免不必要的信息量，这样一来就可以将复杂度降至比较理想的n_{acceptor} + n_{learner}，但这种方案容易产生单点失效的问题，单个学习者一旦失效后，所有的学习者都无法直到通过的提案。 最后一种是前两种方案的折中，接受者将自己的方案发送给一个特定集合S的学习者，然后由这个集合中的学习者将结论转发给其他的学习者，这个方法会在方案二的基础上带来| S |倍的复杂度提升，但是却可以大大提高可靠性。 以上就是对Paxos算法的理解与讨论，可以看出Paxos算法设计的极为简洁，但却极为有效，这也是它能够逐渐被人们接受并流行的原因。然而这只是Paxos的Basic版，比较偏向理论，对于实现的讨论比较少，后续以此为基础还提出了很多优化和增强的版本。下一篇将会介绍近几年比较流行的一个算法Raft。]]></content>
      <categories>
        <category>分布式算法</category>
      </categories>
      <tags>
        <tag>Distributed Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[In search of an understandable consensus algorithm 阅读笔记]]></title>
    <url>%2F2019%2F01%2F10%2FRaft%2F</url>
    <content type="text"><![CDATA[参考文献：Ongaro D, Ousterhout J K. In search of an understandable consensus algorithm[C]//USENIX Annual Technical Conference. 2014: 305-319. 一、Raft简介Raft的作者认为Paxos即使经过几次的重新描述，但依旧让人难以理解，同时Paxos在提出过程中大多数都集中于单提案的模型，没有对实际应用做太详细的规定，因此过于理论化，在实际投入生产过程中，还是必须要提出许多变体来对相对应的应用场景做相应的优化。所以他提出了一套更加容易理解、更适合工业实践和教学的一致性算法。因此Raft算法的设计目标就是易理解，让人更容易理解算法流程和设计目的。 Raft将每个服务器都看作一个状态机(state machine)，每个状态机中都维护着一个日志，客户机向一个状态机提交一个请求，也就是向对应的状态机的日志添加了个带有命令的log entry。Raft算法维护所有服务器中的日志保持一致。这样所有的状态机都按照相同的顺序执行所有的操作，输出相同的输出。 Raft中也是分为三种不同的角色，而且与Paxos一样，角色也并非与服务器一一对应，而是动态改变的，一台服务器可能因为某些事件的触发而产生角色的变动。但是，每个角色所需要执行的操作却大不相同，三种状态间的转换如图1所示： 领导者(Leaders) Raft引入了领导者这一角色，但这个想法并不是Raft最早提出的，早在Paxos的变体multi-paxos中已经有类似角色的体现。 同时，Raft中使用任期(term)的概念。这一概念与Paxos中的number这一概念一样都充当了逻辑时钟的作用。在每一个任期的开始需要选出至少一个领导者(某些情况下一个任期内的所有候选者都竞选失败，没有领导者产生)，然后由领导者来控制后续的日志复制(log replication)。理论上只要当前的领导者服务器没有发生故障或者因为连接中断，任期可以无限长。在领导者失效时，为了防止单点失效的问题，Raft会重新在新的任期中进行一次选举来保证系统依旧可用。日志在Paxos当中相对应于提案，而复制日志相当于Paxos中确认提案与学习提案。但是，新的log只能由领导者提出，也就是客户端直接向领导者提出申请，然后由领导者去通知其他机器新的log和提交确认。 候选者(Candidates) 候选者是一个中间状态，跟随者要想成为领导者，必须要先声明成为候选人，然后进行选举，请求其他服务器为自己投票，赢得由其他的跟随者投票，最终成为领导者，若在竞选中失败，则只能变回跟随者。 跟随者(Followers) 跟随者有点像是Paxos中的学习者，被动地接受他人提出的变动。但是却和Paxos中的学习者不完全一样，Raft中的跟随者还有一个重要的任务，就是检查候选者的合法性以及给合法的候选者投票，让他们成为领导者。 根据上面的一些设定，Raft一共研究的就是三个子问题： 如何选举领导者，当现有的领导者失效的情况下，如何选出新的领导者，选举领导者的时候如何确定新的领导者不会破坏安全性原则 如何进行日志的复制，什么时候可以保证日志可以安全提交 如何保证系统的安全性，要维护包含以下的几个性质： 选举安全性：每一个任期(term)内只能有一个服务器被选举为领导者。 领导者只做append操作：领导者的所有的日志entry只能append在队列尾，而不能删除和覆盖。 日志匹配：如果两个日志在相同的序号上的日志entry的任期相同，那么这个日志从头到这个序号之间的日志entry时完全相同的。 领导者完整性：在一个领导者上提交的日志entry，在后面的term的领导者中也必须出现。也就是说，只有同步了最新log的server才能够被选举为领导者。 状态机安全性：如果一个服务器已经执行了日志上某个entry中的指令，那么其他服务器上相同序号不同的日志entry将不能够执行。 二、领导者选举整个过程的第一步是选举领导者，在系统刚刚启动时或者是当现有的领导者失效时，都将会触发这个过程。当一个跟随者一段时间(所有跟随者都会设置一个一定区间内的随机的计时周期，election timeout)内没有收到来自领导者定时发送的心跳(Heartbeat)或是其他候选者发送来的投票请求时(其他服务器竞选请求也会阻止一个跟随者成为候选者)，就会为自己开始一轮选举。开始选举主要需要以下步骤： 自己所知道的任期+1 给自己投一票 同时给所有人发送投票请求规定所有的跟随者只能投第一个收到的请求一票。当候选者收到半数请求的确认回复时，则赢下了这次选举，将自己的状态改为领导者，并向其他所有服务器开始广播自己的心跳，告知新的任期的开始，以确保其他服务器不会开始新的选举。 在候选者还在等待投票的时候，若收到一个任期不小于自己的其他领导者的心跳，说明已有其他候选者赢得了选举(若任期比自己小，可能是原来被网络阻隔的领导者的包达到了，在这种情况下，可以继续进行选举，等待选举胜利之后取代原来的领导者)，那么将放弃这次选举，将状态改回跟随者(不用改回任期，因为当前的新领导者的任期不会小于自己，他会通知自己以及其他所有的服务器将自己的任期进行更新)。 另一种情况是，同时有两个及以上的候选者产生，他们同时发出了投票请求，这样很可能就都得不到半数以上的投票。这种情况下候选者会在等待超时后重新执行一遍上述三步的流程，直到有一个领导者获胜，而election timeout的随机性也避免了这一情况的反复发生。 三、日志复制按照上一章的领导者选举过程顺利完成领导者选举之后，胜出的领导者就开始接受客户端的请求。接收客户端请求后，领导者会在自己的状态机上append上包含最新命令的log entry，并通过AppendEntries远程过程调用(RPC)，将这个log entry同步到其他服务器上。当超过半数的服务(包括自己)应答append成功后，领导者会在状态机上确认提交这个命令并将结果返回给客户机，同时通知其他服务器提交这个命令。 然而，在复制日志的过程中，会出现各种各样的问题，图2展示了多种领导者与跟随者上日志不一致的情况。例如跟随者缺失一些日志(a-b)，也有可能多出一些(c-d)，也有可能即少一些又多一些(e-f)。例如当服务器在作为跟随者的时候崩溃或网络连接错误，就有可能造成日志的缺失。当作为领导者时的崩溃或网络连接错误而没有将用户提交的请求进行同步，就有可能造成未提交的日志的多出。而实际中情况可能更加复杂。为解决上面这种不一致的情况，领导者在同步日志的时候，需要进行一些一致性检测。上面提到，只要两个服务器日志内的某条entry的任期和序号都一致。那么领导者只需要记下每个服务器当前还未同步日志序号(nextIndex)，然后将这个位置之后的日志发送过去，并在AppendEntrie请求中带上自己的任期，跟随者就可以根据送来的日志内的任期和序号以及领导者的任期，检查自己是否能够同步这些日志。如果不能同步，那么跟随者将会将自己所需要的日志号发送回给领导者，让领导者调整对自己的nextIndex，最终就能保证日志的一致。 但是，这样还不能保证领导者完整性。存在这样一种情况，在前一个任期内网络连接断开而没有同步某些已提交日志entry的某个跟随者，在新的任期中成功当选。显然让这样的服务器成为领导者是不安全的，因为他会覆盖掉原来已经提交的log(Raft的日志只能由领导者同步到跟随者上，不能指望跟随者告诉领导者他的缺失)。所以Raft在选举的时候设置了一个机制，跟随者需要检查当前候选者的已提交日志是否比自己的要旧，若是更旧则不能投票给他让他当选。由于所有日志的提交都需要至少有半数以上的服务器的通过，所以这一机制也就保证了提交日志记录不是最新的服务器无法成功当选领导者。 四、总结Paxos与Raft都是为解决分布式系统中一致性问题而提出的一致性算法。不同的是，Paxos更加偏向理论解释而Raft更偏向于实现。虽然本篇笔记所阅读的Paxos的论文只讨论了Paxos的最基础部分，但仍然能够看出其原理描述的优美精妙，让人切实地体会到算法的简洁有效，也是因为这些让Paxos在过去的十年间几乎成为了一致性算法的代名词。而Raft更加注重于可理解性和实现方面，在算法为何有效方面阐述的较为直白清晰。但Raft体现的细节较多，对每一种可能出现的情况都逐一进行讨论并说明给出的解决方案。]]></content>
      <categories>
        <category>分布式算法</category>
      </categories>
      <tags>
        <tag>Distributed Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bigtable, A distributed storage system for structured data 阅读笔记]]></title>
    <url>%2F2018%2F12%2F18%2FBigtable%2F</url>
    <content type="text"><![CDATA[参考文献：Chang F, Dean J, Ghemawat S, et al. Bigtable: A distributed storage system for structured data[J]. ACM Transactions on Computer Systems (TOCS), 2008, 26(2): 4. 一、Bigtable简介Bigtable是谷歌在其分布式文件系统GFS上设计的一个用于解决GFS无法对结构化数据进行访问与管理的结构化数据存储访问管理系统。基于HDFS的Apache HBase就是它的一个开源实现版本。谷歌将许多自己提供服务的数据使用Bigtable进行管理，例如Google Earth、Google Finance、Gmail等等。所以Bigtable不仅需要应对种类繁多的数据，在处理后端容量巨大的同时，还要保证对延迟敏感任务数据服务的及时性。同时由于谷歌众多的服务都由Bigtable提供支持，在系统设计中，除了上述的高适用性外，更要考虑系统设计的高容错性、高可用性以及可扩展性。 二、数据模型首先要说明Bigtable中数据是以什么形式存储的。在Bigtable中，为了数据的高效管理与使用，数据被设计通过三个层次进行索引，它们分别是： 行 (rows)行标识可以有任意不超过64KB的字符串组成，任何在同一行内的读或者写操作都具有原子性。在维护数据表的过程中，数据按照行关键字进行字典序划分，同时，根据行关键字还可以将数据动态地划分为一个个称作“子表” (Tablet) 的区间，存储在不同的子表服务器上做负载均衡。一般来说字典序相接近的两个行关键字下数据被划分在同一个子表服务器的概率较大，存取的效率也更高。 列族 (column families)实际的数据表中，通常拥有较多的列，但是传统关系型数据库中按列为粒度进行权限管理，给数据管理带来了很大的难度。Bigtable将数据表中的列先划分为不同的列族，在列族中还可以再定义相应的列关键字，组成形如family:qualifier的列关键字，来存储一些相似的数据。列族的设计目的是在能够容纳同样数量的列数的同时，将相同类型的列聚集为一个族来统一管理，甚至可以统一进行数据压缩，方便了数据管理，也提高了数据存储的灵活度。 时间戳 (timestamps)数据表中的数据通常有版本上的更替，为了防止版本间的冲突，Bigtable设计了时间戳维度，同行同列的数据按照时间关系被赋予一个时间戳，时间戳既可以由客户机应用程序自行设置，也可以由时间的毫秒数来决定以64位整数形式存储，并且时间戳按照降序排列，方便获取最新的一个版本。Bigtable支持两种自动回收旧版本的机制，一是保留最新的几个版本，另一种策略是仅保留一定时间内的所有版本。 所以，Bigtable中的每一个数据单元格式如下： (row:string, coloum:string, time:int64) -&gt; string 文中举了一个例子如图1所示，这是一个网页数据表，row值中存储着所记录网页的倒叙URL，即“com.cnn.www”。倒叙存放可以使同一个域名下的不同页面根据字典序存放在一起。“content:”是一个列族，但这个列族中没有其他的qulifier，下面存放着网页html的内容，这里的内容一共有三个版本，按时间顺序的时间戳为t3, t5, t6。“anchor：”为第二个列族，这个列族中有两个不同的column keys，分别是“cnnsi.com”和“my.look.ca”，记录着所有连接到row值存储页面的所有页面，而对应列下存储的就是这些页面中连接到row页面的anchor。 三、系统组成本章将会介绍Bigtable系统中的几个关键组成部分或者支撑技术。 主服务器 (master)主服务器上不存储子表，也不是用来提供表定位信息的，而是主要负责子表服务器的分配、负载均衡，监控子表服务器的状态，当子表服务器的租约到后仍然没有回应则要重新安排新的子表服务器来代替，同时当子表服务器的所存的子表过大的时候还要分配新的子表服务器进行负载均衡。同时，主服务器还要负责处理表模式更改、列族增加和GFS上垃圾回收等任务。 子表服务器 (tablet server)Bigtable在存储表的时候会将表划分为一个个子表来进行存储。子表服务器上存储着子表信息，由于为了减小主服务器的负载，数据请求不会经过主服务器，子表服务器还需要直接响应客户机对字表服务器上存储的子表的读和写操作。在所存储的子表过大的时候需要对子表进行切分操作。需要注意的是，子表服务器也不是直接存放数据的，数据只是存放在GFS中，然后由子服务器来进行分片管理 客户端的库客户端的库用于缓存子表的位置，只有当没有缓存子表的位置或子表的位置出错的情况下，客户机才会启动子表定位。 GFSBigtable底层所使用的分布式文件系统 (Google File System)，存放着数据文件和日志文件。 SSTableBigtable内部使用的文件格式，提供不变有序的键值映射，键与值都是用任意的字节串组成的。SSTable内部包含一系列默认大小为64KB的块 (block)，并将这些块的索引值存放在文件末尾。每一个子表可能对应着多个SSTable文件。 ChubbyChubby是Google设计的一个锁服务，每个Chubby服务都利用Paxos算法保留了5个副本，其中一个作为主副本提供服务。Chubby提供了一系列的目录与文件，每个目录与文件都被当成“锁”来使用以保证，使用Chubby服务的客户机需要保持和Chubby服务之间的会话，并维护一个租期的关系，超出租期如果Chubby没有收到客户机的续约申请，那么客户机就会失去在Chubby服务中的所有锁。Chubby在Bigtable中有非常重要的作用，以至于一旦Chubby服务失效，整个Bigtable就无法工作。无论是在主服务器的确定、子表服务器定位、子表服务器分配、表的权限控制等等方面都运用到了Chubby服务。这些运用将会在后面的章节中提到。 四、子表操作本章将会介绍子表的定位、子表分配以及子表的读写操作。 子表定位Bigtable将子表按照三层关系进行组织，三层关系如图1所示： 第一层，存储在Chubby file中，里面包含了Root tablet的位置信息。 第二层，根子表 (Root tablet) ，元数据子表 (METADATA tablets) 中的第一个子表，它存储着元数据表里其他子表的位置信息，根子表随着大小的增长是不会被分割的。 第三层，原数据子表 (METADATA tablets) ，保存其他用户数据表的子表信息。 ​在查找子表的时候，客户机首先会检查自己的库，看是否已经有这个子表位置的缓存，如果存在这个缓存且这个缓存还有效，就会按照这个位置去获取子表信息。如果这个子表的缓存信息错误，那么客户机将会递归向上一层的子表服务器进行查询。若缓存为空，则客户机将会从Chubby file开始获取根子表的位置，查询根子表查寻相应元数据子表的位置，再在元数据字表中找到需要的数据子表的位置，完成完整的一次询问的查找。 子表分配前文中有提到主服务器master主要负责监控子表服务器状态以及子表的分配。主服务器需要通过Chubby确认每个子表服务器是否还在正常工作，跟踪子表都分配给了哪些子表服务器以及哪些子表还没有被分配。 当一个子表服务器启动的时候，它会在Chubby特定的目录下建立一个自己的文件并获得互斥锁，主服务器通过文件来监控存在哪些子表服务器，通过周期性尝试获取这些文件的互斥锁来确认这些子表服务器是否还在正常工作。当子表服务器失去与Chubby的连接后，就会失去这个互斥锁。但是只要子表服务器上的数据还存在并且Chubby相应文件还存在，它还会不断试图请求会这个互斥锁。一旦主服务器获得了这个互斥锁，它就会删除这个文件，导致子表服务器的最终停止。而子表服务器主动停止服务的时候，也会释放这个互斥锁，以便主服务器更快意识到这个子表服务器的退出。 当主服务器和Chubby连接被断开后，当前的主服务器会主动关闭自己，这时候系统就会重新选择一个新的主服务器出来。主服务器启动时，会首先获取一个Chubby上的master锁以防止其他服务器同时成为主服务器；然后新主服务器会扫描Chubby的特定目录尝试获取互斥锁来获得当前正在工作的子表服务器；之后再询问每个子表服务器被分配的子表；最后再统计METADATA子表中还未被分配的子表，准备将其分配 (若元数据子表还未被分配，则需先将根子表加入到待分配的子表集合中) 。 子表的读写操作读写操作的基本示意图如图3所示。其中SSTable Files是已经持久化在GFS中的数据，memtable是还未存入SSTable Files的数据缓存，tablet log是写操作的日志，用于子表服务器启动时从重做点开始恢复子表。 读操作首先要经过权限的验证，通过验证后，由于数据的不同版本分布在位于内存的memtable中以及位于GFS的SSTable Files中，所以需要事先进行合并。 写操作也类似，首先要经过权限验证，然后使用日志先行 (WAL) 的方式先提交到日志中，然后再把变更插入到memtable中。 ​ 子表压缩每当进行一次写操作，新写的记录不会覆盖原有记录，而是被添加到memtable后面，当memtable的大小达到一定程度的时候，就要用新的一个memtable来代替原来的memtable并把原来的table保存为一个SSTable文件。这个操作过程叫作minor compaction。 但是minor compaction会逐渐增加SSTable的数量，会影响文件维护的效率。因此需要周期性的对SSTable文件和memtable进行合并，这个操作叫作merging compaction。 还有一种特殊的merging compaction叫作major compaction。这种compaction会把所有的SSTable和memtable都merge到一个单独的SSTable中，并且与前两种方法不同的是，major compaction将会删除掉那些已经无效的数据，节省集群空间，释放资源以适应巨大的容量需求。 五、总结这篇文章介绍了谷歌在GFS上搭建的结构化数据表存储系统Bigtable，本篇笔记首先在其使用的数据模型、系统组成方面进行的简单的介绍，然后分别详细讨论了在Bigtable上如何进行数据定位、数据分配以及数据读写操作。讨论了主服务器如何产生，当主服务器以及子表服务器出现问题后应该如何将正在管理数据移交出去，新启动的服务器应当如何加入到系统中并获得数据。还提到了Bigtable底层如何维护与压缩保存的数据文件。虽然这里面每个问题谷歌设计的方法看似都并不复杂，但是通过一个个简单的模型，我们体会到了一些经典模型，是如何被运用到实际系统中的，是如何满足谷歌所提供的数据服务的大容量、低延迟的要求，这也激发了我们进一步对底层理论的了解与研究的兴趣。]]></content>
      <categories>
        <category>分布式算法</category>
      </categories>
      <tags>
        <tag>Distributed Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Time, clocks, and the ordering of events in a distributed system 阅读笔记]]></title>
    <url>%2F2018%2F11%2F18%2FLamport_clocks%2F</url>
    <content type="text"><![CDATA[参考文献：Lamport L. Time, clocks, and the ordering of events in a distributed system[J]. Communications of The ACM, 1978, 21(7): 558-565. 一、基本问题本篇文章所讨论的问题是分布式系统中事件发生的先后顺序的问题。在日常生活中，我们经常通过时间，也就是日期、时分秒等等概念来确定时间发生的先后顺序。虽然这样的解释在单机系统或者一个很小的空间范围内不会出现太大的歧义，但是，在复杂的分布式系统当中，由于不同进程或是不同主机之间用于规定时间的时钟无法保证实时同步以及传输过程中的时延问题，这样的规定也就变得无效。例如两个进程A、B分别要对一个共享变量进行修改，在实际时间上A要比B先发出请求，理论上应该先满足A所发出的请求，但是A进程的请求比B进程的请求晚到达，这就会导致变量最终与期望的值不同。作者在文中强调我们一定要意识到在分布式系统中事件发生仅仅存在偏序关系这一点。所以在分布式系统中需要定义一种新的时间发生“序”的概念，使得不同进程间时间发生的顺序能够得到确定。 二、主要贡献本文定义了一个应用于分布式多进程系统中事件发生的一个偏序关系“happen before”，并提出了一个算法，将这样的偏序关系推广为全序关系，并将全序关系应用于一个同步问题。但是这样的全序关系还会遇到一种异常情况，作者又提出利用同步物理时钟 (physical clocks) 来避免这样的问题。 三、偏序关系偏序关系与全系关系不同，全序关系具有反对称性，这也就意味着全序关系中，任何两个元素之间都可以有关系。但偏序关系不具有反对称性，故两个元素之间不一定具有关系。像前面所说的，很多人在描述事件发生先后顺序时，都隐含地运用了一个全序关系，也就是物理理论中的时间关系。但是分布式系统中很难保持一个统一的精确的时钟，也就是两个事件间可能无法确定先.后关系，所以，作者将事件发生的前后关系定义为一个偏序集，也就是“happen before”关系，记作”-&gt;”。“happen before”关系的定义如下： 如果a和b是同一个进程中的事件，并且a在b之前发生，则a-&gt; b a事件是一个进程发送请求，b事件是另一个进程接收请求，则a-&gt; b 如果a-&gt;b并且b-&gt; c​，则​a-&gt;c​，即偏序的传递性 另外如果两个事件a，b既不满足a-&gt;b，也不满足b-&gt;a​，那么可以说两个事件是并发的 (concurrent) 作者通过一张“空间-时间”表来解释偏序关系，例如Figure 1，横向为不同的进程，纵向向上表示时间的推移，注意时间的推移只在单个进程上是有意义的。进程上的点代表了发生的事件，而波浪线表示消息，箭尾代表一个消息的发送事件而箭头表示消息到达的事件。按照上面的定义，偏序关系只定义在波浪线从箭尾到箭头以及进程线从下到上，这样一条路径上的点对这条路径上后续的点之间存在“happen before”关系（如p1​与r4​），若无法找到这样一条路径连接的两个点，则是并发关系（p3​与q3​）。 四、逻辑时钟为了与物理时钟进行区分，作者提出了逻辑时钟的概念，定义为：每个进程Pi都有一个时钟Ci，当b是进程j的一个事件的时候，系统全局时钟C给b分配的时间为C&lt;b&gt; = Cj&lt;b&gt;。 逻辑时钟的大小与物理时钟的先后没有关系，仅仅与时间发生的先后有关系，即定义时钟条件 (Clock Condition) Clock Condition. 对于任意的事件a，b，如果a-&gt;b则C&lt;a&gt; &lt; C&lt;b&gt;. 这个条件的逆命题不能够成立，即C&lt;a&gt; &lt; C&lt;b&gt;不能够推出a-&gt;b。 根据时钟条件以及前面定义的“happen before”偏序关系可以很容易地得出下面两个条件： C1. 在同一个进程i中如果a比b先发生，那么Ci&lt;a&gt; &lt; Ci&lt;b&gt; C2. 若进程i的事件a是给进程j发送一条消息并且b事件是进程j接收这条消息的事件，那么Ci&lt;a&gt; &lt; Cj&lt;b&gt; 再引入一个逻辑时钟“滴答” (tick)的概念，根据上面两个时钟条件，逻辑时钟在同一个进程先后的两个事件之间至少存在一个时钟tick，而在进程之间消息发送与接收事件之间，也要存在一个时钟tick。在图上如果用虚线表示时间tick的连线，同个进程的两个点之间一定存在一条连线，而消息发送的波浪线一定会穿过至少一条的连线。同时，由于进程与进程之间的物理时钟并不影响逻辑时钟，所以可以将每个进程轴上的点的距离进行任意地拉伸，比如把对应的tick对齐，使得tick之间的连线相互平行并垂直于进程轴，方便观察，如Figure 3所示。 为了满足两个时钟条件C1和C2，就要遵守下面两个实现规则 (Implementation rule)： IR1. 每一个进程中连续的两个事件之间时钟值C要递增。 IR2. 如果事件a需要发送一条消息，那么它需要在消息中包含自己的时间戳 (timestamp)，当b收到这个消息后，读取消息中的时间戳后，需要设置设置自己的时钟值，设置的值不能比当前自己的时钟值小并且要大于消息中的时间戳。 显然IR1保证了C1的满足，而IR2保证了C2的满足。可以想到的一种最简单的实现就是单个进程中的每个非接收消息的事件偏序时间都等于前一个事件偏序事件+1，若该事件接收消息，则需要设置为max(prev, Tm) + 1，其中prev是该进程前一个事件的逻辑时间，Tm是收到消息中包含的时间戳。 五、扩展为事件的全序文中提出了一种简单的方法，将事件的偏序关系推广到了整个分布式系统中所有事件的全序关系，这种定义的方法任意定义了一个进程上的全序关系“prec”，即给进程定义一个优先级，默认按照逻辑时钟值来进行排序，当逻辑时钟值相同时，则按照进程的全序关系来进行排序。 定义系统事件的全序关系“=&gt;”： Ci&lt;a&gt; &lt; Cj&lt;b&gt;，或者 Ci&lt;a&gt; = Cj&lt;b&gt; and Pi prec Pj 这种定义方法有点类似于拓扑排序，即定义好偏序关系后，通过定义一个任意的优先级，形成最终的序列，但是其中的偏序关系也得到了保留。在本文讨论的问题中，就是当a-&gt;b则a=&gt;b。但是这种全序的定义时十分随意的，不同的逻辑时钟，即使满足前面提到的两个实现规则，最终会产生不同的全序关系，不同的进程全序关系，最终的序列也不同。 六、互斥问题的应用我们希望一个给进程分配资源的算法需要满足以下条件： I. 资源分配给其他进程之前，之前分配的进程需要先释放这个资源 II. 资源要按照请求的先后顺序来进行分配 III. 只要每个被赋予权限的进程最终都释放了资源，那么所有的请求最终都能够被赋予资源 这三点看来都是简单的要求，而在实际中却不那么好满足。例如，采用中心调度进程P0来进行资源分配时，进程P1先向P0申请资源，然后P1向P2发送消息，P2收到消息后，向P0发送一个资源申请的请求，显然P1的请求应该先被满足，但是我们无法保证P1的请求比P2先到达。 为解决这个问题，作者使用一个满足IR1、IR2的系统时钟，生成一个事件的全序关系，并假设两个进程间的通信不会丢失且按序到达，那么算法规则定义如下： 申请资源时，进程Pi会发送一个带有时间戳的消息Tm:Pi给其他进程，并把这条消息放入自己的请求队列 (Request queue) 中 进程Pj接收到Tm:Pi后，也放入自己维护的请求队列中，并发回一个带有时间戳的消息 释放消息时，进程Pi移除所有自己请求队列中的Tm:Pi，并将释放进程的消息和时间戳发送给其他进程 当进程Pj收到释放资源消息时，也移除掉自己请求队列中的Tm:Pi 只有Pi本地验证当以下两个条件都满足的时候，进程Pi才会被分配资源： Tm:Pi存在于自己的请求队列中并且在规定的全序关系中排在最前面 收到了其他所有进程发来的时间戳晚于Tm的消息 这样的算法满足了前面的条件I-III： 通过3和4可以保证条件I 由于满足了全序序列，同时也满足了所有偏序关系，所以偏序关系上后出现的请求的时间戳一定会比先出现的要高，根据规则5(i)就能够按序进行资源赋予，满足条件II 规则2保证了规则5(ii)的触发，规则3将会移除自己进程中需要释放的请求，规则4将会移除在其他进程中记录的请求，这样，无论按照全序规则的下一个请求出现在哪个进程中，都能够满足，即触发了规则5(i)，满足了条件III 七、物理时钟上面所设计的系统已经能够利用逻辑时钟生成的全序序列来完成一个进程资源分配算法了，但是，上述的系统当一个进程崩溃时就无法运行，因为请求资源的的进程将无法收到所有其他进程的确认信息，也就无法满足规则5(ii)。然而仅仅凭借逻辑时钟，很难确认一个进程是否已经崩溃或只是处于事件的间隙间。 再考虑一种情况，当用户A使用计算机发送一个请求，然后他打电话让B（系统并不知到电话里的信息）也发送一个请求，由于系统并不知道电话里消息所形成的一个偏序关系，所以如果先收到B的消息的话，仍然会先满足B的请求，这就造成了一个异常行为 (Anomalous Behavior)。 上面两个例子表明了，在分布式系统中引入物理时钟是有必要的，逻辑时钟无法处理Anomalous Behavior这样的又系统外部信息所照成的异常。假设系统中产生的事件集合为ψ，而并上外部事件后的集合为ψ, 在ψ上定义新的“happen before”强时钟条件关系“–&gt;”: Strong Clock Condition. 对于任意的事件a，b，如果a–&gt;b则C&lt;a&gt; = C&lt;b&gt;. 现在引入系统中物理时钟条件，系统中需要保证每个进程之间的物理时钟相互接近并且改变的速度之间也要相互接近，所以要满足以下两个物理时钟条件： PC1. 存在一个常数κ &lt;&lt; 1，对于任意i: |dCi(t)/dt - 1|&lt;κ. PC2. 对于任意i，j: |Ci(t)-Cj(t)|&lt;ε. 这两个物理时钟条件要保证不发生异常行为，需要对时钟同步的过程中的两个变量ε ， κ进行限制。要满足Ci(t+μ)-Cj(t)&gt;0，其中μ是进程间通信的时延，也就是说，两个进程间的物理时钟相差不能超过物理时延，在物理事件上较晚开始的事务当其他进程的消息到达后，依然要拥有更大的时间戳。同时根据PC2可以得出Ci(t+μ)-Ci(t)&gt;(1-κ)μ，可以推导出，要满足Ci(t+μ)-Cj(t)&gt;0，就要满足ε/(1-κ)&lt;= μ.这两个物理时钟条件要保证不发生异常行为，需要对时钟同步的过程中的两个变量ε ， κ进行限制。要满足 最后将实现规则IR1，IR2进行推广 IR1’. 当任意进程Pi如果在物理事件t没有收到消息，那么Ci在t处可微并且dCi(t)/dt &gt; 0. IR2’. (a) Pi在t时刻发送一个带有一个时间戳Tm=Ci(t)的消息m. (b) Pj在t’时刻收到消息m，Pj设置Cj(t’)为max(Cj(t’-0), Tm+μm). 其中μm是传输的最小时延，Cj(t’-0)是Cj(t)在t’处的左极限。 八、总结本文定义了分布式系统中的偏序关系“happen before”，并将其扩展为了全序关系，展示如何解决同步问题。并且讨论如何引入物理时钟来避免异常行为以及同步物理时钟需要满足的条件。可以说这篇文章对分布式系统的发展起到了奠基的作用。]]></content>
      <categories>
        <category>分布式算法</category>
      </categories>
      <tags>
        <tag>Distributed Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3349 Snowflake Snow Snowflakes（哈希）]]></title>
    <url>%2F2018%2F10%2F28%2Fpoj3349%2F</url>
    <content type="text"><![CDATA[先哈希，再对比，对比就是循环滚动对比 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#define MAX 100005#define KEY 100000using namespace std;int snowFlakes[MAX][6];vector&lt;int&gt; head[KEY];bool isSame(int a, int b)&#123; for(int i = 0; i &lt; 6; i++)&#123; bool flag = true; for(int j = 0; j &lt; 6; j++)&#123; if(snowFlakes[a][j] != snowFlakes[b][(i+j)%6])&#123; flag = false; break; &#125; &#125; if(flag == true) return true; &#125; for(int i = 0; i &lt; 6; i++)&#123; bool flag = true; for(int j = 0; j &lt; 6; j++)&#123; if(snowFlakes[a][j] != snowFlakes[b][(i-j+6)%6])&#123; flag = false; break; &#125; &#125; if(flag == true) return true; &#125; return false;&#125;int main()&#123; int num, sum; bool flag = false; scanf("%d", &amp;num); for(int i = 0; i &lt; num; i++)&#123; sum = 0; for(int j = 0; j &lt; 6; j++)&#123; scanf("%d", &amp;snowFlakes[i][j]); sum += snowFlakes[i][j]; &#125; if(flag == false)&#123; int key = sum % KEY; if(head[key].size() &gt; 0)&#123; for(int j = 0; j &lt; head[key].size(); j++)&#123; if(isSame(head[key][j], i))&#123; flag = true; break; &#125; &#125; &#125; head[key].push_back(i); &#125; &#125; if(flag)&#123; printf("Twin snowflakes found.\n"); &#125;else&#123; printf("No two snowflakes are alike.\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2299 Ultra-QuickSort（树状数组）]]></title>
    <url>%2F2018%2F10%2F27%2Fpoj2299%2F</url>
    <content type="text"><![CDATA[求逆序数，记录一下原来的位置，快排一下看看每个位置的数应该排在什么地方，然后从第一个数开始把它排序后的位置放入树状数组，并且可以算出在这之前的数有多少个没有放在这个数前面（已放入的数量-在我前面的数量），也就是逆序数 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#define M 500005using namespace std;struct node&#123; int num; int order; bool operator&lt;(const node &amp;b) const&#123; return num &lt; b.num; &#125;&#125;arr[M];int ranks[M];int cnt[M];int num;int lowbit(int x)&#123; return (x &amp; (-x));&#125;void update(int pos, int x)&#123; while(pos &lt;= num)&#123; cnt[pos] += x; pos += lowbit(pos); &#125;&#125;int getSum(int pos)&#123; int ans = 0; while(pos &gt;= 1)&#123; ans += cnt[pos]; pos -= lowbit(pos); &#125; return ans;&#125;int main()&#123; while(~scanf("%d", &amp;num) &amp;&amp; num != 0)&#123; for(int i = 1; i &lt;= num; i++)&#123; scanf("%d", &amp;arr[i].num); arr[i].order = i; &#125; sort(arr + 1, arr + 1 + num); for(int i = 1; i &lt;= num; i++)&#123; ranks[arr[i].order] = i; &#125; memset(cnt, 0, sizeof(cnt)); long long ans = 0; for(int i = 1; i &lt;= num; i++)&#123; update(ranks[i], 1); ans += (i - getSum(ranks[i])); &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>排序</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1936 All in All]]></title>
    <url>%2F2018%2F10%2F25%2Fpoj1936%2F</url>
    <content type="text"><![CDATA[😂 C++ Code 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; char s[100002]; char t[100002]; while(~scanf("%s %s", s, t))&#123; int slen = strlen(s); int tlen = strlen(t); int i = 0; int j = 0; while(i &lt; slen &amp;&amp; j &lt; tlen)&#123; if(s[i] == t[j]) i++; j++; &#125; if(i == slen) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2388 Who's in the Middle]]></title>
    <url>%2F2018%2F10%2F25%2Fpoj2388%2F</url>
    <content type="text"><![CDATA[一个大顶堆一个小顶堆和一个中位数mid， 第一个数是中位数，后面比中位数大的放到大顶堆，比中位数小的放到小顶堆， 并且不断调整两个堆的大小相差不超过1，较小的一方push mid，较大的一方pop一个当作mid C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; mi;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; mx;int mid;int main()&#123; int ca, tmp; while(!mi.empty()) mi.pop(); while(!mx.empty()) mx.pop(); scanf("%d%d", &amp;ca, &amp;mid); ca--; while(ca--)&#123; scanf("%d", &amp;tmp); if(tmp &lt; mid)&#123; mx.push(tmp); &#125;else&#123; mi.push(tmp); &#125; if(mi.size() &gt;= mx.size() + 2)&#123; mx.push(mid); mid = mi.top(); mi.pop(); &#125;else if(mx.size() &gt;= mi.size() + 2)&#123; mi.push(mid); mid = mx.top(); mx.pop(); &#125; &#125; printf("%d\n", mid); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3080 Blue Jeans (KMP)]]></title>
    <url>%2F2018%2F10%2F20%2Fpoj3080%2F</url>
    <content type="text"><![CDATA[枚举第一个串的长度和起始点，然后用KMP去一个个比较，得到最后一个能匹配的长度，同时要替换字典序最大的那个串 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;using namespace std;char dna[12][65];int nex[65];void getNext(char *p, int len)&#123; nex[0] = -1; int i = 0, j = -1; while(i &lt; len)&#123; if(j == -1 || p[i] == p[j])&#123; i++; j++; nex[i] = j; &#125;else&#123; j = nex[j]; &#125; &#125;&#125;bool kmp(char *a, char*b, int len1, int len2)&#123; int i = 0, j = 0; while(i &lt; len1)&#123; if(j == -1 || a[i] == b[j])&#123; i++; j++; &#125;else&#123; j = nex[j]; &#125; if(j == len2)&#123; return true; &#125; &#125; return false;&#125;int main()&#123; int ca, num; scanf("%d", &amp;ca); while(ca--)&#123; scanf("%d", &amp;num); for(int i = 0; i &lt; num; i++)&#123; scanf("%s", dna[i]); &#125; char tmp[65]; char tmp2[65]; int final_len = 0; bool flag1, flag2; int pos; for(int len = 1; len &lt;= 60; len++)&#123; flag2 = false; for(int i = 0; i &lt;= 60-len; i++)&#123; strncpy(tmp, dna[0]+i, len); tmp[len] = '\0'; getNext(tmp, len); flag1 = true; pos = -1; for(int j = 1; j &lt; num; j++)&#123; if(kmp(dna[j], tmp, 60, len) == false)&#123; flag1 = false; break; &#125; &#125; if(flag1 == true)&#123; final_len = len; if(pos == -1 || strcmp(tmp, tmp2) &gt; 0)&#123; pos = i; strncpy(tmp2, tmp, len); tmp2[len] = '\0'; // printf("tmp2 %s\n", tmp2); &#125; flag2 = true; &#125; &#125; if(flag2 == false) break; &#125; if(final_len &lt; 3) printf("no significant commonalities\n"); else printf("%s\n", tmp2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1035 Spell checker]]></title>
    <url>%2F2018%2F10%2F15%2Fpoj1035%2F</url>
    <content type="text"><![CDATA[直接暴力比就可以 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;char dic[10005][20];char tmp[20];int main()&#123; int dic_len = 0; while(~scanf("%s", dic[dic_len]))&#123; if(dic[dic_len][0] == '#') break; dic_len++; &#125; while(~scanf("%s", tmp))&#123; if(tmp[0] == '#') break; bool flag = false; for(int i = 0; i &lt; dic_len; i++)&#123; if(strcmp(tmp, dic[i]) == 0)&#123; printf("%s is correct\n", tmp); flag = true; break; &#125; &#125; if(flag == true) continue; printf("%s:", tmp); int tmp_len = strlen(tmp); for(int i = 0; i &lt; dic_len; i++)&#123; int cnt = 0; if(tmp_len == strlen(dic[i]))&#123; for(int j = 0; j &lt; tmp_len; j++)&#123; if(tmp[j] != dic[i][j]) cnt++; &#125; if(cnt == 1) printf(" %s", dic[i]); &#125;else if(tmp_len == strlen(dic[i]) + 1)&#123; for(int j = 0, k = 0; j &lt; strlen(dic[j]) &amp;&amp; k &lt; tmp_len; j++, k++)&#123; if(dic[i][j] != tmp[k])&#123; j--; cnt++; &#125; &#125; if(cnt &lt;= 1) printf(" %s", dic[i]); &#125;else if(tmp_len == strlen(dic[i]) - 1)&#123; for(int j = 0, k = 0; j &lt; strlen(dic[i]) &amp;&amp; k &lt; tmp_len; j++, k++)&#123; if(dic[i][j] != tmp[k])&#123; k--; cnt++; &#125; &#125; if(cnt &lt;= 1) printf(" %s", dic[i]); &#125; &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3436 ACM Computer Factory（ISAP）]]></title>
    <url>%2F2018%2F10%2F13%2Fpoj3436%2F</url>
    <content type="text"><![CDATA[ISAP，每台机器都分成两个节点，中间连一条容量为工作效率的边； 如果输入没有1，则和源点连接，输出没有0的和汇点连接； 任意两个点之间输入和输出对应相加没有1则可以连接一条容量为INF的边。 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define M 105#define INF 10005using namespace std;struct Edge&#123; int from; int to; int flow; int cap; Edge(int f, int t, int fl, int c)&#123; from = f; to = t; cap = c; flow = fl; &#125;&#125;;int p, n;int in[M][10], out[M][10];vector&lt;Edge&gt; edges;vector&lt;int&gt; head[M], prefix[M];int deep[M], num[M], cur[M], pre[M];void add(int from, int to, int cap)&#123; edges.push_back(Edge(from, to, 0, cap)); edges.push_back(Edge(to, from, 0, 0)); int sz = edges.size(); head[from].push_back(sz-2); head[to].push_back(sz-1);&#125;void bfs(int s, int t)&#123; memset(deep, -1, sizeof(deep)); memset(num, 0, sizeof(num)); queue&lt;int&gt; q; q.push(s); deep[s] = 0; num[deep[s]]++; while(!q.empty())&#123; int cur = q.front(); q.pop(); for(int i = 0; i &lt; prefix[cur].size(); i++)&#123; int to = prefix[cur][i]; if(deep[to] &lt; 0)&#123; deep[to] = deep[cur] + 1; num[deep[to]]++; q.push(to); &#125; &#125; &#125;&#125;int augument(int s, int t)&#123; int pos = t; int flow = INF; while(pos != s)&#123; Edge &amp;e = edges[pre[pos]]; flow = min(flow, e.cap - e.flow); pos = e.from; &#125; pos = t; while(pos != s)&#123; edges[pre[pos]].flow += flow; edges[pre[pos]^1].flow -= flow; pos = edges[pre[pos]].from; &#125; return flow;&#125;int ISAP(int s, int t)&#123; int flow = 0; bool flag; bfs(t, s); int pos = s; memset(cur, 0, sizeof(cur)); while(deep[s] &lt; 2*(n+1))&#123;// cout &lt;&lt; flow &lt;&lt; " " &lt;&lt; pos &lt;&lt; " " &lt;&lt; deep[pos] &lt;&lt; endl; if(pos == t)&#123; flow += augument(s, t); pos = s; &#125; flag = false; for(int i = cur[pos]; i &lt; head[pos].size(); i++)&#123; Edge &amp;e = edges[head[pos][i]]; if(e.cap &gt; e.flow &amp;&amp; deep[pos] == deep[e.to] + 1)&#123; flag = true; cur[pos] = i; pre[e.to] = head[pos][i]; pos = e.to; break; &#125; &#125; if(flag == false)&#123; int mi = 2*n+1; for(int i = 0; i &lt; head[pos].size(); i++)&#123; Edge &amp;e = edges[head[pos][i]]; if(e.cap &gt; e.flow)&#123; mi = min(mi, deep[e.to]); &#125; &#125; num[deep[pos]]--; if(num[deep[pos]] == 0) break; deep[pos] = mi+1; num[deep[pos]]++; cur[pos] = 0; if(pos != s) pos = edges[pre[pos]].from; &#125; &#125; return flow;&#125;int main()&#123; int tmp; bool one, zero, flag; while(~scanf("%d%d", &amp;p, &amp;n))&#123; edges.clear(); for(int i = 0; i &lt; 2*n+2; i++)&#123; head[i].clear(); prefix[i].clear(); &#125; for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;tmp); add(i, i+n, tmp); prefix[i+n].push_back(i); one = false; for(int j = 0; j &lt; p; j++)&#123; scanf("%d", &amp;in[i][j]); if(in[i][j] == 1) one = true; &#125; zero = false; for(int j = 0; j &lt; p; j++)&#123; scanf("%d", &amp;out[i][j]); if(out[i][j] == 0) zero = true; &#125; if(!one)&#123; add(2*n, i, INF); prefix[i].push_back(2*n); &#125; if(!zero)&#123; add(i+n, 2*n+1, INF); prefix[2*n+1].push_back(i+n); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == j) continue; flag = true; for(int k = 0; k &lt; p; k++)&#123; if(out[i][k] + in[j][k] == 1)&#123; flag = false; break; &#125; &#125; if(flag == true)&#123; add(i+n, j, INF); prefix[j].push_back(i+n); &#125; &#125; &#125; int ans = ISAP(2*n, 2*n+1); vector&lt;int&gt; v; for(int i = 0; i &lt; edges.size(); i++)&#123; if(edges[i].flow &gt; 0 &amp;&amp; edges[i].from % n != edges[i].to % n &amp;&amp; edges[i].from != 2*n &amp;&amp; edges[i].to != 2*n+1)&#123; v.push_back(i); &#125; &#125; printf("%d %d\n", ans, v.size()); for(int i = 0; i &lt; v.size(); i++)&#123; Edge &amp;e = edges[v[i]]; printf("%d %d %d\n", (e.from)%n+1, (e.to)%n+1, e.flow); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1459 Power Network（ISAP）]]></title>
    <url>%2F2018%2F10%2F02%2Fpoj1459%2F</url>
    <content type="text"><![CDATA[ISAP算法模板 最大流增广路算法大致有三个优化等级 EK算法（Edmonds Karp）通过dfs每次在残量网络中找到一条可行的增广路进行增广 Dinic算法 在每次dfs寻找增广路前，先进行一次dfs标号，流量只沿着源点到汇点之间的最短路进行增广，这就相当于给了流一个势能，水只会向下流而不会随处流动，大大所短了EK算法中发现的增广路，提高了效率 ISAP算法，在Dinic算法的基础上进一步优化，并不需要在每次增广前都用bfs重新标号，而是只进行一次标号，之后在一个结点无法增广时才考虑修改节点的标号，同时加入一个gap优化，当某一个标号的节点个数为0时，停止增广，输出最大流。 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define MAX_NODE 105#define INF 150000using namespace std;struct Edge&#123; int from; int to; int cap; int flow; Edge(int f, int t, int c, int fw)&#123; from = f; to = t; cap = c; flow = fw; &#125;&#125;;vector&lt;Edge&gt; edges;vector&lt;int&gt; mp[MAX_NODE], prefix[MAX_NODE]; //the suffix edges of every node, the prefix nodes of every nodeint deep[MAX_NODE], num[MAX_NODE], cur[MAX_NODE], pre[MAX_NODE];int n, np, nc, m;void add(int from, int to, int cap)&#123; edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); int sz = edges.size(); mp[from].push_back(sz-2); mp[to].push_back(sz-1);&#125;void bfs(int s, int t)&#123; memset(deep, -1, sizeof(deep)); queue&lt;int&gt; q; q.push(s); deep[s] = 0; while(!q.empty())&#123; int cur = q.front(); q.pop(); for(int i = 0; i &lt; prefix[cur].size(); i++)&#123; int to = prefix[cur][i]; if(deep[to] &lt; 0)&#123; deep[to] = deep[cur] + 1; q.push(to); &#125; &#125; &#125;&#125;int augument(int s, int t)&#123; int pos = t; int flow = INF; while(pos != s)&#123; Edge &amp;e = edges[pre[pos]]; flow = min(flow, e.cap - e.flow);// printf("flow %d\n", flow);// printf("%d %d\n", e.cap, e.flow); pos = e.from; &#125; pos = t; while(pos != s)&#123; edges[pre[pos]].flow += flow; edges[pre[pos]^1].flow -= flow; pos = edges[pre[pos]].from; &#125; return flow;&#125;int ISAP(int s, int t)&#123; int flow = 0; bool flag = false; bfs(t, s); memset(cur, 0, sizeof(cur)); memset(num, 0, sizeof(num)); for(int i = 0; i &lt; n; i++)&#123; num[deep[i]]++; &#125; int pos = s; while(deep[s] &lt; n)&#123; if(pos == t)&#123; //augument one path successfully flow += augument(s, t); //continue the next one pos = s; &#125; flag = false; for(int i = cur[pos]; i &lt; mp[pos].size(); i++)&#123; Edge &amp;e = edges[mp[pos][i]]; if(e.cap &gt; e.flow &amp;&amp; deep[pos] == deep[e.to] + 1)&#123; flag = true; cur[pos] = i; pre[e.to] = mp[pos][i]; pos = e.to; break; &#125; &#125; if(flag == false)&#123; int mi = n-1; for(int i = 0; i &lt; mp[pos].size(); i++)&#123; Edge &amp;e = edges[mp[pos][i]]; if(e.cap &gt; e.flow)&#123; mi = min(mi, deep[e.to]); &#125; &#125; //gap num[deep[pos]]--; if(num[deep[pos]] == 0) break; num[mi+1]++; deep[pos] = mi+1; cur[pos] = 0; if(pos != s) pos = edges[pre[pos]].from; &#125; &#125; return flow;&#125;int main()&#123; while(~scanf("%d%d%d%d", &amp;n, &amp;np, &amp;nc, &amp;m))&#123; n += 2; for(int i = 0; i &lt; n; i++)&#123; mp[i].clear(); prefix[i].clear(); &#125; edges.clear(); int from, to, cap; for(int i = 0; i &lt; m; i++)&#123; scanf(" (%d,%d)%d", &amp;from, &amp;to, &amp;cap); add(from, to, cap); prefix[to].push_back(from); &#125; for(int i = 0; i &lt; np; i++)&#123; scanf(" (%d)%d", &amp;from, &amp;cap); add(n-2, from, cap); prefix[from].push_back(n-2); &#125; for(int i = 0; i &lt; nc; i++)&#123; scanf(" (%d)%d", &amp;from, &amp;cap); add(from, n-1, cap); prefix[n-1].push_back(from); &#125; int ans = ISAP(n-2, n-1); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3020 Antenna Placement（匈牙利算法）]]></title>
    <url>%2F2018%2F10%2F01%2Fpoj3020%2F</url>
    <content type="text"><![CDATA[匈牙利算法 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;int n, m;int mp[45][15];bool grid[405][405];char in[15];int dir[4][2] = &#123;0,1,0,-1,1,0,-1,0&#125;;int cnt;bool vis[405];int link[405];int num;bool dfs(int x)&#123; for(int y = 0; y &lt; num; y++)&#123; if(grid[x][y] &amp;&amp; !vis[y])&#123; vis[y] = true; if(link[y] == -1 || dfs(link[y]))&#123; link[y] = x; return true; &#125; &#125; &#125; return false;&#125;void search()&#123; memset(link, -1, sizeof(link)); for(int i = 0; i &lt; num; i++)&#123; memset(vis, 0, sizeof(vis)); if(dfs(i))&#123; cnt++; &#125; &#125;&#125;int main()&#123; int ca; scanf("%d", &amp;ca); while(ca--)&#123; memset(mp, -1, sizeof(mp)); memset(grid, 0, sizeof(grid)); num = 0; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++)&#123; scanf("%s", in+1); for(int j = 1; j &lt;= m; j++)&#123; if(in[j] == '*')&#123; mp[i][j] = num++; &#125; &#125; &#125; for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++)&#123; if(mp[i][j] &gt;= 0) for(int k = 0; k &lt; 4; k++)&#123; int x = i + dir[k][0]; int y = j + dir[k][1]; if(mp[x][y] &gt;= 0)&#123; grid[mp[i][j]][mp[x][y]] = true; &#125; &#125; &#125; &#125; cnt = 0; search(); printf("%d\n", num - cnt/2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>二分图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3041 Asteroids]]></title>
    <url>%2F2018%2F09%2F30%2Fpoj3041%2F</url>
    <content type="text"><![CDATA[匈牙利算法模板 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#define M 500using namespace std;bool grid[M][M];bool vis[M];//本轮是否已经尝试通过y来增广并且失败int n, k;int cnt;int link[M];bool dfs(int x)&#123; for(int i = 1; i &lt;= n; i++)&#123; if(grid[x][i] &amp;&amp; !vis[i])&#123; vis[i] = true; if(link[i] == -1 || dfs(link[i]) == true)&#123; link[i] = x; return true; &#125; &#125; &#125; return false;&#125;void search()&#123; for(int i = 1; i &lt;= n; i++)&#123; memset(vis, false, sizeof(vis)); if(dfs(i)) cnt++; &#125;&#125;int main()&#123; int x, y; while(~scanf("%d%d", &amp;n, &amp;k))&#123; memset(link, -1, sizeof(link)); memset(grid, false, sizeof(grid)); for(int i = 0; i &lt; k; i++)&#123; scanf("%d%d", &amp;x, &amp;y); grid[x][y] = true; &#125; cnt = 0; search(); printf("%d\n", cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>二分图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2485 Highways]]></title>
    <url>%2F2018%2F09%2F29%2Fpoj2485%2F</url>
    <content type="text"><![CDATA[要求能够让所有节点联通并且最大边权最小的问题，其实求的就是最小生成树的最大边权； 证明：最小生成树的最大边权一定是所有最小生成树中最小的 反证法：假设最小生成树T1的最大边(u, v)，和一个非最小生成树T2的最大边(a, b)，且(u, v) &gt; (a, b) &gt; T2中的其他所有边 去掉(u, v)，最小生成树会形成一个隔，u，v分别在割的两个分量中，且u，v在T2中一定存在一条唯一的路径，又由于u，v在T1中属于不同的分量，所以这条路径中一定存在着某条边两端分别在割的两个分量中，在T1中连上这条边就能够形成新的生成树，且比原来的最小生成树小，矛盾； C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define MAX 501using namespace std;int arr[MAX][MAX];bool vis[MAX];int ca, num;struct node&#123; int num; int v; bool operator&lt;(const node &amp;b) const&#123; return v &gt; b.v; &#125;&#125;;int prim(int start)&#123; int ans = 0; priority_queue&lt;node&gt; q; memset(vis, false, sizeof(vis)); node tmp; tmp.num = start; tmp.v = 0; q.push(tmp); for(int k = 0; k &lt; num; k++)&#123; node cur; do&#123; cur = q.top(); q.pop(); &#125;while(vis[cur.num]); vis[cur.num] = true; ans = max(ans, cur.v); for(int i = 0; i &lt; num; i++)&#123; if(!vis[i] &amp;&amp; arr[cur.num][i] &gt; 0)&#123; node tmp; tmp.num = i; tmp.v = arr[cur.num][i]; q.push(tmp); &#125; &#125; &#125; return ans;&#125;int main()&#123; while(~scanf("%d", &amp;ca))&#123; while(ca--)&#123; scanf("%d", &amp;num); for(int i = 0; i &lt; num; i++)&#123; for(int j = 0; j &lt; num; j++)&#123; scanf("%d", &amp;arr[i][j]); &#125; &#125; int ans = prim(0); printf("%d\n", ans); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3026 Borg Maze]]></title>
    <url>%2F2018%2F09%2F29%2Fpoj3026%2F</url>
    <content type="text"><![CDATA[把每个S和A都看成节点，BFS求之间的距离然后套用Prim来计算最小生成树。注意输入有坑，整数输入完后可能有多个空格，要用gets()而不能用getchar() C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;queue&gt;#define M 55#define M_ROBOT 105using namespace std;struct node&#123; int x; int y; int step; node(int a, int b, int c)&#123; x = a; y = b; step = c; &#125; node()&#123; x = 0; y = 0; step = 0; &#125;&#125;robots[M_ROBOT];struct queueEdge&#123; int num; int v; queueEdge()&#123; num = 0; v = 0; &#125; queueEdge(to, len)&#123; num = to; v = len; &#125;&#125;;char mp[M][M];int arr[M_ROBOT][M_ROBOT];bool vis[M][M];int n, m, num;void bfs(int start)&#123; memset(vis, 0, sizeof(vis)); queue&lt;node&gt; q; robots[start].step = 0; q.push(robots[start]); while(!q.empty())&#123; node cur = q.front(); q.pop(); vis[cur.x][cur.y] = true; char tmp = mp[cur.x][cur.y]; if(tmp != '#' &amp;&amp; tmp != ' ')&#123; arr[start][(int)tmp] = cur.step; &#125; if(mp[cur.x-1][cur.y] != '#' &amp;&amp; !vis[cur.x-1][cur.y]) q.push(node(cur.x-1, cur.y, cur.step+1)); if(mp[cur.x+1][cur.y] != '#' &amp;&amp; !vis[cur.x+1][cur.y]) q.push(node(cur.x+1, cur.y, cur.step+1)); if(mp[cur.x][cur.y-1] != '#' &amp;&amp; !vis[cur.x][cur.y-1]) q.push(node(cur.x, cur.y-1, cur.step+1)); if(mp[cur.x][cur.y+1] != '#' &amp;&amp; !vis[cur.x][cur.y+1]) q.push(node(cur.x, cur.y+1, cur.step+1)); &#125;&#125;int prim(int start)&#123; int ans = 0; memset(vis, false, sizeof(vis)); priority_queue&lt;queueEdge&gt; q; q.push(queueEdge(start, 0)); for(int k = 0; k &lt; num; k++)&#123; do&#123; node cur = q.top(); q.pop(); &#125;while(vis[cur.num]); vis[cur.num] = true; ans += vis.v; for(int i = 0; i &lt; num; i++)&#123; if(!vis[i]) q.push(queueEdge(i, arr[cur.num][i])); &#125; &#125; return ans;&#125;int main()&#123; int ca; scanf("%d", &amp;ca); while(ca--)&#123; num = 0; scanf("%d%d", &amp;m, &amp;n); getchar(); for(int i = 0; i &lt; n; i++)&#123; gets(mp[i]); for(int j = 0; j &lt; m; j++)&#123; if(mp[i][j] == 'A' || mp[i][j] == 'S')&#123; mp[i][j] = num; robots[num].x = i; robots[num].y = j; num++; &#125; &#125; &#125; for(int i = 0; i &lt; num; i++)&#123; bfs(i); &#125; int ans = prim(0); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1258 Agri-Net]]></title>
    <url>%2F2018%2F09%2F28%2Fpoj1258%2F</url>
    <content type="text"><![CDATA[Prim模板 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define MAX 101using namespace std;int arr[MAX][MAX];bool vis[MAX];int num;struct node&#123; int num; int v; bool operator&lt;(const node &amp;b) const&#123; return v &gt; b.v; &#125;&#125;;int prim(int start)&#123; int ans = 0; priority_queue&lt;node&gt; q; memset(vis, false, sizeof(vis)); node tmp; tmp.num = start; tmp.v = 0; q.push(tmp); for(int k = 0; k &lt; num; k++)&#123; node cur; do&#123; cur = q.top(); q.pop(); &#125;while(vis[cur.num]); vis[cur.num] = true; ans += cur.v; for(int i = 0; i &lt; num; i++)&#123; if(!vis[i] &amp;&amp; arr[cur.num][i] &gt; 0)&#123; node tmp; tmp.num = i; tmp.v = arr[cur.num][i]; q.push(tmp); &#125; &#125; &#125; return ans;&#125;int main()&#123; while(~scanf("%d", &amp;num))&#123; for(int i = 0; i &lt; num; i++)&#123; for(int j = 0; j &lt; num; j++)&#123; scanf("%d", &amp;arr[i][j]); &#125; &#125; int ans = prim(0); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1094 Sorting It All Out]]></title>
    <url>%2F2018%2F09%2F27%2Fpoj1094%2F</url>
    <content type="text"><![CDATA[拓扑排序，加入一个关系后就判断一次，注意判断排序不能确定后不能马上跳过，还要继续看看会不会形成环 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;using namespace std;bool arr[26][26];int n, m;int degree[26];char ans[30];int topoSort()&#123; int ret = 1; int pos = 0; int tmpDegree[26]; memcpy(tmpDegree, degree, sizeof(tmpDegree)); queue&lt;int&gt; q; for(int i = 0; i &lt; n; i++) if(degree[i] == 0) q.push(i); while(!q.empty())&#123; if(q.size() &gt; 1) ret = 0; int cur = q.front(); q.pop(); ans[pos++] = cur + 'A'; for(int i = 0; i &lt; n; i++)&#123; if(arr[cur][i])&#123; tmpDegree[i]--; if(tmpDegree[i] == 0) q.push(i); &#125; &#125; &#125; if(pos &lt; n)&#123; return -1; &#125; ans[pos] = '\0'; return ret;&#125;int main()&#123; char ch[4]; bool flag = false; while(~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; n != 0)&#123; memset(arr, 0, sizeof(arr)); memset(degree, 0, sizeof(degree)); flag = false; for(int i = 0; i &lt; m; i++)&#123; scanf("%s", ch); arr[ch[0]-'A'][ch[2]-'A'] = true; if(flag) continue; degree[ch[2]-'A']++; int topo = topoSort(); if(topo == 1)&#123; flag = true; printf("Sorted sequence determined after %d relations: %s.\n", i+1, ans); &#125;else if(topo == -1)&#123; flag = true; printf("Inconsistency found after %d relations.\n", i+1); &#125; &#125; if(!flag) printf("Sorted sequence cannot be determined.\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1789 Truck History（Prim）]]></title>
    <url>%2F2018%2F09%2F26%2Fpoj1789%2F</url>
    <content type="text"><![CDATA[最小生成树 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#define M 2000using namespace std;char t[M][10];int arr[M][M];bool vis[M];int num;struct node&#123; int num; int len; bool operator&lt;(const node &amp;b) const&#123; return len &gt; b.len; &#125;&#125;;int dist(int a, int b)&#123; int cnt = 0; for(int i = 0; i &lt; 7; i++)&#123; if(t[a][i] != t[b][i]) cnt++; &#125; return cnt;&#125;int prim(int start)&#123; int ans = 0; priority_queue&lt;node&gt; q; memset(vis, 0, sizeof(vis)); node tmp; tmp.num = start; tmp.len = 0; q.push(tmp); for(int k = 0; k &lt; num; k++)&#123; node cur; do&#123; cur = q.top(); q.pop(); &#125;while(vis[cur.num]); vis[cur.num] = true; ans += cur.len; for(int i = 0; i &lt; num; i++)&#123; if(!vis[i])&#123; node tmp; tmp.num = i; tmp.len = arr[cur.num][i]; q.push(tmp); &#125; &#125; &#125; return ans;&#125;int main()&#123; while(~scanf("%d", &amp;num) &amp;&amp; num != 0)&#123; for(int i = 0; i &lt; num; i++)&#123; scanf("%s", t[i]); &#125; for(int i = 0; i &lt; num; i++)&#123; arr[i][i] = 0; for(int j = i+1; j &lt; num; j++)&#123; arr[i][j] = arr[j][i] = dist(i, j); &#125; &#125; int ans = prim(0); printf("The highest possible quality is 1/%d.\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2240 Arbitrage]]></title>
    <url>%2F2018%2F09%2F25%2Fpoj2240%2F</url>
    <content type="text"><![CDATA[SPFA找正环或者用Floyd找自己到自己最长路大于1的点 C++ Code SPFA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;map&gt;#include &lt;queue&gt;#define M 35#define INF 80000000using namespace std;double arr[M][M];bool isInqueue[M];int numInqueue[M];int num, numedge;double dis[M];bool spfa()&#123; memset(numInqueue, 0, sizeof(numInqueue)); memset(isInqueue, 0, sizeof(isInqueue)); queue&lt;int&gt; q; for(int i = 1; i &lt;= num; i++)&#123; dis[i] = INF; q.push(i); isInqueue[i] = true; numInqueue[i]++; &#125; while(!q.empty())&#123; int cur = q.front(); q.pop(); isInqueue[cur] = false; for(int i = 1; i &lt;= num; i++)&#123; if(arr[cur][i] &gt; 0)&#123; if(dis[i] &lt; dis[cur]*arr[cur][i])&#123; dis[i] = dis[cur] * arr[cur][i]; if(!isInqueue[i])&#123; q.push(i); isInqueue[i] = true; numInqueue[i] ++; if(numInqueue[i] &gt;= num) return true; &#125; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; int ca = 1; while(scanf("%d", &amp;num) &amp;&amp; num != 0)&#123; memset(arr, 0 , sizeof(arr)); map&lt;string, int&gt; m; string name, c1, c2; double rate; for(int i = 1; i &lt;= num; i++)&#123; cin &gt;&gt; name; m[name] = i; &#125; scanf("%d", &amp;numedge); for(int i = 1; i &lt;= numedge; i++)&#123; cin &gt;&gt; c1 &gt;&gt; rate &gt;&gt; c2; arr[m[c1]][m[c2]] = rate; &#125; bool flag = spfa(); if(flag) printf("Case %d: Yes\n", ca++); else printf("Case %d: No\n", ca++); &#125; return 0;&#125; Floyd 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;double arr[31][31];double max(double a, double b)&#123; return a &gt; b ? a : b;&#125;int main()&#123; map&lt;string, int&gt; name; int num , m; int a, b; double trans; string cash1, cash2; int ca = 1; while(cin &gt;&gt; num &amp;&amp; num) &#123; memset(arr, 0, sizeof(arr)); for(int i = 0; i &lt; num; i++) &#123; cin &gt;&gt; cash1; name[cash1] = i; &#125; cin &gt;&gt; m; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; cash1; a = name[cash1]; cin &gt;&gt; trans; cin &gt;&gt; cash2; b = name[cash2]; arr[a][b] = trans; &#125; for(int k = 0; k &lt; num; k++) for(int i = 0; i &lt; num; i++) for(int j = 0; j &lt; num; j++) arr[i][j] = max(arr[i][j], arr[i][k]*arr[k][j]); bool flag = false; for(int i = 0; i &lt; num; i++) &#123; if(arr[i][i] &gt; 1) &#123; cout &lt;&lt; "Case " &lt;&lt; ca++ &lt;&lt; ": Yes" &lt;&lt;endl; flag = true; break; &#125; &#125; if(!flag) printf("Case %d: No\n", ca++); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1125 Stockbroker Grapevine]]></title>
    <url>%2F2018%2F09%2F24%2Fpoj1125%2F</url>
    <content type="text"><![CDATA[Floyd C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#define M 101#define INF 1000000using namespace std;int arr[M][M];int main()&#123; int num, contact; int to, cost; while(scanf("%d", &amp;num) &amp;&amp; num != 0)&#123; for(int i = 1; i &lt;= num; i++)&#123; for(int j = 1; j &lt;= num; j++)&#123; if(i == j) arr[i][j] = 0; else arr[i][j] = INF; &#125; &#125; for(int i = 1; i &lt;= num; i++)&#123; scanf("%d", &amp;contact); for(int j = 0; j &lt; contact; j++)&#123; scanf("%d%d", &amp;to, &amp;cost); arr[i][to] = cost; &#125; &#125; for(int k = 1; k &lt;= num; k++)&#123; for(int i = 1; i &lt;= num; i++)&#123; for(int j = 1; j &lt;= num; j++)&#123; arr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j]); &#125; &#125; &#125; bool flag = false; int mi = INF; int pos; for(int i = 1; i &lt;= num; i++)&#123; flag = false; int mx = -1; for(int j = 1; j &lt;= num; j++)&#123; if(arr[i][j] &gt;= INF)&#123; flag = true; break; &#125; mx = max(mx, arr[i][j]); &#125; if(flag == false &amp;&amp; mi &gt; mx)&#123; mi = mx; pos = i; &#125; &#125; if(mi == INF) printf("disjoint\n"); else printf("%d %d\n", pos, mi); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2253 Frogger（Floyd）]]></title>
    <url>%2F2018%2F09%2F23%2Fpoj2253%2F</url>
    <content type="text"><![CDATA[利用Floyd的更新策略，只不过把要更新的值类型从最短路变成最大跨度。输出用%lf WA死我了，改用%f或cout就好了。 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#define MAX 202using namespace std;struct node&#123; double x; double y;&#125;stones[MAX];double arr[MAX][MAX];int main()&#123; int num; int ca = 1; while(~scanf("%d", &amp;num) &amp;&amp; num != 0)&#123; for(int i = 0; i &lt; num; i++)&#123; scanf("%lf%lf", &amp;stones[i].x, &amp;stones[i].y); &#125; for(int i = 0; i &lt; num; i++)&#123; arr[i][i] = 0; for(int j = i+1; j &lt; num; j++)&#123; arr[i][j] = arr[j][i] = sqrt((stones[i].x - stones[j].x)*(stones[i].x - stones[j].x) + (stones[i].y - stones[j].y)*(stones[i].y - stones[j].y)); &#125; &#125; for(int k = 0; k &lt; num; k++)&#123; for(int i = 0; i &lt; num; i++)&#123; for(int j = 0; j &lt; num; j++)&#123; arr[i][j] = min(arr[i][j], max(arr[i][k], arr[k][j])); &#125; &#125; &#125; printf("Scenario #%d\n", ca++); printf("Frog Distance = %.3f\n\n", (arr[0][1])); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1062 昂贵的聘礼]]></title>
    <url>%2F2018%2F09%2F22%2Fpoj1062%2F</url>
    <content type="text"><![CDATA[每个物品是一个节点，当前dis是直接用钱换的价值，从被申请交换的物品向申请交换的物品方向建边，边权是交换后还需要的优惠价。至于等级的限制，因为最后一定要和酋长交换，否则答案就是酋长给出的原价，所以将所有包含酋长的等级长为m的区间都枚举出来，求所有点到酋长的最短路，spfa就直接把所有点push一遍到queue中就行。 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;math.h&gt;#define MAX_NODE 101#define INF 0x7fffffffusing namespace std;int arr[MAX_NODE][MAX_NODE];int ranks[MAX_NODE];int cost[MAX_NODE];int dis[MAX_NODE];bool isInqueue[MAX_NODE];int m, n;int p, l, x;int t, v;bool spfa(int pos)&#123; memset(isInqueue, 0, sizeof(isInqueue)); queue&lt;int&gt; q; for(int i = 1; i &lt;= n; i++)&#123; dis[i] = cost[i]; if(ranks[i] &gt;= ranks[1]-m+pos &amp;&amp; ranks[i] &lt;= ranks[1]+pos)&#123; q.push(i); isInqueue[i] = true; &#125; &#125; while(!q.empty())&#123; int cur = q.front(); q.pop(); isInqueue[cur] = false; for(int i = 1; i &lt;= n; i++)&#123; if(arr[cur][i] &gt; 0 &amp;&amp; (ranks[i] &gt;= ranks[1]-m+pos &amp;&amp; ranks[i] &lt;= ranks[1]+pos))&#123; if(dis[i] &gt; arr[cur][i] + dis[cur])&#123; dis[i] = arr[cur][i] + dis[cur]; if(!isInqueue[i])&#123; isInqueue[i] = true; q.push(i); &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; while(~scanf("%d%d", &amp;m, &amp;n))&#123; memset(arr, -1, sizeof(arr)); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d%d%d", &amp;p, &amp;l, &amp;x); cost[i] = dis[i] = p; ranks[i] = l; for(int j = 0; j &lt; x; j++)&#123; scanf("%d%d", &amp;t, &amp;v); arr[t][i] = v; &#125; &#125; int mi = INF; for(int i = 0; i &lt;= m; i++)&#123; spfa(i); mi = min(mi, dis[1]); &#125; printf("%d\n", mi); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3259 Wormholes]]></title>
    <url>%2F2018%2F09%2F21%2Fpoj3259%2F</url>
    <content type="text"><![CDATA[同样判断是否存在负环/正环的最短路/最长路问题，用SPFA或Bellman-Ford直接求负环就行 C++ Code 这是这次写的SPFA的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#define MAX_NODE 501#define MAX_EDGE 5402#define INF 1e9using namespace std;int ca, n, m, w;int head[MAX_NODE];int cnt;int dis[MAX_NODE];bool isInqueue[MAX_NODE];int num_inqueue[MAX_NODE];struct edge&#123; int v; int cap; int nex;&#125;edges[MAX_EDGE];void add(int s, int t, int cap)&#123; edges[cnt].cap = cap; edges[cnt].v = t; edges[cnt].nex = head[s]; head[s] = cnt++;&#125;bool spfa(int start)&#123; queue&lt;int&gt; q; while(!q.empty()) q.pop(); memset(num_inqueue, 0, sizeof(num_inqueue)); memset(isInqueue, false, sizeof(isInqueue)); for(int i = 0; i &lt; MAX_NODE; i++) dis[i] = INF; dis[start] = 0; q.push(start); isInqueue[start] = true; while(!q.empty())&#123; int cur = q.front(); q.pop(); isInqueue[cur] = false; for(int pos = head[cur]; pos != -1; pos = edges[pos].nex)&#123; int v = edges[pos].v; if(dis[v] &gt; dis[cur] + edges[pos].cap)&#123; dis[v] = dis[cur] + edges[pos].cap; if(!isInqueue[v])&#123; q.push(v); isInqueue[v] = true; num_inqueue[v]++; if(num_inqueue[v] &gt;= n) return true; &#125; &#125; &#125; &#125; return false;&#125;int main()&#123; int from, to, cap; scanf("%d", &amp;ca); while(ca--)&#123; cnt = 0; memset(head, -1, sizeof(head)); scanf("%d%d%d", &amp;n, &amp;m, &amp;w); for(int i = 0; i &lt; m; i++)&#123; scanf("%d%d%d", &amp;from, &amp;to, &amp;cap); add(from, to, cap); add(to, from, cap); &#125; for(int i = 0; i &lt; w; i++)&#123; scanf("%d%d%d", &amp;from, &amp;to, &amp;cap); add(from, to, -cap); &#125; bool ans = spfa(1); if(ans) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 翻模板的时候发现了几年前写的时候用Bellman-Ford的版本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define INF 0x3f3f3f3fusing namespace std;struct node&#123; int u, v, cap;&#125;edge[5040];int cnt;int dis[520];int n, m, w;int Bellman_Ford()&#123; int i; for(i = 1; i &lt;= n; i++) dis[i] = INF; dis[1] = 0; for(i = 1; i &lt;= n; i++) &#123; int flag = 0; for(int j = 0; j &lt; cnt; j++) &#123; if(dis[edge[j].v] &gt; dis[edge[j].u] + edge[j].cap) &#123; flag = 1; dis[edge[j].v] = dis[edge[j].u] + edge[j].cap; &#125; &#125; if(flag == 0) break; &#125; return (i == n+1);&#125;void add(int u, int v, int c)&#123; edge[cnt].u = u; edge[cnt].v = v; edge[cnt++].cap = c;&#125;int main()&#123; int ca; scanf("%d", &amp;ca); while(ca--) &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;w); cnt = 0; int a, b, c; while(m--) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); add(a, b, c); add(b, a, c); &#125; while(w--) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); add(a, b, -c); &#125; int ans = Bellman_Ford(); if(ans == 1) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1860 Currency Exchange（SPFA）]]></title>
    <url>%2F2018%2F09%2F20%2Fpoj1860%2F</url>
    <content type="text"><![CDATA[判断是否存在负环/正环的最短路/最长路问题，把每种货币当作节点，兑换货币就是图上的有向边，使用SPFA查找是否会让起点进入一个正环就行了 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#define MAX 101#define INF 1e9using namespace std;double rate[MAX][MAX];double com[MAX][MAX];queue&lt;int&gt; q;bool isInqueue[MAX];double dis[MAX];int n, m, start;double v;int c1, c2;bool spfa()&#123; dis[start] = v; q.push(start); isInqueue[start] = true; while(!q.empty())&#123; int cur = q.front(); q.pop(); isInqueue[cur] = false; for(int i = 1; i &lt;= n; i++)&#123; if(dis[i] &lt; (dis[cur] - com[cur][i])*rate[cur][i])&#123; dis[i] = (dis[cur] - com[cur][i])*rate[cur][i]; if(!isInqueue[i])&#123; q.push(i); isInqueue[i] = true; &#125; &#125; &#125; if(dis[start] &gt; v) return true; &#125; return false;&#125;int main()&#123; while(~scanf("%d%d%d%lf", &amp;n, &amp;m, &amp;start, &amp;v))&#123; memset(rate, 0, sizeof(rate)); memset(com, 0, sizeof(com)); memset(isInqueue, 0, sizeof(isInqueue)); for(int i = 0; i &lt; MAX; i++)&#123; dis[i] = -INF; &#125; while(!q.empty())&#123; q.pop(); &#125; for(int i = 0; i &lt; m; i++)&#123; scanf("%d%d", &amp;c1, &amp;c2); scanf("%lf%lf%lf%lf", &amp;rate[c1][c2], &amp;com[c1][c2], &amp;rate[c2][c1], &amp;com[c2][c1]); &#125; bool isIncrease = spfa(); if(isIncrease)&#123; printf("YES\n"); &#125;else&#123; printf("NO\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2996 Help Me with the Game]]></title>
    <url>%2F2018%2F09%2F19%2Fpoj2996%2F</url>
    <content type="text"><![CDATA[又是大模拟，注意黑白的迭代顺序不大一样，和poj2993相反的题目（2993不做了😂，单纯就是在各种操作字符串） C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;string&gt; white[6]; vector&lt;string&gt; black[6]; char tmp[100]; char board[8][8]; memset(board, 0, sizeof(board)); for(int i = 7; i &gt;= 0; i--)&#123; scanf("%s", tmp); scanf("%s", tmp); for(int j = 0; j &lt; 8; j++)&#123; board[i][j] = tmp[2+j*4]; &#125; &#125; scanf("%s", tmp); for(int i = 0; i &lt; 8; i++)&#123; for(int j = 0; j &lt; 8; j++)&#123; if(board[i][j] == 'K')&#123; string pushStr = "Ka1"; pushStr[1] = 'a' + j; pushStr[2] = '1' + i; white[0].push_back(pushStr); &#125;else if(board[i][j] == 'Q')&#123; string pushStr = "Qa1"; pushStr[1] = 'a' + j; pushStr[2] = '1' + i; white[1].push_back(pushStr); &#125;else if(board[i][j] == 'R')&#123; string pushStr = "Ra1"; pushStr[1] = 'a' + j; pushStr[2] = '1' + i; white[2].push_back(pushStr); &#125;else if(board[i][j] == 'B')&#123; string pushStr = "Ba1"; pushStr[1] = 'a' + j; pushStr[2] = '1' + i; white[3].push_back(pushStr); &#125;else if(board[i][j] == 'N')&#123; string pushStr = "Na1"; pushStr[1] = 'a' + j; pushStr[2] = '1' + i; white[4].push_back(pushStr); &#125;else if(board[i][j] == 'P')&#123; string pushStr = "a1"; pushStr[0] = 'a' + j; pushStr[1] = '1' + i; white[5].push_back(pushStr); &#125; &#125; &#125; for(int i = 7; i &gt;= 0; i--)&#123; for(int j = 0; j &lt; 8; j++)&#123; if(board[i][j] == 'k')&#123; string pushStr = "Ka1"; pushStr[1] = 'a' + j; pushStr[2] = '1' + i; black[0].push_back(pushStr); &#125;else if(board[i][j] == 'q')&#123; string pushStr = "Qa1"; pushStr[1] = 'a' + j; pushStr[2] = '1' + i; black[1].push_back(pushStr); &#125;else if(board[i][j] == 'r')&#123; string pushStr = "Ra1"; pushStr[1] = 'a' + j; pushStr[2] = '1' + i; black[2].push_back(pushStr); &#125;else if(board[i][j] == 'b')&#123; string pushStr = "Ba1"; pushStr[1] = 'a' + j; pushStr[2] = '1' + i; black[3].push_back(pushStr); &#125;else if(board[i][j] == 'n')&#123; string pushStr = "Na1"; pushStr[1] = 'a' + j; pushStr[2] = '1' + i; black[4].push_back(pushStr); &#125;else if(board[i][j] == 'p')&#123; string pushStr = "a1"; pushStr[0] = 'a' + j; pushStr[1] = '1' + i; black[5].push_back(pushStr); &#125; &#125; &#125; bool flag = false; printf("White:"); for(int i = 0; i &lt; 6; i++)&#123; for(int j = 0; j &lt; white[i].size(); j++)&#123; if(flag == false)&#123; printf(" "); flag = true; &#125; else printf(","); cout &lt;&lt; white[i][j]; &#125; &#125; flag = false; printf("\nBlack:"); for(int i = 0; i &lt; 6; i++)&#123; for(int j = 0; j &lt; black[i].size(); j++)&#123; if(flag == false)&#123; printf(" "); flag = true; &#125; else printf(","); cout &lt;&lt; black[i][j]; &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>模拟法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1573 Robot Motion]]></title>
    <url>%2F2018%2F09%2F18%2Fpoj1573%2F</url>
    <content type="text"><![CDATA[大模拟，就酱 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;char arr[500][500];int flags[500][500];int main()&#123; int n, m, start; while(~scanf("%d%d%d", &amp;n, &amp;m, &amp;start) &amp;&amp; n != 0)&#123; memset(flags, -1, sizeof(flags)); for(int i = 1; i &lt;= n; i++)&#123; scanf("%s", &amp;arr[i][1]); &#125; int x = 1; int y = start; int cnt = 0; while(x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)&#123; if(flags[x][y] != -1)&#123; printf("%d step(s) before a loop of %d step(s)\n", flags[x][y], cnt-flags[x][y]); break; &#125;else&#123; flags[x][y] = cnt++; &#125; if(arr[x][y] == 'W') y-=1; else if(arr[x][y] == 'E') y+=1; else if(arr[x][y] == 'N') x-=1; else if(arr[x][y] == 'S') x+=1; &#125; if(!(x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)) printf("%d step(s) to exit\n", cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>模拟法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2632 Crashing Robots]]></title>
    <url>%2F2018%2F09%2F16%2Fpoj2632%2F</url>
    <content type="text"><![CDATA[模拟机器人走的序列，用一个数组标记当前每个位置是否有机器人以及机器人的编号就行 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;struct robot&#123; int x; int y; int dir;&#125;robots[101];int main()&#123; int ca; int num, step; int A, B, N, M; char tmp; int arr[101][101]; bool flag; scanf("%d", &amp;ca); while(ca--)&#123; flag = true; memset(arr, 0, sizeof(arr)); scanf("%d%d%d%d", &amp;A, &amp;B, &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++)&#123; scanf("%d%d", &amp;robots[i].x, &amp;robots[i].y); arr[robots[i].x][robots[i].y] = i; getchar(); scanf("%c", &amp;tmp); if(tmp == 'W') robots[i].dir = 0; else if(tmp == 'N') robots[i].dir = 1; else if(tmp == 'E') robots[i].dir = 2; else if(tmp == 'S') robots[i].dir = 3; &#125; for(int i = 0; i &lt; M; i++)&#123; scanf("%d", &amp;num); getchar(); scanf("%c", &amp;tmp); scanf("%d", &amp;step); if(flag == false) continue; if(tmp == 'F')&#123; if(robots[num].dir == 0)&#123; for(int j = 1; j &lt;= step &amp;&amp; robots[num].x-j &gt; 0; j++)&#123; if(arr[robots[num].x - j][robots[num].y] != 0)&#123; printf("Robot %d crashes into robot %d\n", num, arr[robots[num].x-j][robots[num].y]); flag = false; break; &#125; &#125; if(flag == false) continue; if(robots[num].x-step &gt; 0)&#123; arr[robots[num].x][robots[num].y] = 0; robots[num].x -= step; arr[robots[num].x][robots[num].y] = num; &#125;else&#123; printf("Robot %d crashes into the wall\n", num); flag = false; &#125; &#125;else if(robots[num].dir == 1)&#123; for(int j = 1; j &lt;= step &amp;&amp; robots[num].y+j &lt;= B; j++)&#123; if(arr[robots[num].x][robots[num].y+j] != 0)&#123; printf("Robot %d crashes into robot %d\n", num, arr[robots[num].x][robots[num].y+j]); flag = false; break; &#125; &#125; if(flag == false) continue; if(robots[num].y+step &lt;= B)&#123; arr[robots[num].x][robots[num].y] = 0; robots[num].y += step; arr[robots[num].x][robots[num].y] = num; &#125;else&#123; printf("Robot %d crashes into the wall\n", num); flag = false; &#125; &#125;else if(robots[num].dir == 2)&#123; for(int j = 1; j &lt;= step &amp;&amp; robots[num].x+j &lt;= A; j++)&#123; if(arr[robots[num].x + j][robots[num].y] != 0)&#123; printf("Robot %d crashes into robot %d\n", num, arr[robots[num].x+j][robots[num].y]); flag = false; break; &#125; &#125; if(flag == false) continue; if(robots[num].x+step &lt;= A)&#123; arr[robots[num].x][robots[num].y] = 0; robots[num].x += step; arr[robots[num].x][robots[num].y] = num; &#125;else&#123; printf("Robot %d crashes into the wall\n", num); flag = false; &#125; &#125;else if(robots[num].dir == 3)&#123; for(int j = 1; j &lt;= step &amp;&amp; robots[num].y-j &gt; 0; j++)&#123; if(arr[robots[num].x][robots[num].y-j] != 0)&#123; printf("Robot %d crashes into robot %d\n", num, arr[robots[num].x][robots[num].y-j]); flag = false; break; &#125; &#125; if(flag == false) continue; if(robots[num].y-step &gt; 0)&#123; arr[robots[num].x][robots[num].y] = 0; robots[num].y -= step; arr[robots[num].x][robots[num].y] = num; &#125;else&#123; printf("Robot %d crashes into the wall\n", num); flag = false; &#125; &#125; &#125;else if(tmp == 'L')&#123; robots[num].dir = (robots[num].dir - (step%4) + 4) % 4; &#125;else if(tmp == 'R')&#123; robots[num].dir = (robots[num].dir + (step%4) + 4) % 4; &#125; &#125; if(flag == true) printf("OK\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>模拟法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1068 Parencodings]]></title>
    <url>%2F2018%2F09%2F15%2Fpoj1068%2F</url>
    <content type="text"><![CDATA[给定括号串的两种编码，第一种是显示每个右括号左边有多少个左括号，第二种显示每个右括号与其匹配的左括号间有多少个右括号（包括自己），给出第一种编码，求第二种编码 可以直接模拟，算出原括号串然后去数出第二种编码，也可以定位与右括号匹配的左括号在哪个右括号分割出的区间内，即给出的第一种编码两个数之间是两个相邻右括号之间的左括号数，找的时候就从左边相邻的右括号开始枚举，每次加一个右括号数num_right同时加上中间相应的左括号数num_left直到num_left &gt; num_right为止 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int ca; int num; int diff[25]; int arr[25]; arr[0] = 0; scanf("%d", &amp;ca); while(ca--)&#123; memset(diff, 0, sizeof(diff)); scanf("%d", &amp;num); for(int i = 1; i &lt;= num; i++)&#123; scanf("%d", &amp;arr[i]); diff[i] = arr[i] - arr[i-1]; &#125; for(int i = 1; i &lt;= num; i++)&#123; int j = i; /*number of right parentheses between (j-1)th and (i)th right parentheses, including (i)th*/ int num_right = 1; /*number of left parentheses between (j-1)th and (i)th right parentheses*/ int num_left = diff[j]; while(num_right &gt; num_left)&#123; num_right += 1; j--; num_left += diff[j]; &#125; printf("%d ", num_right); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>模拟法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 3295 Tautology]]></title>
    <url>%2F2018%2F09%2F15%2Fpoj3295%2F</url>
    <content type="text"><![CDATA[求一个式子是否是重言式，符号在前，直接构造一个栈来枚举并求出式子是否都为真 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;bool valid(char* wff, int num)&#123; bool st[101]; int top = 0; int len = strlen(wff); for(int i = len-1; i &gt;= 0; i--)&#123; if(wff[i] == 'p')&#123; st[top++] = ((1&amp;num) == 1); &#125;else if(wff[i] == 'q')&#123; st[top++] = (((1&lt;&lt;1)&amp;num) == (1&lt;&lt;1)); &#125;else if(wff[i] == 'r')&#123; st[top++] = (((1&lt;&lt;2)&amp;num) == (1&lt;&lt;2)); &#125;else if(wff[i] == 's')&#123; st[top++] = (((1&lt;&lt;3)&amp;num) == (1&lt;&lt;3)); &#125;else if(wff[i] == 't')&#123; st[top++] = (((1&lt;&lt;4)&amp;num) == (1&lt;&lt;4)); &#125;else if(wff[i] == 'K')&#123; st[top-2] = (st[top-1] &amp;&amp; st[top-2]); top--; &#125;else if(wff[i] == 'A')&#123; st[top-2] = (st[top-1] || st[top-2]); top--; &#125;else if(wff[i] == 'C')&#123; st[top-2] = ((!st[top-2]) || st[top-1]); top--; &#125;else if(wff[i] == 'E')&#123; st[top-2] = (st[top-1] == st[top-2]); top--; &#125;else if(wff[i] == 'N')&#123; st[top-1] = !st[top-1]; &#125; &#125; return st[0];&#125;int main()&#123; char wff[101]; bool flag; while(scanf("%s", wff) &amp;&amp; strcmp(wff, "0") != 0)&#123; flag = true; for(int i = 0; i &lt; (1&lt;&lt;5); i++)&#123; if(valid(wff, i) == false)&#123; flag = false; break; &#125; &#125; if(flag) printf("tautology\n"); else printf("not\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>构造法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2586 Y2K Accounting Bug]]></title>
    <url>%2F2018%2F09%2F14%2Fpoj2586%2F</url>
    <content type="text"><![CDATA[给出盈利和亏损的固定值，任意连续五个月都是亏损的，问最大能够盈利多少。 先求出5个月中能够最小化亏损的组合然后依次循环，排列中应尽量将盈利月排在前面，这样最后两个月才能最大化盈利。 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;int main()&#123; int s, d; while(~scanf("%d%d", &amp;s, &amp;d)) &#123; if(s*4 &lt; d) &#123; if(10*s &gt; 2*d) &#123; printf("%d\n", 10*s - 2*d); &#125; else &#123; printf("Deficit\n"); &#125; &#125; else if(s*3 &lt; d*2) &#123; if(8*s &gt; 4*d) &#123; printf("%d\n", 8*s - 4*d); &#125; else &#123; printf("Deficit\n"); &#125; &#125; else if(s*2 &lt; d*3) &#123; if(6*s &gt; 6*d) &#123; printf("%d\n", 6*s - 6*d); &#125; else &#123; printf("Deficit\n"); &#125; &#125; else if(s &lt; d*4) &#123; if(3*s &gt; 9*d) &#123; printf("%d\n", 3*s - 9*d); &#125; else &#123; printf("Deficit\n"); &#125; &#125; else &#123; printf("Deficit\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2109 Power of Cryptography]]></title>
    <url>%2F2018%2F09%2F13%2Fpoj2109%2F</url>
    <content type="text"><![CDATA[给两个数n, p，求k使得k的n次方等于p。理论上应该使用大数来保证精度，但是这题用C++编译器的情况下直接pow也是可以的。大数的代码今后有时间调试好后补上。 C++ Code 123456789101112131415/*Only C++ compiler can Accepted*/#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;math.h&gt;using namespace std;int main()&#123; double n, p; while(~scanf("%lf%lf", &amp;n, &amp;p))&#123; printf("%.0lf\n", pow(p, 1/n)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1328 Radar Installation]]></title>
    <url>%2F2018%2F09%2F12%2Fpoj1328%2F</url>
    <content type="text"><![CDATA[预处理出每个岛所能容许的雷达范围，按照右端点排序，每次都新放置一个在新线段的右边，然后往后找哪个的左端点够不着了，再放在这个线段的右端点，以此类推 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;using namespace std;struct land&#123; double l; double r; int y; bool operator&lt;(const land&amp; b) const&#123; if(r == b.r)&#123; return l &lt; b.l; &#125; return r &lt; b.r; &#125;&#125;lands[1000];int main()&#123; int n, d; int cas = 1; bool flag = true; int cnt = 1; while(~scanf("%d%d", &amp;n, &amp;d) &amp;&amp; n != 0)&#123; flag = true; cnt = 1; int x; for(int i = 0; i &lt; n; i++)&#123; scanf("%d%d", &amp;x, &amp;lands[i].y); if(lands[i].y &gt; d || lands[i].y &lt; 0) flag = false; lands[i].l = x - sqrt(d*d - lands[i].y*lands[i].y); lands[i].r = x + sqrt(d*d - lands[i].y*lands[i].y); &#125; if(flag == false)&#123; printf("Case %d: %d\n", cas++, -1); continue; &#125; sort(lands, lands+n); double cur = lands[0].r; for(int i = 1; i &lt; n; i++)&#123; if(lands[i].l &gt; cur)&#123; cur = lands[i].r; cnt++; &#125; &#125; printf("Case %d: %d\n", cas++, cnt); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 2965 The Pilots Brothers' refrigerator]]></title>
    <url>%2F2018%2F09%2F11%2Fpoj2965%2F</url>
    <content type="text"><![CDATA[七灯问题变形，一共有16个开关，递归枚举变动的个数 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;bool isSame(int* pan)&#123; for(int i = 0; i &lt; 16; i++)&#123; if(pan[i] != 1) return false; &#125; return true;&#125;void flip(int* pan, int pos)&#123; int x = pos / 4; int y = pos % 4; pan[pos] = !(pan[pos]); for(int i = 0; i &lt; 4; i++)&#123; pan[4*x + i] = !(pan[4*x + i]); pan[4*i + y] = !(pan[4*i + y]); &#125;&#125;void dfs(int* pan, int cur, int* ans, int curPos, int* result, int* tmpResult)&#123; if(isSame(pan))&#123; *ans = min((int)(*ans), cur); for(int i = 0; i &lt; (int)(*ans); i++) result[i] = tmpResult[i]; return; &#125; if(curPos == 16) return; dfs(pan, cur, ans, curPos+1, result, tmpResult); flip(pan, curPos); tmpResult[cur] = curPos; dfs(pan, cur+1, ans, curPos+1, result, tmpResult); flip(pan, curPos);&#125;int main()&#123; int pan[16]; char row[5]; int pos = 0; int result[16]; int tmpResult[16]; for(int i = 0; i &lt; 4; i++)&#123; scanf("%s", row); getchar(); for(int j = 0; j &lt; 4; j++)&#123; if(row[j] == '+') pan[pos++] = 0; else pan[pos++] = 1; &#125; &#125; int ans = 20; dfs(pan, 0, &amp;ans, 0, result, tmpResult); printf("%d\n", ans); for(int j = 0; j &lt; ans; j++)&#123; printf("%d %d\n", result[j]/4 + 1, result[j]%4 + 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1753 Flip Game]]></title>
    <url>%2F2018%2F09%2F10%2Fpoj1753%2F</url>
    <content type="text"><![CDATA[太久不练实在是手生啊，干脆从POJ的分类题目开始重新训练。虽然研究僧时间还是蛮紧的，但是还是要抽点时间出来啊！！！😂 七灯问题变形，一共有16个开关，递归枚举变动的个数 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;bool isSame(int* pan)&#123; for(int i = 1; i &lt; 16; i++)&#123; if(pan[i] != pan[i-1]) return false; &#125; return true;&#125;void flip(int* pan, int pos)&#123; int x = pos / 4; int y = pos % 4; pan[pos] = !(pan[pos]); if(y &lt; 3)&#123; pan[pos+1] = !(pan[pos+1]); &#125; if(y &gt; 0)&#123; pan[pos-1] = !(pan[pos-1]); &#125; if(x &lt; 3)&#123; pan[pos + 4] = !(pan[pos + 4]); &#125; if(x &gt; 0)&#123; pan[pos - 4] = !(pan[pos - 4]); &#125;&#125;bool dfs(int* pan, int cur, int len, int curPos)&#123; if(cur == len) if(isSame(pan))&#123; return true; &#125; else return false; if(16 - curPos &lt; len - cur) return false; int* new_pan = new int[16]; for(int i = curPos; i &lt; 16; i++)&#123; for(int j = 0; j &lt; 16; j++)&#123; new_pan[j] = pan[j]; &#125; flip(new_pan, i); if(dfs(new_pan, cur+1, len, i+1))&#123; return true; &#125; &#125; return false;&#125;int main()&#123; int pan[16]; char row[5]; int pos = 0; for(int i = 0; i &lt; 4; i++)&#123; scanf("%s", row); getchar(); for(int j = 0; j &lt; 4; j++)&#123; if(row[j] == 'b') pan[pos++] = 0; else pan[pos++] = 1; &#125; &#125; if(isSame(pan))&#123; printf("0\n"); &#125;else&#123; int ans; int i; for(i = 1; i &lt;= 16; i++)&#123; /*number of flipped*/ if(dfs(pan, 0, i, 0))&#123; printf("%d\n", i); break; &#125; &#125; if(i == 17) printf("Impossible\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>poj</tag>
        <tag>poj分类训练</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Spring Boot框架内使用Shiro与Mybatis完成用户登录]]></title>
    <url>%2F2018%2F09%2F09%2Fspringboot_shiro%2F</url>
    <content type="text"><![CDATA[在采用Spring Boot框架的Web应用内使用Shiro与Mybatis完成用户的登录的验证 前面的笔记已经说到了如何创建一个Spring Boot项目并在Spring Boot框架内使用Mybatis，接下来就要在现有的基础上结合Shiro框架来实现一个简单的用户登录功能了 首先需要创建需要的数据表，这里我们一共需要创建5张表，分别是： user（用户表） role（角色表） permission（权限表） user_role（用户-角色映射表） role_permission（角色-权限映射表） 采用的是用户与角色关联，然后再给不同角色分配权限的模式，具体表格式如下所示 1234567891011121314151617181920212223242526272829303132create table user( id int(11) not null auto_increment, name varchar(30) not null unique, password varchar(50) not null, primary key(id));create table role( id int(11) not null auto_increment, name varchar(30) not null unique, primary key(id));create table permission( id int(11) not null auto_increment, name varchar(30) not null unique, primary key(id));create table user_role( user_id int(11), role_id int(11), foreign key(user_id) references user(id) on delete cascade, foreign key(role_id) references role(id) on delete cascade);create table role_permission( role_id int(11), permission_id int(11), foreign key(role_id) references role(id) on delete cascade, foreign key(permission_id) references permission(id) on delete cascade); 为了作为模板示范，添加两种角色user与admin 为user添加read权限，为admin同时添加read与write权限 123456789insert into role(name) value('user');insert into role(name) value('admin');insert into permission(name) value('read');insert into permission(name) value('write');insert into role_permission(role_id, permission_id) value(1, 1);insert into role_permission(role_id, permission_id) value(2, 1);insert into role_permission(role_id, permission_id) value(2, 2); 然后就要参照每一张表创建MyBatis实例和映射文件，创建方法参考在Spring Boot框架内使用Mybatis 紧接着就是配置Shiro，最重要的就是一个配置文件和一个Realm，这两个文件是shiro工作的核心 首先是配置文件，主要负责Shiro的主体设置、Realm设置，加密设置，这在之前Shiro框架中已经提到过。最重要的，Shiro与Spring Boot Web框架整合，还需要设置过滤器，即让Shiro收到网页请求后逐个检查改请求访问的页面或方法是否需要身份验证，需要什么身份或权限。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package org.phoenix.shiro;import org.apache.shiro.authc.credential.HashedCredentialsMatcher;import org.apache.shiro.cache.ehcache.EhCacheManager;import org.apache.shiro.spring.LifecycleBeanPostProcessor;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;import org.apache.shiro.web.filter.authc.LogoutFilter;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.DependsOn;import javax.servlet.Filter;import java.util.LinkedHashMap;import java.util.Map;@Configurationpublic class ShiroConfiguration &#123; /** * 负责org.apache.shiro.util.Initializable类型bean的生命周期的，初始化和销毁 * @return */ @Bean(name = "lifecycleBeanPostProcessor") public LifecycleBeanPostProcessor lifecycleBeanPostProcessor()&#123; return new LifecycleBeanPostProcessor(); &#125; /** * 密码编码 * @return */ @Bean(name = "hashCredentialsMatcher") public HashedCredentialsMatcher hashedCredentialsMatcher()&#123; HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher(); credentialsMatcher.setHashAlgorithmName("MD5"); credentialsMatcher.setHashIterations(1); credentialsMatcher.setStoredCredentialsHexEncoded(true); return credentialsMatcher; &#125; @Bean(name = "myRealm") @DependsOn("lifecycleBeanPostProcessor") public MyRealm myRealm()&#123; MyRealm realm = new MyRealm(); realm.setCredentialsMatcher(hashedCredentialsMatcher()); return realm; &#125; @Bean(name = "ehCacheManager") @DependsOn("lifecycleBeanPostProcessor") public EhCacheManager ehCacheManager()&#123; return new EhCacheManager(); &#125; @Bean(name = "securityManager") public DefaultWebSecurityManager securityManager()&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); securityManager.setRealm(myRealm());// add later// securityManager.setCacheManager(ehCacheManager()); return securityManager; &#125; @Bean(name = "shiroFilter") public ShiroFilterFactoryBean shiroFilterFactoryBean()&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); shiroFilterFactoryBean.setSecurityManager(securityManager()); Map&lt;String, Filter&gt; filters = new LinkedHashMap&lt;&gt;(); LogoutFilter logoutFilter = new LogoutFilter(); logoutFilter.setRedirectUrl("/login"); shiroFilterFactoryBean.setFilters(filters); Map&lt;String, String&gt; filterChainDefinitionManger = new LinkedHashMap&lt;&gt;(); //logout直接加载logout filterChainDefinitionManger.put("/logout", "logout"); //访问index下url需要authentication filterChainDefinitionManger.put("/index", "authc, perms[read]"); filterChainDefinitionManger.put("/admin", "authc, perms[write]"); filterChainDefinitionManger.put("/**", "anon"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionManger); shiroFilterFactoryBean.setSuccessUrl("/index"); shiroFilterFactoryBean.setLoginUrl("/login"); shiroFilterFactoryBean.setUnauthorizedUrl("/403"); return shiroFilterFactoryBean; &#125;&#125; 在shiroFilterFactoryBean()中设置了/index页面和/admin页面需要身份验证authc，也就是登录状态，否则就会跳转到。同时/index需要用户具有read权限而/admin需要有read和write权限，如不具有相应权限则会跳转到错误页面。 对于Realm设置如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package org.phoenix.shiro;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.phoenix.bean.Permission;import org.phoenix.bean.Role_Permission;import org.phoenix.bean.User;import org.phoenix.bean.User_Role;import org.phoenix.dao.PermissionDao;import org.phoenix.dao.RoleDao;import org.phoenix.dao.UserDao;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.session.Session;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;import org.springframework.beans.factory.annotation.Autowired;public class MyRealm extends AuthorizingRealm&#123; @Autowired private UserDao userDao; @Autowired private RoleDao roleDao; @Autowired private PermissionDao permissionDao; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); String username = (String)principalCollection.getPrimaryPrincipal(); User user = userDao.getByUserName(username); for(User_Role user_role : userDao.getRoles(user.getId()))&#123; for(Role_Permission role_permission: roleDao.getPermissions(user_role.getRoleId()))&#123; Permission permission = permissionDao.getById(role_permission.getPermissionId()); authorizationInfo.addStringPermission(permission.getName()); &#125; &#125; return authorizationInfo; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; String userName = token.getUsername(); User user = userDao.getByUserName(userName); if(user != null)&#123; Session session = SecurityUtils.getSubject().getSession(); session.setAttribute("user", user); SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(userName, user.getPassword(), getName()); authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(userName)); return authenticationInfo; &#125;else&#123; return null; &#125; &#125;&#125; Realm进行身份验证的时候需要创建一个该用户的会话（这一点与单独的Shiro框架不同） 进行身份授权的时候首先要查询用户的Role，然后再根据Role查询相应的Permission加入AuthorizationInfo中返回 注册两个用户，然后分别赋予user角色和admin角色 12insert into user_role value(1, 1);insert into user_role value(2, 2); 系统效果 登录界面 首先以user身份进行登录进入/index 点击试试管理员权限，发现并不能进入/admin页面，而是跳转到了/403页面 返回选择登出重新以管理员身份登录，然后再试试管理员权限，成功进入]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Shiro</tag>
        <tag>Mybatis</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 18.04中安装MySQL以及普通用户无法登录问题]]></title>
    <url>%2F2018%2F09%2F06%2Fubuntu_mysql%2F</url>
    <content type="text"><![CDATA[在ubuntu 18.04下安装/升级MySQL数据库并解决安装后普通用户无法登录MySQL，必须使用sudo才能够登录的问题。 安装删除旧版本 1sudo apt --purge remove mysql-server mysql-common mysql-client 安装新版本 1sudo apt install mysql-server mysql-common mysql-client 这时候登录mysql 1mysql -u root -p 输入密码后无法登录，出现Error，但是 1sudo mysql -u root -p 却能够正常登录的话，那么就按照下面的步骤修改root密码 修改root密码123sudo mysql -u rootmysql&gt; use mysql;mysql&gt; select User, plugin from user; 发现root用户的plugin不太一样，重建一个root 1234mysql&gt; drop user 'root'@'localhost';Query OK, 0 rows affected (0,00 sec)mysql&gt; create user 'root'@'localhost' identified by 'new_password'Query OK, 0 rows affected (0,00 sec) 刷新权限 1234mysql&gt; grant all privileges on *.* to 'root'@'localhost' with grant option;Query OK, 0 rows affected (0,00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0,00 sec) 再次输入命令 1mysql -u root -p 应该就可以正常登录了]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Spring Boot框架内使用Mybatis]]></title>
    <url>%2F2018%2F09%2F03%2Fspringboot_mybatis%2F</url>
    <content type="text"><![CDATA[Mybatis是一个基于Java的持久层框架，帮助将SQL数据可以中的实体映射到Java实例中，方便增删改查的实现。本篇笔记记录如何将Mybatis与Spring Boot框架相结合进行使用 首先需要创建一个Spring Boot项目 然后以用户（User）为例来使用Mybatis Maven依赖 1234567891011121314151617181920&lt;properties&gt; &lt;mybatis.version&gt;3.2.7&lt;/mybatis.version&gt; &lt;mybatis-spring.version&gt;1.2.2&lt;/mybatis-spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis-spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; ​ 创建实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package org.phoenix.bean;public class User &#123; private Integer uid; private String username; //不返回password// @JsonIgnore private String password; public Integer getId() &#123; return uid; &#125; public void setId(Integer id)&#123; this.uid = id; &#125; public String getUsername()&#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString()&#123; return "UserDao&#123;" + "id=" + uid + ", username=" + username + ", password=" + password + "&#125;"; &#125;&#125; ​ DAO（Data Access Object）层 12345678910111213141516package org.phoenix.dao;import org.phoenix.bean.User;import org.springframework.dao.DataAccessException;import java.util.List;import java.util.Map;public interface UserDao &#123; List&lt;User&gt; getByMap(Map&lt;String, Object&gt; map); User getById(Integer id); Integer create(User user) throws DataAccessException; int update(User user); int delete(Integer id); User getByUserName(String userNmae);&#125; ​ Service层 123456789101112131415161718192021222324252627282930313233343536373839404142package org.phoenix.Service;import org.phoenix.bean.User;import org.phoenix.dao.UserDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.dao.DataAccessException;import org.springframework.stereotype.Service;import java.util.List;import java.util.Map;@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; getByMap(Map&lt;String, Object&gt; map)&#123; return userDao.getByMap(map); &#125; public User getById(Integer id)&#123; return userDao.getById(id); &#125; public User create(User user)throws DataAccessException &#123; userDao.create(user); return user; &#125; public User update(User user)&#123; userDao.update(user); return user; &#125; public int delete(Integer id)&#123; return userDao.delete(id); &#125; public User getByUserName(String userName)&#123; return userDao.getByUserName(userName); &#125;&#125; ​ UserDaoMapper，连接了Dao层与Mapper，就是Mybatis工作的地方，这里面用XML语法编写了所有操作要用到的SQL语句，并与DAO层内的接口一一对应，当调用DAO层内接口的时候，就会完成对数据库的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="org.phoenix.dao.UserDao"&gt; &lt;resultMap id="userMap" type="org.phoenix.bean.User"&gt; &lt;id property="uid" column="uid"/&gt; &lt;result property="username" column="username"/&gt; &lt;result property="password" column="password"/&gt; &lt;/resultMap&gt; &lt;sql id="queryCondition"&gt; &lt;where&gt; &lt;if test="uid != null and uid != ''"&gt; and uid = #&#123;uid&#125; &lt;/if&gt; &lt;if test="username != null and username != ''"&gt; and username = #&#123;username&#125; &lt;/if&gt; &lt;if test="password != null and password != ''"&gt; and password = #&#123;password&#125; &lt;/if&gt; &lt;if test="keywords != null and keywords != ''"&gt; and username like CONCAT('%', #&#123;keywords&#125;,'%') &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt; &lt;select id="getByMap" parameterType="map" resultMap="userMap"&gt; SELECT * FROM user &lt;include refid="queryCondition" /&gt; &lt;/select&gt; &lt;select id="getById" parameterType="int" resultMap="userMap"&gt; SELECT * FROM user WHERE uid =#&#123;uid&#125; &lt;/select&gt; &lt;select id="getByUserName" parameterType="String" resultMap="userMap"&gt; SELECT * FROM user WHERE username =#&#123;username&#125; &lt;/select&gt; &lt;insert id="create" parameterType="org.phoenix.bean.User"&gt; &lt;!--&lt;selectKey resultType="int" order="AFTER" keyProperty="id" &gt;--&gt; &lt;!--SELECT LAST_INSERT_ID()--&gt; &lt;!--&lt;/selectKey&gt;--&gt; INSERT INTO user( username, password )VALUES( #&#123;username&#125;, #&#123;password&#125; ) &lt;/insert&gt; &lt;update id="update" parameterType="org.phoenix.bean.User"&gt; UPDATE user SET username = #&#123;username&#125;, password = #&#123;password&#125; WHERE uid = #&#123;uid&#125; &lt;/update&gt; &lt;delete id="delete" parameterType="int"&gt; DELETE FROM user WHERE uid = #&#123;uid&#125; &lt;/delete&gt;&lt;/mapper&gt; ​ 接下来就是要配置Mybatis，让它知道要在哪里找Dao层，哪里找Mapper，用什么数据库，数据库地址是什么，用户密码是什么，在用哪个database等等 配置数据连接，提供数据库连接的信息 123456789101112131415161718192021222324252627282930313233343536package org.phoenix.config;import com.mchange.v2.c3p0.ComboPooledDataSource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;import java.beans.PropertyVetoException;/** * 配置数据库连接 */@Configurationpublic class DataSourceConfig &#123; @Autowired private Environment env; @Bean(name = "dataSource") public ComboPooledDataSource dataSource() throws PropertyVetoException&#123; ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(env.getProperty("jdbc.driverClassName")); dataSource.setJdbcUrl(env.getProperty("jdbc.url")); dataSource.setUser(env.getProperty("jdbc.username")); dataSource.setPassword(env.getProperty("jdbc.password")); dataSource.setMaxPoolSize(20); dataSource.setMinPoolSize(5); dataSource.setInitialPoolSize(10); dataSource.setMaxIdleTime(300); dataSource.setAcquireIncrement(5); dataSource.setIdleConnectionTestPeriod(60); return dataSource; &#125;&#125; 然后需要提供DAO层所在的位置 1234567891011121314151617181920package org.phoenix.config;import org.mybatis.spring.mapper.MapperScannerConfigurer;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * 扫描DAO文件 */@Configurationpublic class MapperSacnnerConfig &#123; @Bean public MapperScannerConfigurer mapperSacnnerConfigurer()&#123; MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setBasePackage("**.dao"); mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory"); return mapperScannerConfigurer; &#125;&#125; 用上面的信息来设置MyBatis，并告诉Mybatis映射文件Mapper的位置，MyBatis就会自动将UserDao自动对应到同前缀文件UserDaoMapper.xml上 1234567891011121314151617181920212223242526272829303132333435package org.phoenix.config;import org.apache.ibatis.type.JdbcType;import org.mybatis.spring.SqlSessionFactoryBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;/** * 配置Mybatis映射文件 */@Configurationpublic class MyBatisConfig &#123; @Autowired private DataSource dataSource; @Bean(name = "sqlSessionFactory") public SqlSessionFactoryBean sqlSessionFactory( ApplicationContext applicationContext) throws Exception&#123; SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration(); configuration.setMapUnderscoreToCamelCase(true); configuration.setJdbcTypeForNull(JdbcType.NULL); sessionFactory.setMapperLocations(applicationContext.getResources("classpath:mapper/*.xml")); return sessionFactory; &#125;&#125; ​ 最后配置Spring Boot的REST接口来通过UserService调用UserDao 123456789101112131415161718192021222324252627282930package org.phoenix.controller;import org.phoenix.Service.UserService;import org.phoenix.bean.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;import javax.servlet.http.HttpServletRequest;import java.util.List;@RequestMapping(value = "/users")@RestControllerpublic class UserController &#123; @Autowired private UserService userService; @RequestMapping(method = RequestMethod.GET) public List&lt;User&gt; list(HttpServletRequest request)&#123; return userService.getByMap(null); &#125; @RequestMapping(value = "/&#123;id&#125;", method = RequestMethod.GET) public User detail(@PathVariable Integer id)&#123; return userService.getById(id); &#125;&#125; ​ 启动应用，在浏览器地址栏内输入http://localhost:8080/users 就会出现预先在数据库里存号的用户信息 1[&#123;"username":"123","password":"af17a6d2be6676b4cf53b3ae81796fa6","id":1&#125;,&#123;"username":"admin","password":"c0e024d9200b5705bc4804722636378a","id":2&#125;] 如果要按id查找，例如查找id=1的用户，就输入http://localhost:8080/users/1 就可以了 项目的Github地址]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shiro安全框架入门]]></title>
    <url>%2F2018%2F09%2F02%2Fshiro%2F</url>
    <content type="text"><![CDATA[对Shiro安全框架的各种操作进行简单的入门，为Shiro框架嵌入Web应用进行基础练习讲解 ShiroApache Shiro是一个简单强大的Java安全框架，提供了用户身份验证、权限授权、加密和会话管理等功能，通过Shiro可以简单快速地帮助各种应用确保安全 Authentication（身份验证） 通过数据库或其他地方存储的用户信息进行比较，确认用户是否登录登录 Authorization（授权） 通过数据库内存储的用户角色信息确认用户权限 Cryptography（加密） 对信息，如密码，进行加密操作 Session Management（会话管理） 进行用户会话管理，保持登录状态 Demo maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; ​ Authentication简单测试，使用Junit进行单元测试 123456789101112131415161718192021222324252627282930313233343536373839404142package org.phoenix.test;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.SimpleAccountRealm;import org.apache.shiro.subject.Subject;import org.junit.Before;import org.junit.Test;public class AutenticationTest &#123; SimpleAccountRealm simpleAccountRealm = new SimpleAccountRealm(); @Before public void addUser()&#123; simpleAccountRealm.addAccount("Ph0en1x", "1234", "admin"); &#125; @Test public void testAutentication()&#123; // 构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); defaultSecurityManager.setRealm(simpleAccountRealm); // 主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("Ph0en1x", "1234"); subject.login(token); System.out.println("isAutenticated: " + subject.isAuthenticated()); subject.checkRole("admin"); subject.logout(); System.out.println("isAutenticated: " + subject.isAuthenticated()); &#125;&#125; 这是Shiro安全模块最简单结构的构建，首先需要构建SecurityManager环境。而构建SecurityManager环境需要一个叫作Realm的组件，Realm里面将会进行用户身份认证以及授权等一系列操作。这里我只创建了简单的，只能进行预先加入到内存中的用户的身份验证和授权的SimpleRealm。 在Junit的@Before标签中我们就预先加入了一个用户用于测试 这之后需要将刚刚完成Realm配置的SecurityManager配置到环境中，并生成一个主体（Subject），后面将由主体来发送认证请求给Realm 身份认证请求被包含在一个UsernamePasswordToken中，然后由主体发送login请求，同时进行admin权限验证 上述代码将会得到以下输出 12isAutenticated: trueisAutenticated: false 当主体发送logout请求后再进行身份验证就会返回false 当UsernamePasswordToken中的用户密码不正确时，会抛出异常 1org.apache.shiro.authc.IncorrectCredentialsException: Submitted credentials for token [org.apache.shiro.authc.UsernamePasswordToken - Ph0en1x, rememberMe=false] did not match the expected credentials. 当验证用户不具有相应身份或权限时，会抛出异常 1org.apache.shiro.authz.UnauthorizedException: Subject does not have role [admin] CustomRealm自定义Realm Realm是Shiro进行身份验证和授权的最核心组件，所以也一定能开放给用户进行自定义，例如想根据某个数据库或者文件中的信息来进行相应的验证，密码加密验证等等操作。我这里也写了一个简单的从数据库中查询用户密码来验证登录用户身份的CustomRealm 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package org.phoenix.shiro.realm;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.crypto.hash.Md5Hash;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import org.apache.shiro.util.ByteSource;import java.sql.*;public class CustomerRealm extends AuthorizingRealm&#123; protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; //角色授权 return null; &#125; protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; //认证用户 String username = (String)authenticationToken.getPrincipal(); String password = getPasswordByUserName(username); if(password == null)&#123; return null; &#125; SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo( "Ph0en1x", password, "customRealm" ); // 传回的时候也要带盐 authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(username)); return authenticationInfo; &#125; private String getPasswordByUserName(String username) &#123; String url = "jdbc:mysql://127.0.0.1/test"; String name = "root"; String password = "1234"; String result = null; try&#123; Connection con = DriverManager.getConnection(url, name, password); String sql = String.format("select password from user where username = \'%s\'", username); Statement statement = con.createStatement(); ResultSet rs = statement.executeQuery(sql); rs.next(); // md5加盐操作 result = (new Md5Hash(rs.getString("password"), username)).toString(); System.out.println(result); &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125; return result; &#125;&#125; CustomerRealm都继承于AuthorizingRealm，而AuthorizingRealm继承于AuthenticatingRealm 而完成CustomerRealm，需要实现两个abstract方法doGetAuthorizationInfo和doGetAuthenticationInfo分别用于授权和身份验证请求的处理。 还有就是密码的加盐操作，数据并不会明文存在数据库中。通常会通过一些加密操作，例如MD5码，在加密的过程中为了加大破译的难度，往往还会带上一些别的信息，叫作“盐”（salt）。例如上面我获取密码的方法getPasswordByUserName就在获得密码后进行了加盐加密的操作（用来模拟存储加密后的密码，实际使用中是加盐加密后再存入数据库中），并且通过setCredentialsSalt方法告诉验证信息加入的盐是什么。 相应的，在Shiro的配置中也要加入相应的加密方法和盐的配置 1234567891011121314151617181920212223242526272829303132333435363738394041package org.phoenix.test;import org.phoenix.shiro.realm.CustomerRealm;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.authc.credential.HashedCredentialsMatcher;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.subject.Subject;import org.junit.Test;public class CustomRealmTest &#123; @Test public void testAutentication()&#123; CustomerRealm customerRealm = new CustomerRealm(); // 构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager(); defaultSecurityManager.setRealm(customerRealm); //加密设置 HashedCredentialsMatcher matcher = new HashedCredentialsMatcher(); matcher.setHashAlgorithmName("md5"); matcher.setHashIterations(1); customerRealm.setCredentialsMatcher(matcher); // 主体提交认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("Ph0en1x", "1234"); subject.login(token); System.out.println("isAutenticated: " + subject.isAuthenticated());// subject.checkRole("admin");// subject.checkPermission("user:delete"); subject.logout(); System.out.println("isAutenticated: " + subject.isAuthenticated()); &#125;&#125; 加密设置就是告诉Shiro我的密码是用了一次迭代的md5加密的，再配合setCredentialsSalt里的盐信息，就可以完成身份验证 ​ 这里还有其他的一些关于Shiro的简单代码]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建第一个Angular Web应用]]></title>
    <url>%2F2018%2F09%2F01%2Fangular%2F</url>
    <content type="text"><![CDATA[使用node.js搭建第一个简单的angular应用 安装node.js 在nodejs官网上下载新版本的Node.js安装包到本地(这里用Ubuntu为例，使用apt默认源中的nodejs版本过旧，所以到官网下载安装包) 解压 1tar -xvf node-v8.11.4-linux-x64.tar.xz 将解压后目录内的bin/下的node和npm的链接放置在系统目录下，配置全局使用 12sudo ln -s /home/ph0en1x/Program_Files/node-v8.11.4-linux-x64/bin/node /usr/local/bin/nodesudo ln -s /home/ph0en1x/Program_Files/node-v8.11.4-linux-x64/bin/npm /usr/local/bin/npm 由于我的根目录与home目录挂载着不同的硬盘，所以只能使用软链接，如果是同一块硬盘也可以使用硬链接 确认版本 12node --versionnpm --version ​ 搭建Angular应用 全局安装Angular CLI 1npm install -g @angular/cli 新建工程 1ng new my-app 启动应用 12cd my-appng serve --open 最后进入浏览器输入 http://localhost:4200 看到demo 具体教程参考Angular官方文档]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 42 Trapping Rain Water]]></title>
    <url>%2F2018%2F08%2F24%2Fleetcode42%2F</url>
    <content type="text"><![CDATA[2-SUM 同类型题目， 与LeetCode11思想相似 Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcosfor contributing this image! 这题会卡时间限制，要求使用O(n)的方法来解决这个问题； 实际上只需要计算每个格子左右的高度最大值中取较小的那个与当前的高度取正差值即可； 优化：可以仅遍历一次就完成计算，即设置左指针与右指针，并且记录左指针左边的最大值以及右指针右边的最大值，每次比较两个最大值，如果左最大值小于右最大值，那么右边不会对左指针指的位置产生限制，直接用左最大值计算即可，右边同理； Python Code 123456789101112131415161718192021222324252627class Solution: def trap(self, height): """ :type height: List[int] :rtype: int """ length = len(height) if height == None or length == 0: return 0 l = 0 r = length - 1 result = 0 maxL = maxR = 0 while l &lt;= r: maxL = max(height[l], maxL) maxR = max(height[r], maxR) if maxL &lt; maxR: result += maxL - height[l] l += 1 else: result += maxR - height[r] r -= 1 return result]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 11 Container With Most Water]]></title>
    <url>%2F2018%2F08%2F23%2Fleetcode11%2F</url>
    <content type="text"><![CDATA[2-SUM 同类型题目 Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. 算法： 刚开始设置最左边和最右边两个板，记录当前面积，然后把短的那边的指针向中心移动一个位置，比较面积，以此类推； 证明： 以左边指针为例，如果左边较短，那么右边的指针无论怎么向左移动都不可能得到更大的面积了，所以可以看作直接跳过大层循环，即左边指针向右一位。右边指针同理； 左边向右一位后，右边的指针不需要回到最右边，因为右边指针的右边不可能有比左边指针移动前更大的（相当于双方打擂台，守擂的一定比对方之前打擂失败的都要强），所以左指针移动后不可能通过右指针右边的数得到更好的答案。 Python Code 1234567891011121314151617class Solution(object): def maxArea(self, height): """ :type height: List[int] :rtype: int """ mx = 0 i = 0 j = len(height) - 1 while i &lt; j: v = min(height[i], height[j]) * (j-i) mx = max(mx, v) if height[i] &lt; height[j]: i += 1 else: j -= 1 return mx]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 41 First Missing Positive]]></title>
    <url>%2F2018%2F08%2F23%2Fleetcode41%2F</url>
    <content type="text"><![CDATA[桶排序思想，一种理想情况下接近O(n)的排序算法 Given an unsorted integer array, find the smallest missing positive integer. Example 1: 123&gt; Input: [1,2,0]&gt; Output: 3&gt; Example 2: 123&gt; Input: [3,4,-1,1]&gt; Output: 2&gt; Example 3: 123&gt; Input: [7,8,9,11,12]&gt; Output: 1&gt; Note: Your algorithm should run in O(n) time and uses constant extra space. 假设这n个数就是1-n进行排序，即i应该放在nums[i-1]上 扫描一遍数组，只要当前位置上的数不是在1-n之间并且没有正确摆放，就与正确位置上的数进行一次交换 所有的数都会被扫描到一遍，每一次交换都会使得一个数到达它应该在的位置上，所以最多交换n次，扫描过后所有在1-n区间内的数都会被换到它应该在的位置上 再从头扫描一遍数组，第一个放置错误的位置就是第一个缺失的数，如果都正确了，那么就是n+1缺失 Python Code 12345678910111213141516171819class Solution: def firstMissingPositive(self, nums): """ :type nums: List[int] :rtype: int """ length = len(nums) if length == 0: return 1 for i in range(length): while nums[i] &gt; 0 and nums[i] &lt;= length and nums[i] != i+1 and nums[i] != nums[nums[i]-1]: tmp = nums[nums[i]-1] nums[nums[i]-1] = nums[i] nums[i] = tmp for i in range(length): if nums[i] != i+1: return i+1 return length+1]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jsoup编写网络爬虫]]></title>
    <url>%2F2018%2F07%2F16%2Fjsoup%2F</url>
    <content type="text"><![CDATA[以爬取Stack Overflow的搜索结果为例，使用Jsoup库编写Java网络爬虫 Jsoup是一个非常好用并且开源的Java爬虫（用来发送请求和解析Html的库），本篇笔记将会介绍如何使用Jsoup编写一个简单的网络爬虫，用来获取Stack Overflow的搜索结果 Jsoup官网有非常棒的文档，建议有能力的可以直接参考; 下面开始编写一个自己的Demo 首先创建一个Maven工程项目，并在pom.xml文件中导入jsoup包引用 12345&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.11.2&lt;/version&gt;&lt;/dependency&gt; ​ 创建一个java文件，命名为JsoupTest.java 引入需要的相应的引用 12345import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.nodes.Element;import org.jsoup.select.Elements;import java.io.IOException; ​ 进入Stack Overflow首页，以IOException为例搜索一下，然后打开调试工具查看网页的结构，我们需要获取每个问题、问题的摘要以及问题的链接。 选取我们需要的结果区域，可以看到我们要的元素在一个类型为question-summary的div下一个类型为summary的div下，其中： class=&quot;result-link&quot;里面存着问题以及问题的链接; class=&quot;excerpt&quot;里面存着问题的摘要; class=&quot;tags&quot;里面存着问题的标签; class=&quot;started&quot;里面存着提问日期 ​ 知道结构以后就可以开始编写爬虫了 首先定义URL，Stackoverflow使用GET请求的方式来进行搜索，所以创建两个串 12static String url = "https://stackoverflow.com/search?q=";static String query = "IOException"; 第二个query串就是要搜索的内容，前面是查询url的前缀 然后使用Jsoup发送请求，把query直接接在url后面就行 1Document doc = Jsoup.connect(url+query).get(); doc为收到的response，也就是整个页面，这时候就可以使用Jsoup的解析功能来提取我们需要的内容了： 提取question-summary类下的summary类(CSS语法) 1Elements elements = doc.select(".question-summary .summary"); 这样将得到一个Html元素的队列，然后迭代地进行内容的提取 1234567for(Element e : elements)&#123; Elements title = e.select(".result-link h3 a"); System.out.println("title: " + title.get(0).attr("title")); System.out.println("url: " + title.get(0).absUrl("href")); Elements excerpt = e.select(".excerpt"); System.out.println("Excerpt: " + excerpt.text() + "\n");&#125; 同样也是采用CSS语法，attr()方法会获取元素里的某个属性值(Attribute)，由于很多页面内的链接都是相对路径，absurl()会获取href属性中的url后，自动形成我们需要的绝对路径，text()将会获取元素中的文本元素(不包含标签)，html()则是获得该元素下的所有内容; ​ 然后查看显示结果 123456789101112title: HttpClient request throws IOExceptionurl: https://stackoverflow.com/questions/13141434/httpclient-request-throws-ioexceptionExcerpt: The following code throws a IOException with the message: &quot;The specified registry key does not exist.&quot; HttpClient client = new HttpClient(); Uri uri = new Uri(&quot;http://www.google.com …title: How to avoid Java code in JSP files?url: https://stackoverflow.com/questions/3177733/how-to-avoid-java-code-in-jsp-files/3180202#3180202Excerpt: , IOException &#123; if (((HttpServletRequest) request).getSession().getAttribute(&quot;user&quot;) == null) &#123; ((HttpServletResponse) response).sendRedirect(&quot;login&quot;); // Not logged in, redirect to login page … ServletException, IOException &#123; try &#123; List&lt;Product&gt; products = productService.list(); // Obtain all products. request.setAttribute(&quot;products&quot;, products); // Store products in …title: Understanding Java IOExceptionurl: https://stackoverflow.com/questions/5819121/understanding-java-ioexceptionExcerpt: I need some help with understanding the IOException. I&apos;ve reviewed a lot of information on the internet, and looked at the technical specifications at Oracle&apos;s Java website. Am I correct in my … understanding of the IOException class and all of it&apos;s sub-classes, that there are no associated &quot;error messages&quot; or &quot;return code&quot; values? So if one wanted to issue some message and/or return code value …... ​ 完成我们要的提取 完整的代码]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>网络爬虫</tag>
        <tag>Java</tag>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 34 Search for a Range]]></title>
    <url>%2F2018%2F06%2F03%2Fleetcode34%2F</url>
    <content type="text"><![CDATA[用不同的二分查找方式找到最左边和最右边的target Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1: 123&gt; Input: nums = [5,7,7,8,8,10], target = 8&gt; Output: [3,4]&gt; Example 2: 123&gt; Input: nums = [5,7,7,8,8,10], target = 6&gt; Output: [-1,-1]&gt; Python Code 123456789101112131415161718192021222324252627282930313233class Solution: def searchRange(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ if len(nums) == 0: return [-1, -1] l = 0 r = len(nums)-1 # left most while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt;= target: r = mid-1 else: l = mid+1 if l &gt;= len(nums) or nums[l] != target: return [-1, -1] left = l l = 0 r = len(nums)-1 # right most while l &lt;= r: mid = (l+r) // 2 if nums[mid] &gt; target: r = mid-1 else: l = mid+1 right = r return [left, right]]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习实战--Apriori算法挖掘关联规则]]></title>
    <url>%2F2018%2F05%2F29%2FApriori2%2F</url>
    <content type="text"><![CDATA[Apriori算法是最著名的关联规则的挖掘方法，可以使用它挖掘频繁项集发现数据中的规律。著名的“啤酒与尿布”案例就是在分析大量超市的事务之后发现了“啤酒”与“尿布”这一频繁项集。这篇笔记主要是记录Apriori的Python3代码实现的，会就算法来讲解Apriori挖掘频繁项集的步骤，算法的详细内容在《数据挖掘-概念与技术》一书中有非常详细的讲解，这里不再赘述 完整代码在这里 前面文章https://www.ph0en1x.space/2018/05/13/Apriori/介绍了如何利用Apriori算法挖掘频繁项集，这篇文章将继续介绍如何找到关联规则 生成关联规则的入口函数，从先减少一个项集开始，然后交由rulesFromConseq进行递归 123456789101112131415def generateRules(L, supportData, minConf=0.7): ''' L: itemsets supportData: map of the item to the number ''' bigRuleList = [] for i in range(1, len(L)): for freqSet in L[i]: Hl = [frozenset([item]) for item in freqSet] if i &gt; 1: rulesFromConseq(freqSet, Hl, supportData, bigRuleList, minConf) else: calcConf(freqSet, Hl, supportData, bigRuleList, minConf) return bigRuleList ​ 计算置信度是否超过阈值 12345678910def calcConf(freqSet, H, supportData, brl, minConf=0.7): prunedH=[] for conseq in H: conf = supportData[freqSet] / supportData[freqSet-conseq] if conf &gt;= minConf: print (freqSet-conseq, '---&gt;', conseq, 'conf:', conf) brl.append((freqSet-conseq, conseq, conf)) # 剪枝，如果置信度已经低于阈值，就不用继续加了 prunedH.append(conseq) return prunedH ​ 递归增加分子中的item数量 1234567891011def rulesFromConseq(freqSet, H, supportData, brl, minConf=0.7): ''' 递归扫描关联关系 少1个 少2个... ''' m = len(H[0]) if len(freqSet) &gt; (m+1): Hmp1 = aprioriGen(H, m+1) Hmp1 = calcConf(freqSet, Hmp1, supportData, brl, minConf) if len(Hmp1) &gt; 1: rulesFromConseq(freqSet, Hmp1, supportData, brl, minConf) 在main函数中添加关联关系的调用 123456789101112131415if __name__ == "__main__": # dataSet, dataMap = loadDataSet() dataSet = loadDataSet() start = time.time() L, suppData = apriori(dataSet, minSupport=100) end = time.time() cnt = 1 for i in L: print(cnt, i) cnt += 1 print('Apriori total time:', end-start, 's') print("Generate Rule Begin:") # 生成关联关系 generateRules(L, suppData, minConf=0.3) ​]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习实战--Apriori算法挖掘频繁项集]]></title>
    <url>%2F2018%2F05%2F13%2FApriori%2F</url>
    <content type="text"><![CDATA[Apriori算法是最著名的关联规则的挖掘方法，可以使用它挖掘频繁项集发现数据中的规律。著名的“啤酒与尿布”案例就是在分析大量超市的事务之后发现了“啤酒”与“尿布”这一频繁项集。这篇笔记主要是记录Apriori的Python3代码实现的，会就算法来讲解Apriori挖掘频繁项集的步骤，算法的详细内容在《数据挖掘-概念与技术》一书中有非常详细的讲解，这里不再赘述 完整代码在这里 数据格式 类似下方的二维数组，每一个list代表一个transaction，里面的每个数都是item的编号 1[[1,2,5], [2,4], [2,3], [1,2,4],[1,3], [2,3], [1,3], [1,2,3,5], [1,2,3]] 读取数据 12345678def loadDataSet(): thing_arr = [] with open('data/Groceries.txt', 'r') as f: X = f.read() thing_arr = json.loads(X) f.close() return thing_arr ​ 首先生成C1集合，将所有出现过的item编号都加入到C1中 1234567891011121314def createC1(dataSet): ''' 生成C1 :param dataSet: :return: ''' C1 = [] for transaction in dataSet: for item in transaction: if not [item] in C1: C1.append([item]) C1.sort() #将项集列表转换为不可变集和 return [frozenset(item) for item in C1] ​ 扫描数据集计数，去除Ck中的非频繁项集，生成L1 1234567891011121314151617181920212223def scanD(D, Ck, minSupport = 50): ''' 扫描事务集D过滤Ck :param D: :param Ck: :param minSupport: :return: ''' ssCnt = &#123;&#125; for tid in D: for can in Ck: if can.issubset(tid): if can not in ssCnt.keys() : ssCnt[can] = 1 else: ssCnt[can] += 1 retList = [] supportData = &#123;&#125; for key in ssCnt: support = ssCnt[key] if support &gt;= minSupport: retList.insert(0, key) supportData[key] = support return retList, supportData ​ 从Lk-1集中生成Ck集合，需要将Lk-1项集进行排序，然后将前k-2项相同的集合进行合并 123456789101112131415161718def aprioriGen(Lk, k): ''' 生成Ck :param Lk: :param k: :return: ''' retList = [] lenLk = len(Lk) for i in range(lenLk): for j in range(i+1, lenLk): L1 = list(Lk[i])[:k-2] L2 = list(Lk[j])[:k-2] L1.sort() L2.sort() if L1 == L2: retList.append(Lk[i] | Lk[j]) return retList ​ 将上述步骤结合起来，就可以生成所有的频繁项集，直到为空终止算法 12345678910111213def apriori(dataSet, minSupport = 50): C1 = createC1(dataSet=dataSet) D = [set(item) for item in dataSet] L1, supportData = scanD(D, C1, minSupport) L = [L1] k = 2 while(len(L[k-2]) &gt; 0): Ck = aprioriGen(L[k-2], k) Lk, supK = scanD(D, Ck, minSupport) supportData.update(supK) L.append(Lk) k += 1 return L, supportData 到此使用Apriori挖掘频繁项集就编写完了，后面还有关联规则的挖掘，未完。。 ​]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习实战--FP-growth算法挖掘频繁项集]]></title>
    <url>%2F2018%2F05%2F13%2FFPgrowth%2F</url>
    <content type="text"><![CDATA[FP-growth是频繁项集挖掘的一种优化算法。它先将事务先构造成一棵FP树，这样一来就不用像Apriori一项反复地扫描原来的事务了，大大提高了效率。这篇笔记主要是记录FP-growth的Python3代码实现的，会就算法来讲解FP-growth挖掘频繁项集的步骤，算法的详细内容在《数据挖掘-概念与技术》一书中有非常详细的讲解，这里不再赘述 完整代码在这里 数据格式 类似下方的二维数组，每一个list代表一个transaction，里面的每个数都是item的编号 1[[1,2,5], [2,4], [2,3], [1,2,4],[1,3], [2,3], [1,3], [1,2,3,5], [1,2,3]] 读取数据 12345678def loadDataSet(): thing_arr = [] with open('data/Groceries.txt', 'r') as f: X = f.read() thing_arr = json.loads(X) f.close() return thing_arr ​ FP-Growth实现起来相对复杂，需要定义树结点结构 1234567891011121314151617181920class treeNode: def __init__(self, nameValue, numOccur, parentNode): # 值 self.name = nameValue # 计数 self.count = numOccur # 下一个相同值的结点 self.nodeLink = None # 父节点 self.parent = parentNode # 孩子结点 self.children = &#123;&#125; def inc(self, numOccur): self.count += numOccur def disp(self, ind=1): print(" "*ind, self.name, ' ', self.count) for child in self.children.values(): child.disp(ind+1) ​ 初始化transaction计数 12345def createInitSet(dataSet): retDict = &#123;&#125; for trans in dataSet: retDict[frozenset(trans)] = 1 return retDict ​ 建立FP树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879def createTree(dataSet, minSup = 1): ''' 创建根结点以及搜索链表表头 :param dataSet: :param minSup: :return: ''' # 搜索链表头 headerTable = &#123;&#125; # 在搜索用的链表头除记录每个item的频数 for trans in dataSet: for item in trans: headerTable[item] = headerTable.get(item, 0) + dataSet[trans] # 小于最小支持度的item不用考虑 for k in list(headerTable.keys()): if headerTable[k] &lt; minSup: del(headerTable[k]) freqItemSet = set(headerTable.keys()) # 如果不存在频繁项集则直接返回空 if len(freqItemSet) == 0: return None, None # 为每个结点增加一个指向下一个同值结点的指针 for k in headerTable.keys(): headerTable[k] = [headerTable[k], None] # 树根 retTree = treeNode('Null Set', 1, None) for tranSet, count in dataSet.items(): localD = &#123;&#125; for item in tranSet: if item in freqItemSet: localD[item] = headerTable[item][0] if len(localD) &gt; 0: # 每个transaction中的item按出现的次数从高到低排 orderedItems = [v[0] for v in sorted(localD.items(), key=lambda p: p[1], reverse=True)] # 建树 updateTree(orderedItems, retTree, headerTable, count) return retTree, headerTabledef updateTree(items, inTree, headerTable, count): ''' 每个transaction递归更新到树上，并更新搜索链表 :param items: :param inTree: :param headerTable: :param count: 每个transaction的出现次数 :return: ''' # 每个transaction的最高出现词数item直接接在root上 if items[0] in inTree.children: # 有该元素项时计数值+1 inTree.children[items[0]].inc(count) else: # 没有这个元素项时创建一个新节点 inTree.children[items[0]] = treeNode(items[0], count, inTree) # 更新头指针表或前一个相似元素项节点的指针指向新节点 if headerTable[items[0]][1] == None: headerTable[items[0]][1] = inTree.children[items[0]] else: updateHeader(headerTable[items[0]][1], inTree.children[items[0]]) # 递归建树 if len(items) &gt; 1: # 对剩下的元素项迭代调用updateTree函数 updateTree(items[1:], inTree.children[items[0]], headerTable, count) def updateHeader(nodeToTest, targetNode): ''' 找到链表尾加上一个 :param nodeToTest: :param targetNode: :return: ''' while (nodeToTest.nodeLink != None): nodeToTest = nodeToTest.nodeLink nodeToTest.nodeLink = targetNode ​ 在每次查询条件FP树时，需要递归寻找其条件前缀路径 12345678910111213141516171819202122def ascendTree(leafNode, prefixPath): ''' 递归寻找父节点 :param leafNode: :param prefixPath: :return: ''' if leafNode.parent != None: prefixPath.append(leafNode.name) ascendTree(leafNode.parent, prefixPath)def findPrefixPath(basePat, treeNode): condPats = &#123;&#125; while treeNode != None: prefixPath = [] # 获得某个叶子节点的前缀路径 ascendTree(treeNode, prefixPath) if len(prefixPath) &gt;= 2: # 去掉自己获得前缀路径，且权重为当前结点的权重，用于建立条件前缀树 condPats[frozenset(prefixPath[1:])] = treeNode.count treeNode = treeNode.nodeLink return condPats 进行频繁项挖掘 12345678910111213141516171819202122def mineTree(inTree, headerTable, minSup, preFix, freqItemList): ''' 递归查找频繁项集 :param inTree: FP树 :param headerTable: :param minSup: :param preFix: 当前前缀 :param freqItemList: 存储频繁项集 :return: ''' # 从出现次数少的开始找 bigL = [v[0] for v in sorted(headerTable.items(), key=lambda p: p[1][0])] for basePat in bigL: newFreqSet = preFix.copy() newFreqSet.add(basePat) freqItemList.append(newFreqSet) condPattBases = findPrefixPath(basePat, headerTable[basePat][1]) CondTree, Header = createTree(condPattBases, minSup) if Header != None: mineTree(CondTree, Header, minSup, newFreqSet, freqItemList) ​]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu自己创建桌面快捷方式]]></title>
    <url>%2F2018%2F04%2F25%2Fubuntu_shortcut%2F</url>
    <content type="text"><![CDATA[本篇文章将会介绍如何在Ubuntu下创建自己的快捷方式 操作步聚： 新建空白文档 写入 1234567[Desktop Entry]Name = Studiocomment= android studioExec=可执行文件位置Icon=图标位置Terminal=falseType=Application 更改文件名为xxx.desktop 右键属性—权限—允许作为程序执行文件 创建完成]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下安装Matlab 2018a]]></title>
    <url>%2F2018%2F04%2F23%2Fubuntu_matlab%2F</url>
    <content type="text"><![CDATA[在Ubuntu在安装Matlab用于学习、研究用途。Linux上可以使用开源免费的Octave代替 下载Matlab 2018a 安装包 matlab是收费软件，所以这篇笔记没有提供下载和破解资源，各位想把Matlab用做学习研究用途的童鞋可以到各大PT站取下载 ​ 进入安装包内，和Windows安装一样，里面会有三个文件，分别是破解用的证书文件，光盘镜像1，光盘镜像2 ​ 创建挂载点~/matlab挂载映像文件1 123$ cd ~$ mkdir matlab $ sudo mount -t auto -o loop YOUR_DOWNLOAD_DIR/R2018a_glnxa64_dvd1.iso ~/matlab/ ​ 挂载之后，进入根目录开始安装(注意不能直接在挂载目录下启动install) 12$ cd /$ sudo ./home/phoenix/matlab/install ​ 安装中提示输入key的可以到破解文件Crack中的readme.txt中找 按照提示进行安装，安装到一半时会提示插入光盘2，这时候就要挂载映像文件2 1$ sudo mount -t auto -o loop YOUR_DOWNLOAD_DIR/R2018a_glnxa64_dvd2.iso ~/matlab/ ​ 安装好后第一次启动 12$ cd /usr/local/MATLAB/R2018a/bin$ sudo ./matlab ​ 选择不要联网激活，导入Crack中的license_standalone.lic文件 ​ 复制文件 1sudo cp -f YOUR_DOWNLOAD_DIR/Matlab2018aLinux64Crack/R2018a/bin/glnxa64/matlab_startup_plugins/lmgrimpl/libmwlmgrimpl.so /usr/local/MATLAB/R2018a/bin/glnxa64/matlab_startup_plugins/lmgrimpl 再次启动 1$ sudo ./matlab]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下编译安装VLfeat]]></title>
    <url>%2F2018%2F04%2F23%2Fubuntu_vlfeat%2F</url>
    <content type="text"><![CDATA[The VLFeat open source library implements popular computer vision algorithms specializing in image understanding and local features extraction and matching. Algorithms include Fisher Vector, VLAD, SIFT, MSER, k-means, hierarchical k-means, agglomerative information bottleneck, SLIC superpixels, quick shift superpixels, large scale SVM training, and many others. It is written in C for efficiency and compatibility, with interfaces in MATLAB for ease of use, and detailed documentation throughout. It supports Windows, Mac OS X, and Linux. 下载源码 解压进入vlfeat的根目录vlfeat_ROOT 修改Makefile 解除注释或添加一行 1DISABLE_OPENMP=yes ​ 打开/etc/ld.so.conf添加一行 1vlfeat_ROOT/toolbox/mex/mexa64 ​ 刷新环境配置 1sudo ldconfig ​ 再次进入vlfeat_ROOT，输入命令 1make MEX=matlab_ROOT/bin/mex ​ 编译成功后进入matlab命令行输入 1run('vlfeat_ROOT/toolbox/vl_setup.m') 运行成功后查看版本，正常显示后完成安装 1vl_version ​ 在matlab起始位置下(我的是HOME目录下)添加一个startup.m文件写上 1run('vlfeat_ROOT/toolbox/vl_setup.m') 就可以每次启动时自动加载vlfeat ​]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>matlab</tag>
        <tag>VLfeat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[马氏距离(Mahalanobis Distance)]]></title>
    <url>%2F2018%2F04%2F18%2FMahalanobis%2F</url>
    <content type="text"><![CDATA[马氏距离(Mahalanobis Distance)是度量学习中一种常用的距离指标，同欧氏距离、曼哈顿距离、汉明距离等一样被用作评定数据之间的相似度指标。但却可以应对高维线性分布的数据中各维度间非独立同分布的问题。 什么是马氏距离马氏距离(Mahalanobis Distance)是一种距离的度量，可以看作是欧氏距离的一种修正，修正了欧式距离中各个维度尺度不一致且相关的问题。 单个数据点的马氏距离 数据点x, y之间的马氏距离 其中Σ是多维随机变量的协方差矩阵，μ为样本均值，如果协方差矩阵是单位向量，也就是各维度独立同分布，马氏距离就变成了欧氏距离。 马氏距离实际意义那么马氏距离就能能干什么？它比欧氏距离好在哪里？举几个栗子 欧式距离近就一定相似？ 先举个比较常用的例子，身高和体重，这两个变量拥有不同的单位标准，也就是有不同的scale。比如身高用毫米计算，而体重用千克计算，显然差10mm的身高与差10kg的体重是完全不同的。但在普通的欧氏距离中，这将会算作相同的差距。 归一化后欧氏距离近就一定相似？ 当然我们可以先做归一化来消除这种维度间scale不同的问题，但是样本分布也会影响分类 举个一维的栗子，现在有两个类别，统一单位，第一个类别均值为0，方差为0.1，第二个类别均值为5，方差为5。那么一个值为2的点属于第一类的概率大还是第二类的概率大？距离上说应该是第一类，但是直觉上显然是第二类，因为第一类不太可能到达2这个位置。 所以，在一个方差较小的维度下很小的差别就有可能成为离群点。就像下图一样，A与B相对于原点的距离是相同的。但是由于样本总体沿着横轴分布，所以B点更有可能是这个样本中的点，而A则更有可能是离群点。 算上维度的方差就够了？ 还有一个问题——如果维度间不独立同分布，样本点一定与欧氏距离近的样本点同类的概率更大吗？ 可以看到样本基本服从f(x) = x的线性分布，A与B相对于原点的距离依旧相等，显然A更像是一个离群点 即使数据已经经过了标准化，也不会改变AB与原点间距离大小的相互关系。所以要本质上解决这个问题，就要针对主成分分析中的主成分来进行标准化。 马氏距离的几何意义上面搞懂了，马氏距离就好理解了，只需要将变量按照主成分进行旋转，让维度间相互独立，然后进行标准化，让维度同分布就OK了 由主成分分析可知，由于主成分就是特征向量方向，每个方向的方差就是对应的特征值，所以只需要按照特征向量旋转，然后缩放特征向量倍就可以了，可以得到以下的结果： 离群点就被成功分离，这时候的欧式距离就是马氏距离。 马氏距离的推导首先要对数据点进行旋转，旋转至主成分，维度间线性无关，假设新的坐标为 又变换后维度间线性无关且每个维度自己的方差为特征值，所以满足： 马氏距离是旋转变换缩放之后的欧式距离，所以马氏距离的计算公式为： 这就是之前提到的马氏距离的公式 马氏距离的问题 协方差矩阵必须满秩 里面有求逆矩阵的过程，不满秩不行，要求数据要有原维度个特征值，如果没有可以考虑先进行PCA，这种情况下PCA不会损失信息 不能处理非线性流形(manifold)上的问题 只对线性空间有效，如果要处理流形，只能在局部定义，可以用来建立KNN图]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[word2vec词嵌入方法]]></title>
    <url>%2F2018%2F04%2F10%2Fword2vec%2F</url>
    <content type="text"><![CDATA[word2vec模型与应用由Mikolov等人在自然语言领域具有很高的影响，它在语言模型进行学习前先找寻到一种合适的编码方式，这种编码方式叫作词嵌入(Word Embedding); 本片笔记属于原理介绍，没有实现细节的代码讲解 One-hot编码嵌入前通常会使用 one-hot编码方式，这种编码方式每个词都会单独的占一位，该位为1则表示这个词出现，例如但前语料中一共有5个词，那么它们就分别表示为10000，01000，00100，00010，00001。 显然，这是一种极不高效的编码方式，既需要极大的空间用于存储，也不能从词向量中获得有用的词之间的语义关系，这也就是为什么需要词嵌入技术的原因。 Why word2vec?为什么Word2Vec方法受到如此多的注意，以至于对现在的自然语言处理产生了极大的影响？ 总结了一下Word2Vec的几个特点： 快，以往的词嵌入得到的词向量仅仅只是一个副产物，而w2v则针对词嵌入提出了各种模型以及相应的优化算法(后面会提到的) 语义上相近的词向量相似度上也比较接近 这点是最神奇的，虽然不知道为什么，w2v得到的词向量竟然满足语义上的加减法！！！比如Madrid-Spain+France=Paris; king-man+women=queen; (⊙ω⊙)! 此外w2v还拥有两种模式Skip-gram与CBOW，而每种模式下都有两种优化的实现方法Hierarchical Softmax, Negative Sampling Skip-gram第一种模式是Skip-gram模式，根据一个词推测出其最有可能的上下文(Context)，其结构图如下： 步骤 输入One-hot编码，每个词向量现在都是V维的，V就是语料中词汇的总数 乘上字典矩阵WV*N，变成一个N维向量。N就是嵌入后的词向量维数 乘上字典矩阵W’N*V，相当于求距离，然后再求一个Softmax，变成一个V维向量。每一位其实都代表改为one-hot编码的词出现的概率 CBOWCBOW(Continuous Bag-of-Words)，是另外一种Word2Vec的模式，用于根据上下文推测出空缺的词的方法，其结构示意图如下： 步骤 输入上下文C个词的One-hot编码 乘上字典矩阵WV*N，得到各自的N维编码 取它们的平均值 乘上字典矩阵W’N*V，相当于求与其他词之间的距离，然后取Softmax，变成一个V维向量，每位代表的还是这个位上one-hot编码的那个词的概率，选最大的那个 ​ Hierarchical Sotfmax上面说的就是Word2Vec的基本思想了，但是呢，当语料非常庞大的时候，求Softmax 开销就会变得异常的大，其中一种解决方法就是使用层次Softmax(Hierarchical Sotfmax)来将Softmax的概率转化为一个多次二分类问题。 层级Softmax函数使用的数据结构是以词频作为权重构造的霍夫曼树(Huffman Tree)，这样做的好处是词频大的词只需要更少的遍历就可以找到 叶子节点为V个语料中的词，而非叶子节点也有一个向量v，代表一次选择，即每走一步都需要确定下一步是要走到左孩子节点还是右孩子节点，原来的Softmax概率就被写成 σ(*)是Sigmoid函数，双竖线中括号表示若选择左孩子则为1，右孩子则为-1，在sigmoid中正好正负样例两者 相加等1。最后就是非叶子节点向量与词向量的内积。训练时同时考虑词的嵌入向量训练和霍夫曼树上非叶子节点的参数。 与CBOW配合，将叠加以后的嵌入向量作为霍夫曼树的输入，去寻找原中心词，并以此过程优化霍夫曼树与词向量; 与Skip-Gram配合，将目标词汇一个个作为霍夫曼树的输入 ，去寻找原中心词，并以此过程优化霍夫曼树与词向量; Negative Sampling在此前的LargeVis–LINE在高维数据降维与可视化上的运用中已经提到了Negative Sampling，实际上，在Word2Vec后，负采样技术在运用上比层级Softmax更加的广泛。 做法也与LargeVis相似，即使得正样本出现的概率最大，负样本出现的概率减小，那么如何取负样本呢？ 将所有的词按照词频的3/4次方为正比进行采样作为负样本，即满足概率： 按照这个概率取得负样本(若取到中心词本身则重新进行采样)用于替换中心词，与原中心词的Context组成一组负样本，只要取几个词就可已完成负采样。按照原文的话说，当数据集比较小的时候，5-20个负样本; 当数据集比较大的时候，只需要2-5个就可以了。 负采样的目标函数为： 高频词子采样语料中总是有很多类似于”a” “the” “in”这样的词，这些词被认为不会提供太多有用的信息，因为它们几乎会出现在所有的词的context中。所以对于这些词我们进行子采样(Subsampling)来进行过滤。Mikolov的原文中采用的下采样公式是 P是每个词被删除的概率，t是一个认为定的阈值，大约在10-5左右，f是词频。这样一来，稀有的词就能得到保留，而频繁出现的词却会被大面积的删除，但总体词频的顺序不变，达成下采样的目的。 Tensorflow实现负采样Skip-gram word2vec Tensorflow封装实现 作者源码 参考Distributed Representations of Words and Phrases and their Compositionality word2vec Parameter Learning Explained Word2Vec中的数学原理 Word2Vec原理 深度学习word2vec笔记之算法篇]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu下安装gsl科学计算库]]></title>
    <url>%2F2018%2F04%2F03%2Fubuntu_gsl%2F</url>
    <content type="text"><![CDATA[GSL是GNU的科学计算库(GNU Scientific Library)，是用于C++的开源科学计算库 下载最新版本GSL http://www.gnu.org/software/gsl/ 解压后进入目录下，然后执行命令 123./configuremakemake install ​ 将会自动将lib与头文件安装到/usr/local/lib和/usr/local/include 下面，过程中可能会出现权限上的问题，sudo就行。之后就可以使用GSL了;]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>GSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[训练集(train set)验证集(validation set)测试集(test set)与交叉验证法(Cross Validation)]]></title>
    <url>%2F2018%2F04%2F01%2Fcross_validation%2F</url>
    <content type="text"><![CDATA[这三种数据集合非常容易弄混，特别是验证集和测试集，这篇笔记写下我对它们三个的理解以及在实践中是如何进行划分的。 训练集这个是最好理解的，用来训练模型内参数的数据集，Classfier直接根据训练集来调整自身获得更好的分类效果 验证集​ 用于在训练过程中检验模型的状态，收敛情况。验证集通常用于调整超参数，根据几组模型验证集上的表现决定哪组超参数拥有最好的性能。 ​ 同时验证集在训练过程中还可以用来监控模型是否发生过拟合，一般来说验证集表现稳定后，若继续训练，训练集表现还会继续上升，但是验证集会出现不升反降的情况，这样一般就发生了过拟合。所以验证集也用来判断何时停止训练 测试集测试集用来评价模型泛化能力，即之前模型使用验证集确定了超参数，使用训练集调整了参数，最后使用一个从没有见过的数据集来判断这个模型是否Work。 三者区别形象上来说训练集就像是学生的课本，学生 根据课本里的内容来掌握知识，验证集就像是作业，通过作业可以知道 不同学生学习情况、进步的速度快慢，而最终的测试集就像是考试，考的题是平常都没有见过，考察学生举一反三的能力。 为什么要测试集训练集直接参与了模型调慘的过程，显然不能用来反映模型真实的能力，这样一些 对课本死记硬背的学生(过拟合)将会拥有最好的成绩，显然不对。同理，由于验证集参与了人工调参(超参数)的过程，也不能用来最终评判一个模型，就像刷题库的学生也不能算是学习好的学生是吧。所以要通过最终的考试(测试集)来考察一个学(模)生(型)真正的能力。 但是仅凭一次考试就对模型的好坏进行评判显然是不合理的，所以接下来就要介绍交叉验证法 交叉验证法交叉验证法的作用就是尝试利用不同的训练集/测试集划分来对模型做多组不同的训练/测试，来应对单词测试结果过于片面以及训练数据不足的问题。 交叉验证的做法就是将数据集粗略地分为比较均等不相交的k份，即 然后取其中的一份进行测试，另外的k-1份进行训练，然后求得error的平均值作为最终的评价，具体算法流程西瓜书中的插图如下：]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu下一些常用软件安装]]></title>
    <url>%2F2018%2F03%2F28%2Fubuntu_env%2F</url>
    <content type="text"><![CDATA[安装完Ubuntu后常用软件和环境的安装，之前写过一点，在这里做补充，Chrome，Typora，Anaconda，调节双系统时间，Sublime，nodejs等 1. Chrome1234567sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -sudo apt-get updatesudo apt-get install google-chrome-stable 2. Typora123456789# optional, but recommendedsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE# add Typora's repositorysudo add-apt-repository 'deb https://typora.io ./linux/'sudo apt-get update# install typorasudo apt-get install typora 3. Anaconda到官网下载最新anaconda的安装包 下载后运行 1bash Anaconda... 按照提示一步步确定安装位置 4. 调节双系统时间12timedatectl set-local-rtc 1 --adjust-system-clocktimedatectl set-ntp 0 5. Sublime123sudo add-apt-repository ppa:webupd8team/sublime-text-3sudo apt-get updatesudo apt-get install sublime-text-installer 6. nodejs123sudo apt-get install nodejssudo apt install nodejs-legacysudo apt install npm 7. Mysql123sudo apt install mysql-serversudo apt install mysql-clientmysql -u root -p 8. 其他https://www.ph0en1x.space/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LargeVis--LINE在高维数据降维与可视化上的运用]]></title>
    <url>%2F2018%2F03%2F23%2Flargevis%2F</url>
    <content type="text"><![CDATA[LargeVis是唐建在2016年提出的高维数据降维可视化算法，主要工作是大大降低了t-SNE算法的计算复杂度，使算法能够更高的效率处理更大规模的数据。主要使用的优化方法是改进的随机投影树KNN图构造方法以及、与Word2Vec类似的采样与负采样方法以及随机梯度下降算法；在距离的映射方面仍然采用了与t-SNE一样的高斯分布——T分布的策略 高效KNN图构造方法 构造精确的KNN图在计算复杂度上是非常高的，需要计算两两点之间的距离，这需要O(N2d)的复杂度。在t-SNE的后续工作中已经意识到了这个问题，于是Maaten提出了各种随机投影树的算法，详细的算法将在其他的笔记中详细的记录，大致上就是对空间上进行划分直到同一区间内的点少于一个阈值，最后被分在同一块区域中的数据点就被认为是NN。这样来确定近邻效率高了不少，但是为了保证KNN图的精确率，仍然需要创建许多的投影树，这样还是十分影响效率。于是LargeVis中运用了一种叫邻居搜索的方法，主要思想就是“邻居的邻居也是我的邻居”。 首先创建少量的随机投影树先粗略估计KNN，为每个节点维护一个最大堆，然后搜索图每个节点邻居的邻居，这些节点也有可能成为最近邻的候选，与原节点的最大堆比较，若比它小则push若是堆内的节点数超过K，就pop。我们可以多迭代几次来提升图的精确度，实践中只要少量的迭代就可以让精确度接近100%。下图展示了LargeVis构建KNN图的算法流程： ​ ​ 图可视化 在定义好KNN图后，LargeVis同样也需要像t-SNE那样的从高维到低维的映射。 LargeVis在映射的过程中仅保留了KNN边的权重，这些边被称作是正边，而不直接相邻的节点之间称作为负边。正边的边权同t-SNE中定义相同，使用高斯分布进行映射： 而在低维，则依靠观测的概率来决定低维的坐标： 其中f(.)是距离函数，可以使用t分布等距离越小数值越大的函数来做映射，就是高维当中越接近的点，低维当中也要更加的接近。所以最终的优化目标函数： 其中两个E是正边集与负边集。 优化 ​ 直接按照上述目标函数进行优化开销是很大的，因为负边的数量是非常大的，直接对所有负边进行训练又要造成复杂度的上升。所以这里就要采用负采样算法进行优化。 负采样算法根据对应节点的度来决定被采样到的概率，即度越大的节点被当作负边的另一个节点的概率越大，概率满足噪声分布 这样一来，目标函数就变成了： ​ 这样一来，目标函数就得到确定，但是，如果直接使用边的权重进行训练，权重直接乘到梯度中，不同边的权重不同，会对梯度造成很大的影响，权重较大的边受到的变动步长也较大，会影响训练过程。所以这里要用到LINE技术，将带权边看作wij条单位边，这样一来就可以直接对所有的正边进行采样，对目标函数也没有改变 ​ 此外就是异步随机梯度下降算法，因为构建的KNN图非常的稀疏，同时对几个点进行梯度下降，一般不会重叠产生冲突，这样就能大大提高训练效率 结果 LargeVis的结果还是很接近tsne的，而且处理速度能快不少(没有用官方给的MNIST数据集，所以和他们给的结果不大一样)。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot项目中Tomcat端口号的更改]]></title>
    <url>%2F2018%2F03%2F20%2Fspring_boot_tomcat_port%2F</url>
    <content type="text"><![CDATA[使用IntelliJ Idea开发Spring Boot项目时，Idea会使用内置的Tomcat服务器，默认情况下使用的端口号的8080，本篇笔记记录如何修改内置Tomcat服务器使用的端口号 在run选项下或者工具栏运行中选择Edit Configurations 在打开的界面中的Override parameters选项下加入如下的选项，假设要把端口号改成8888 如果是在Eclipse下配置，则可以加入一条-Dserver.port=8888]]></content>
      <categories>
        <category>JetBrains</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Java</tag>
        <tag>JetBrains</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA快速搭建Spring Boot应用]]></title>
    <url>%2F2018%2F03%2F18%2Fspring_boot%2F</url>
    <content type="text"><![CDATA[使用IntelliJ Idea创建Spring Boot项目并运行简单实例 新建项目File -&gt; New -&gt; Project 选择Maven项目(这篇笔记里不选Spring)，然后一路Next 在pom.xml里添加如下内容后，等待maven import的完成 1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 版本可以根据Spring Boot主页里的引导来进行选择 在/src/main/java下新建Java Class，命名为MainController.java，写入如下内容 1234567891011121314151617181920import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@Controller@EnableAutoConfigurationpublic class MainController &#123; @RequestMapping("/") @ResponseBody String home(String input) &#123; System.out.println(input); return input.toUpperCase(); &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(MainController.class, args); &#125;&#125; 这段代码执行后，将会监听url后的/根目录，接到input变量然后转成大写字母进行返回 写好后运行MainControllerSpring Boot就可以启动了 打开浏览器，输入localhost:8080/?input=abc，(默认情况下Idea内置的端口占用的是8080端口，由于我别的程序需要使用，所以我改成了8888端口，后面也会有笔记说明如何更改) 上面使用了GET请求将参数input=abc发送给服务器，返回了字符串ABC 这只是最简单的Spring Boot应用的配置，去掉@ResponseBodyannotation，Spring Boot还可以直接返回一个html页面，具体的其他内容后面会有笔记。 这里有一个我使用Spring-Boot搭建的文档搜索引擎，使用Solr作为搜索内核，支持各种md、pdf、txt、xml文档的爬取。]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JetBrains</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[t-SNE高维数据降维与可视化]]></title>
    <url>%2F2018%2F03%2F15%2Ftsne%2F</url>
    <content type="text"><![CDATA[t-SNE(基于t分布的随机近邻嵌入，t-distributed stochastic neighbor embedding)，是Laurens van der Maaten大神在Geffory Hinton大神的SNE基础上加入t分布而形成的，是目前效果最好的可视化降维算法，可以将高维数据内部的特征放大，使得相似的数据在低维中能更加接近，不相似的数据在低维中距离更远。 一、SNE​ SNE由Hinton大神在2003年提出，它提出的目的就是为了改进MDS与ISOPMAP寻求距离完全按照原有维度内的问题，转而满足高低维之间满足分布上的统一。虽然这样会导致距离信息有了一定程度的丢失，但是这么做保留了距离的分布，获得更好的可视化效果。 ​ SNE需要通过训练使得高维与低维的距离的高斯分布尽量的接近，即： ​ 满足高维的点在p中的值与低维的q中的值能够尽量接近，cost函数采用KL散度： ​ 采用动量优化的方式进行训练 二、Symmetric SNE​ 传统的SNE的分布映射方法不具有对称性，即pi|j与pj|i不相等，所以可以将映射方式改成联合概率分布的方式： ​ 但是高维中的离群点的cost就会很低，因为它离所有点的距离都非常的远，p非常小，所以，可以把p改写成 ​ 这样cost的值就改写为： 三、t-SNE​ 之前所说的各种算法中，都会产生拥挤问题，所谓拥挤问题就是高维数据中的距离关系不能完整地在低维空间中得以保留，10维中可以有11个点相互等距，而二维空间中最多就只能有3个点组成等边三角形，这样的降维肯定不能够保证距离的保留。同时可以参考这篇博客中的实验，同样是均匀分布会发现高维空间中均匀分布的点中距离分布也是很不均匀的，随着维度的增大，距离越远的点的比重会越来越大。 所以，如果不设法减轻这种拥挤问题，那么就会出现高维空间中距离较远与较近的点，在低维中的距离相同的问题，使得类与类之间分不开。为解决拥挤问，T分布就能够一展神通。 T分布具有长尾的特性，即碰到有离群点时，不会因为离群点使整个分布脱离原有的大部分数据，同时，低维数据使用T分布映射而高维数据使用正态分布作为映射，如下图： 在高维空间中较近的点在低维空间中将会更近，而较远的点将会更远，这样就能有效缓解拥挤问题，tsne的公式为 tsne结果： tsne代码 参考 Maaten L, Hinton G. Visualizing data using t-SNE[J]. Journal of machine learning research, 2008, 9(Nov): 2579-2605. Hinton G E, Roweis S T. Stochastic neighbor embedding[C]//Advances in neural information processing systems. 2003: 857-864.]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
        <tag>Visualization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等度量映射(ISOMAP)]]></title>
    <url>%2F2018%2F03%2F11%2FIsomap%2F</url>
    <content type="text"><![CDATA[等度量映射(Isomap)是最经典的非线性映射降维方法之一，它在MDS的基础上引入了“测地距离”的概念，直接解决了MDS使用欧氏距离无法应对非线性流形的问题。 测地距离(Geometric Distance)是高维流形中两点之间的最短距离，高维流形中，空间是不规则的，所以最短距离不一定是直线距离(欧氏距离)。就像蚂蚁从立方体的一面爬到另一面，不能直接横穿立方体一样。 上图最左边的图中两个点的最近距离应该是蓝色实线的距离，而不应该是虚线的距离。 真实的测地距离是非常难以求出的，Isomap基于流形局部近似于欧式空间的定义提出了一种近似的求解方式 求得原样本的KNN图，并依据定义保留其欧式距离 所有非KNN的点间的距离规定为无穷大 用dijkstra或floyd求出任意两点的最短路便可近似表示两点间的测地距离 最后Isomap将得到的测地距离矩阵输入MDS完成降维; 感受下效果]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多维缩放(MDS)]]></title>
    <url>%2F2018%2F03%2F11%2FMDS%2F</url>
    <content type="text"><![CDATA[多维缩放(multidimensional scaling ,MDS)，是另外一种线性降维方式，与主成分分析法和线性降维分析法都不同的是，多维缩放的目标不是保留数据的最大可分性，而是更加关注与高维数据内部的特征。多维缩放算法集中于保留高维空间中的“相似度”信息，而在一般的问题解决的过程中，这个“相似度”通常用欧式距离来定义。 假设D为m个样本在高维空间中的距离矩阵，distij为第i个样本与第j个样本的欧式距离 Z是样本在低维中映射的表示，那么，多维缩放的降维目标就是要保证： 令B=ZTZ，B为降维后样本的内积矩阵，bij=ziTzj 规定降维后的样本为中心化样本，因为只保留了距离信息，无论结果怎么旋转、平移都可以，即 那么 令 综合以上各式，得到 所以可以使用距离矩阵D来求得内积矩阵B， 为了完成降维，可以将B进行特征值分解 仅保留最大的前d’个特征值以及相应的特征向量，就可以得出降维后的结果]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetbrain IDE插件开发入门]]></title>
    <url>%2F2018%2F03%2F10%2Fjetbrain_plugin%2F</url>
    <content type="text"><![CDATA[Jetbrain号称IDE界的Adobe，各个平台、各个环境下的IDE无论从易用性还是外观上都是十分优秀的，这份笔记将会记录如何在JetBrains中编写简单的插件。 一、创建项目 安装JetBrains IDEA 新建项目，选择IntelliJ Platform Plugin，这里我们选择开发IDEA的插件，所以Project SDK选择IDEA的安装目录 二、实现 创建好项目后，打开resources目录下的plugins.xml，在这里我们要注册我们的插件 加一条&lt;depends&gt;com.intellij.modules.platform&lt;/depends&gt;，后面打包的时候需要 在&lt;actions&gt;中注册自己的插件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;idea-plugin&gt; &lt;id&gt;com.ph0en1x.Registration&lt;/id&gt; &lt;name&gt;Jetbrain Plugin&lt;/name&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;vendor email="support@yourcompany.com" url="https://www.ph0en1x.space"&gt;Ph0en1x Notebook&lt;/vendor&gt; &lt;description&gt;&lt;![CDATA[ Jetbrain Plugin Demo ]]&gt;&lt;/description&gt; &lt;change-notes&gt;&lt;![CDATA[ Add change notes here.&lt;br&gt; &lt;em&gt;most HTML tags may be used&lt;/em&gt; ]]&gt; &lt;/change-notes&gt; &lt;!-- please see http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/build_number_ranges.html for description --&gt; &lt;idea-version since-build="173.0"/&gt; &lt;!-- please see http://www.jetbrains.org/intellij/sdk/docs/basics/getting_started/plugin_compatibility.html on how to target different products --&gt; &lt;!-- uncomment to enable plugin in all products &lt;depends&gt;com.intellij.modules.lang&lt;/depends&gt; --&gt; &lt;depends&gt;com.intellij.modules.platform&lt;/depends&gt; &lt;!--&lt;application-components&gt;--&gt; &lt;!--&lt;component&gt;--&gt; &lt;!--&lt;implementation-class&gt;com.ph0en1x.Registration&lt;/implementation-class&gt;--&gt; &lt;!--&lt;/component&gt;--&gt; &lt;!--&lt;/application-components&gt;--&gt; &lt;extensions defaultExtensionNs="com.intellij"&gt; &lt;!-- Add your extensions here --&gt; &lt;/extensions&gt; &lt;actions&gt; &lt;!-- Add your actions here --&gt; &lt;group id="HelloWorld" text="Ph0en1x Menu"&gt; &lt;add-to-group group-id="MainMenu" anchor="last" /&gt; &lt;/group&gt; &lt;action class="com.ph0en1x.MenuAction" id="menuAction1" text="显示对话框"&gt; &lt;add-to-group group-id="HelloWorld" anchor="first" /&gt; &lt;/action&gt; &lt;action class="com.ph0en1x.MenuAction2" id="menuAction2" text="在Help里" description="A simple IDEA plugin."&gt; &lt;add-to-group group-id="HelpMenu" anchor="last"/&gt; &lt;/action&gt; &lt;/actions&gt;&lt;/idea-plugin&gt; 我这里注册了两个插件，第一个插件在一个新建的选项&lt;group&gt;下面，新建选项显示的文字是显示对话框 class：插件入口类 id：唯一标识插件 text：选项显示的文字 description：状态栏显示的文字 icon：显示的图标（这里我没加） add-to-group：表示要添加到哪个选项下面 anchor：插入选项的位置 实现Action 在src目录下创建与之前定义的相应的入口类，入口类要继承于com.intellij.openapi.actionSystem.AnAction com.ph0en1x.MenuAction 实现点击后显示一个对话框 123456789101112package com.ph0en1x;import com.intellij.openapi.actionSystem.AnAction;import com.intellij.openapi.actionSystem.AnActionEvent;import com.intellij.openapi.ui.Messages;public class MenuAction extends AnAction&#123; @Override public void actionPerformed(AnActionEvent anActionEvent) &#123; Messages.showInfoMessage("Show some message", "This is title"); &#125;&#125; com.ph0en1x.MenuAction2实现点击后显示一个对话框询问姓名，输入姓名后弹出欢迎界面 123456789101112131415package com.ph0en1x;import com.intellij.openapi.actionSystem.AnAction;import com.intellij.openapi.actionSystem.AnActionEvent;import com.intellij.openapi.project.Project;import com.intellij.openapi.ui.Messages;public class MenuAction2 extends AnAction&#123; @Override public void actionPerformed(AnActionEvent anActionEvent) &#123; Project project = anActionEvent.getProject(); String name = Messages.showInputDialog(project, "What's your name?", "This is title", Messages.getQuestionIcon()); Messages.showMessageDialog(project, "Hello " + name + "!", "This is title", Messages.getInformationIcon()); &#125;&#125; ​ 完成后点击run，会打开一个新的IDEA，打开一个项目后，新的IDEA里就会有我们刚刚编写的插件]]></content>
      <categories>
        <category>JetBrains</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Java</tag>
        <tag>JetBrains</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下通过docker运行eclipse che]]></title>
    <url>%2F2018%2F03%2F09%2Feclipse_che%2F</url>
    <content type="text"><![CDATA[Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署。个人理解：通过沙箱隔离出一块区域，每块区域都有不同的应用运行环境。类似虚拟机是为了操作系统提供模拟的硬件环境，docker容器给应用提供了模拟的系统环境。 Eclipse Che是一个现代的、开放源代码的软件开发环境。它是一个通过提供结构化的工作区、项目输入、模块化扩展插件来支持Codenvy的引擎。Che可以用作桌面IDE，RESTful工作空间服务器，或作为一个创建新的工具SDK。我们将使用docker来运行Che Docker安装 删除旧版本 1$ sudo apt-get remove docker docker-engine docker.io 安装最新版本Docker CE 12345678910111213141516$ sudo apt-get update$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -$ sudo apt-key fingerprint 0EBFCD88$ sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable"$ sudo apt-get update$ sudo apt-get install docker-ce Hello World 1$ sudo docker run hello-world 运行che 1sudo docker run -ti -v /var/run/docker.sock:/var/run/docker.sock -v ~/Documents/che-data1:/data eclipse/che start -v ~/Documents/che-data1:/data表示将数据存储在~/Documents/che-data1 根据上面的结果浏览器输入http://localhost:8080 之后就可以像正常的IDE那样使用了; 运行界面 还有一个记录REST API请求的界面，打开localhost:8080/swagger]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>docker</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下Java安装]]></title>
    <url>%2F2018%2F03%2F09%2Fubuntu_java%2F</url>
    <content type="text"><![CDATA[介绍如何在Linux下安装Java 到Oracle官网下载安装包，选择tar.gz的版本，例如下载到/home/phoenix/Program_Files/ 解压 1sudo tar zxvf jdk-9.0.4_linux-x64_bin.tar.gz ​ 修改 /etc/environment 12345PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin"export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport JAVA_HOME=/home/phoenix/Program_Files/jdk-9.0.4 保存关闭后，刷新环境 1source /etc/enviroment ​ 验证环境 123456$ echo $JAVA_HOME/home/phoenix/Program_Files/jdk-9.0.4$ echo $CLASSPATH.:/lib:/jre/lib$ echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/bin ​ 修改/etc/profile 添加如下内容 1234JAVA_HOME=/home/phoenix/Program_Files/jdk-9.0.4export JRE_HOME=/home/phoenix/Program_Files/jdk-9.0.4/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH ​ 重启系统验证 1java -version ​]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性判别分析(LDA)]]></title>
    <url>%2F2018%2F03%2F07%2FLDA%2F</url>
    <content type="text"><![CDATA[线性判别分析(Linear Discriminant Analysis, LDA)是另外一种线性降维方法。与主成分分析法不同，线性判别分析是一种有监督学习，也就意味着线性判别分析需要使用带标签的数据进行训练来完成降维。 主成分分析法笔记 的主要思想是找到一种线性映射至低维空间的方法，保证降维后带有不同标签的数据能够尽量分散，而带有相同标签的数据能够尽量相互集中，与PCA一样，分散这一评价指标仍然由方差来决定。 二分类情况 考虑当样本的类别只有两类(0和1)且从d维映射至一维的问题，如下图 LDA的优化目标 其中μi为第i类样本的中心点，∑i表示第i类样本的协方差矩阵，即(x-μi)(x-μi)T; w即需要找到的最佳映射方式 定义“类内散度矩阵”(within-class scatter matrix) 以及“类间散度矩阵”(between-class scatter matrix) 则优化目标可以写为 称为Sb和Sw的“广义瑞利商”(generalized Rayleigh quotient) 但是只有这个式子是不够的，因为当w乘以一个倍数的时候，答案J不会改变，就有无穷多解。要求唯一解，就要对w进行限制，限制之后的优化目标： 与PCA相同，通过拉格朗日乘子法，得到： 又 由于w的任何倍数不会影响结果，所以 我们只要求出Sw就可以出最优的w ​ 多分类情况 多分类情况下，需要定义“全局散度矩阵”： 类内散度与类间散度矩阵的规定不变 只要知道其中的两者利用广义瑞利商就可以算出最优解，例如按照二分类的方法得到 同样也能求出解;]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主成分分析法(PCA)]]></title>
    <url>%2F2018%2F03%2F06%2FPCA%2F</url>
    <content type="text"><![CDATA[主成分分析法(principal component analysis, PCA)是最常用的无监督高维数据降维方法之一，它旨在降维的过程中保留原数据中最重要的几个分量，从而达到最大化原数据方差的作用。几乎所有数据降维方面研究都要用来作为比较重要的方法。 主成分分析的基本思想就是在原有样本的n维空间内再建立一个d维线性空间，用n个标准正交基进行重新映射，然后选取其中的d’个正交基进行保留，而在这d’个坐标轴上的坐标值就是映射到低维后的坐标。而推导的目的就是为了确定如何确定这这d个标准正交基以及如何选取它们。就如下图一样，将二维空间内的点映射至一维空间，最终选择较长的那条向量进行投影映射。 首先，需要将手头需要降维的数据进行中心化，使样本中心点为原点 然后假定选择的新的坐标系为 其中W是标准正交基向量，即 (i != j) 选取其中的d’个向量让原样本向新坐标系中映射WTxi，即： W是经过选取后的d’个标准正交基，z是低维中的坐标 选取的目标是使降维后的点尽量的分散，也就是方差尽量的大： 优化问题被归纳为 根据拉格朗日乘子法，来决定哪d’个w可以留下，优化目标就成为了： ​ 代入优化目标 ​ 所以求解的过程就是寻找原样本协方差矩阵XXT的最大的d’个特征值，而相应的标准正交基就是相应特征值的特征向量;]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Data Mining</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Requests和BeautifulSoup并行抓取今日头条图集]]></title>
    <url>%2F2018%2F03%2F04%2Fbeautifulsoup2%2F</url>
    <content type="text"><![CDATA[代码分块讲解。分析Ajax请求来爬取今日头条的图集，将结果存储在MongoDB中。使用了Python多进程(multiprocessing)并行进行抓取。针对一个实战的教程进行修改，以适应今日头条最新的网页请求方式 完整代码在这里 MongoDB笔记 Requests与BeautifulSoup笔记 首先，本次要爬取的页面外观如下 搜索后点击图集标签 点击进某一个详细页面后，得到： 其中所有照片不会一口气全部呈现在页面中，而是通过翻页来使用Ajax请求新的展示图 在搜索结果展示页，打开开发者工具-&gt;Network-&gt;XHR，然后刷新，我们可以获取请求的URL和请求的参数 编写获取页面的代码 1234567891011121314151617181920212223242526272829def get_page_index(offset, keyword): ''' :param offset: 页面offset，用于自动append新结果 :param keyword: 搜索关键字 :return: ''' #请求的参数 data = &#123; 'offset': offset, 'format': 'json', 'keyword': keyword, 'autoload':'true', 'count': '20', 'cur_tab': 3, 'from': 'gallery' &#125; #urlencode可以用来将参数的json串转换为url上的参数 url = 'https://www.toutiao.com/search_content/?' + urlencode(data) try: response = requests.get(url) #成功200 if response.status_code == 200: # print(response.text) return response.text return None except RequestException: print('请求索引页出错') return None 从开发者工具可以看到得到的响应串是 编写获取每个detail页面的url代码 123456789101112def parse_page_index(html): try: #转化为json对象 data = json.loads(html) # print(data) #有数据并且又‘data’标签 if data and 'data' in data.keys(): for item in data.get('data'): if 'article_url' in item.keys(): yield item.get('article_url') except JSONDecodeError: pass 获得每个detail页面的url后，与index页面类似，请求每个url 12345678910def get_page_detail(url): try: response = requests.get(url) # print(response.text) if response.status_code == 200: return response.text return None except RequestException: print('请求详情页出错', url) return None 在每个detail页面中打开开发者工具-&gt;Network-&gt;Doc，可以看到detail页面都预备要请求什么 可以发现在BASE_DATA.galleryInfo中gallery里记录了每个sub_img的信息，所以用正则表达式把它们提出来并尝试去请求图片 123456789101112131415161718192021222324252627def parse_page_detail(html, url): soup = BeautifulSoup(html, 'lxml') #获得页面title title = soup.select('title')[0].get_text() print(title) #匹配需要的串 image_pattern = re.compile('gallery: JSON.parse\("(.*?)"\),', re.S) result = re.search(image_pattern, html) if result: #group(1)只匹配括号里的，group()返回包括括号里的整个串 data = json.loads(result.group(1).replace('\\', '')) # print(data) if data and 'sub_images' in data.keys(): sub_imges = data['sub_images'] # 获得图片的url images = [item.get('url') for item in sub_imges] # 下载图片 for image in images: download_image(image) #返回预备要存入MongoDB的json串 return &#123; 'title' : title, 'images' : images, 'url' : url &#125; else: print("failed") 下载图片同请求网页类似 12345678910111213def download_image(url): print('downing', url, '...') try: response = requests.get(url, stream=True) if response.status_code == 200: # print(response.text) filename = url.split('/')[-1] #保存图片 save_image(response, filename) return None except RequestException: print('请求图片出错', url) return None 保存图片 12345678def save_image(response, filename): file_path = './jiepai/&#123;0&#125;.&#123;1&#125;'.format(filename, 'jpg') if not os.path.exists(file_path): with open(file_path, 'wb') as f: #按字节流保存 for chunk in response.iter_content(chunk_size=128): f.write(chunk) f.close() 主函数 123456789101112131415def main(offset): #请求index页面 html = get_page_index(offset, '街拍') #解析页面 for url in parse_page_index(html): #头条返回的url已经不能直接访问到网页，而是跳转到了新的页面，所以要自己转下格式 url = 'https://www.toutiao.com/a' + url.split('/')[-2] # 请求detail页面 html = get_page_detail(url) if html: #解析detail页面 result = parse_page_detail(html, url) #存入数据库 if result: save_to_mongo(result) 插入数据库的操作 123456789101112#连接数据库client = pymongo.MongoClient(MONGO_URL)#确定响应的databasedb = client[MONGO_DB]def save_to_mongo(result): #插入 if db[MONGO_TABLE].insert(result): print('存储到MongoDB成功', result) return True else: return False 其中 123456MONGO_URL = 'localhost'MONGO_DB = 'toutiao'MONGO_TABLE = 'toutiao'GROUP_START = 0GROUP_END = 20 并行地抓取不同offset的数据 123456789if __name__ == "__main__": if not os.path.exists('./jiepai'): os.mkdir('./jiepai') groups = [x*20 for x in range(GROUP_START, GROUP_END+1)] #创建进程池，默认为cpu核数 pool = Pool(processes=4) #开启进程，传入参数 pool.map(main, groups) Enjoy it !!!]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>BeautifulSoup</tag>
        <tag>网络爬虫</tag>
        <tag>python</tag>
        <tag>MongoDB</tag>
        <tag>parallel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu下安装MongoDB以及基本操作]]></title>
    <url>%2F2018%2F03%2F03%2Fubuntu_mongodb%2F</url>
    <content type="text"><![CDATA[MongoDB是著名的非关系型数据库，由于其存取十分灵活，在一些web应用上得到了比关系型数据库更广泛的运用 一、MongoDB安装 安装mongoDB 1sudo apt-get install mongodb 查看版本 1mongo -version 启动和关闭mongoDB服务 12service mongodb startservice mongodb stop 查看是否在运行 1pgrep mongo -l 卸载mongoDB 1sudo apt-get --purge remove mongodb mongodb-clients mongodb-server 二、MongoDB基本操作 启动MongoDB命令行工具 1mongo ​ 1234567show dbs #显示所有数据库show collections #显示当前数据库中的集合(collection类似mysql等关系数据库中的table)show users #显示所有用户use DBname #切换当前数据库至DBnamedb.help() #显示数据库操作命令db.yourCollection.help() #显示集合操作命令，yourCollection是集合名 exit #退出命令行工具 创建数据库 1use DBname #不需要事先定义，现用现创建 ​ 创建Collection 1db.createCollection('newCollection') 或直接向Collection中插入数据 ​ 插入数据 123db.collentionName.insert(&#123;_id:1, name: 'Ph0en1x', age: 20&#125;) # ordb.collectionName.save(&#123;_id:1, name: 'Ph0en1x', age: 22&#125;) _id不写会自动生成，当_id重复时，insert不会插入新的记录，而save会进行更新 ​ 查找数据 1db.youCollection.find(criteria, filterDisplay) criteria ：查询条件，可选 filterDisplay：筛选显示部分数据，如显示指定列数据，可选（当选择时，第一个参数不可省略，若查询条件为空，可用{}做占位符，如下例第三句） 例如 12345db.collectionName.find() #查询所有记录db.collectionName.find(&#123;name: 'Ph0en1x'&#125;) #查询name='Ph0en1x'的记录db.collectionName.find(&#123;&#125;,&#123;name:1, sge:1&#125;) #筛选出指定列name、age数据db.collectionName.find(&#123;name: 'Ph0en1x', age: 22&#125;) #and 与条件查询db.student.find(&#123;$or: [&#123;age: 22&#125;, &#123;age: 25&#125;]&#125;) #or 条件查询 ​ 修改数据 1db.youCollection.update(criteria, objNew, upsert, multi ) criteria： update的查询条件 objNew ：update的对象和一些更新的操作符 upsert ：如果不存在update的记录，是否插入objNew，true or false multi：false默认，只更新查询到的第一条，true更新全部 其中criteria和objNew是必选参数，upsert和multi可选参数 例如 1db.collectionName.update(&#123;name: 'Ph0en1x'&#125;, &#123;$set: &#123;sage: 13&#125;&#125;, false, true) ​ 删除数据 1db.collectionName.remove(&#123;name: 'Ph0en1x'&#125;) ​]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 多进程(multiprocessing)]]></title>
    <url>%2F2018%2F03%2F02%2Fpython_multiprocessing%2F</url>
    <content type="text"><![CDATA[Python多进程编程入门，基本使用，queue的使用，pool使用和共享变量的使用 完整代码点击这里 一、基本使用Python有多进程(multiprocessing)与多线程(multithreading)两种并行的方式，在python中导入库 12import multiprocessing as mpimport threading as td 我们编写一个代码来比较multiprocessing、multithreading和serial三种执行的效率 要使用并行，首先要先准备一个被调用的函数 1234567def job(q, a): res = 0 #两个进程/线程分别负责前半部分和后半部分 for i in range(50000*a, 50000*(a+1)): res += i**3 + i**2 + i #结果放入queue中 q.put(res) 多进程 123456789101112131415def multiprocess(): # 使用queue q = mp.Queue() #传入参数 p1 = mp.Process(target=job, args=(q, 0)) p2 = mp.Process(target=job, args=(q, 1)) p1.start() p2.start() p1.join() p2.join() res1 = q.get() res2 = q.get() print('multiprocess:',res1 + res2) 多线程 1234567891011121314def multithread(): # 使用queue q = mp.Queue() t1 = td.Thread(target=job, args=(q, 0)) t2 = td.Thread(target=job, args=(q, 1)) t1.start() t2.start() t1.join() t2.join() res1 = q.get() res2 = q.get() print('multithread:', res1 + res2) 串行执行 12345def serial(): res = 0 for i in range(100000): res += i**3 + i**2 + i print('serial:', res) 调用 123456789101112if __name__ == '__main__': import time st = time.time() serial() st1 = time.time() print('serial time:', st1 - st, "\n") multithread() st2 = time.time() print('multithread time:', st2 - st1, "\n") multiprocess() print('multiprocess time:', time.time() - st2, "\n") 输出 12345678serial: 24999833335833300000serial time: 0.07318806648254395 multithread: 24999833335833300000multithread time: 0.16390419006347656 multiprocess: 24999833335833300000multiprocess time: 0.057524681091308594 可以看出，multiprocessing比普通串行的执行要快一些，但是multithreading比串行要慢一些。multithreading要体现性能的提升必须在任务有大量的IO时，在计算密集型的程序内，multithreading无法体现优越性。事实上，当处理的事情越少时，调度多进程的代价大于多进程带来的性能提升，两种并行都要比串行要慢 二、使用pool来调用python多进程123456789101112131415161718import multiprocessing as mpdef job(x): return x**3def multiprocess(): #mp.Pool()进程数processes默认为cpu核数 pool = mp.Pool(processes=2) res = pool.map(job, range(10)) print(res) #使用apply_async()只能传一组参数 multi_res = [pool.apply_async(job, (i,)) for i in range(10)] print([res.get() for res in multi_res])if __name__ == "__main__": multiprocess() 输出 12[0, 1, 8, 27, 64, 125, 216, 343, 512, 729][0, 1, 8, 27, 64, 125, 216, 343, 512, 729] 三、共享变量与互斥锁1234567891011121314151617181920212223242526272829303132import multiprocessing as mpimport timedef job(v, num, l): #请求锁 l.acquire() for _ in range(10): time.sleep(0.1) v.value = v.value + num print(v.value) #释放锁 l.release()def multiprocess(): #共享变量 v = mp.Value('i', 0) #互斥锁 l = mp.Lock() p1 = mp.Process(target=job, args=(v, -1, l)) p2 = mp.Process(target=job, args=(v, 1, l)) p1.start() p2.start() p1.join() p2.join() print('final:', v.value)if __name__ == "__main__": multiprocess() 输出(不使用互斥锁) 123456789101112131415161718192021-10-10-10-10-111121023324final: 4 答案出现了错误，并且两个进程的执行顺序很随机，因为可能出现A进程读取变量到寄存器进行计算后时间片被用完挂起，B进程开始进行了读取之后挂起，当A将计算完的结果放回到内存挂起后B进程又将计算完的结果放回内存，A的计算就被覆盖，产生了错误。 输出(使用互斥锁) 123456789101112131415161718192021-1-2-3-4-5-6-7-8-9-10-9-8-7-6-5-4-3-2-10final: 0 可以看到进程1先抢到了互斥锁开始了自己的循环，直到执行完释放后进程2才开始执行。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>parallel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[L2正则化解决过拟合问题]]></title>
    <url>%2F2018%2F02%2F28%2Fl2_regularization%2F</url>
    <content type="text"><![CDATA[过拟合(overfit)是深度学习乃至机器学习过程中的又一大问题，通常的解决方法为L2正则化、Dropout正则化等等 一、L2正则化L2正则化就是在原来的损失函数上，再加上一项参数的二范式 第二项又称作弗罗贝尼乌斯范数（Frobenius norm）的平方 将新的损失函数对参数求梯度得 使用梯度下降更新参数 其中α、λ是两个超参数，α是学习率，而λ负责调节L2正则化过程 λ=0时，表示不使用正则化 λ越大，在训练过程中则会压制参数的变大，使参数尽量变小 二、L2正则化为什么有效通俗的解释，产生过拟合问题的根本原因是模型试图记住的参数太多，导致其举一反三的能力减弱，而通过L2正则化，导致很多的参数会变得很小，对模型的影响力降低，相当于降低了模型的复杂程度，提高了泛化能力。 还有一种比较通俗的解释，来自Andrew Ng 我们的所常用的激活函数sigmoid、tanh是长这样的 如果控制参数较小，那么中间层输出的参数也会很小，就会集中在中间导数相对于稳定的位置，也就是限制了分类模型过分的扭曲。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过拟合与欠拟合问题]]></title>
    <url>%2F2018%2F02%2F27%2Foverfit%2F</url>
    <content type="text"><![CDATA[过拟合(overfit)是深度学习乃至机器学习过程中的又一大问题，通常的解决方法为L2正则化、Dropout正则化等等 要解释过拟合，需要借用一张Andrew Ng的课件： 三附图中的左图，模型过于简单，偏差较大，无法很好的拟合非线性的分类问题，出现欠拟合(underfit)问题，一般需要增加网络层数，增加隐藏层神经元个数来解决。这种问题一般表现为训练集与验证集损失函数值都较大; 右图，过于贴合训练集，方差较大，称作过拟合(overfit)问题，过拟合问题一般表现为训练集损失函数值较小，但是验证集的损失函数较大。即训练出的模型太过死板，而无法解决训练集以外的数据; 中间表示刚好的情况，一般训练集与验证集损失函数值都较小 要通俗且形象地解释过拟合现象就是——书呆子，将做过的题目全都背下，但缺乏举一反三的能力，碰到做过的题，那么他就会做，但是改个问法就傻了。 有个更加有意思的说法就是——考驾照，驾考时教练一般会让你看准许多的记号，然后机械地打方向盘，然而这样即使拿到的驾照，也无法立即上路。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Requests和BeautifulSoup编写简单的网络爬虫]]></title>
    <url>%2F2018%2F02%2F26%2Fbeautifulsoup%2F</url>
    <content type="text"><![CDATA[前段时间一个任务需要获得日本所有主要城市的经纬度坐标，手头没有现成的数据，只能写一个简单的爬虫来爬取某旅游公司的页面来获得我要的经纬度数据。。采用一个方便简单的爬虫框架Request与BeautifulSoup，由于项目时间很赶，只是一个很简单的脚本，并不考虑动态页面，也没有与数据库进行交互，这部分的笔记以后再补，我会就着这次的代码简单介绍它们的使用方法 一、Requests与BeautifulSoup简介 Requests Requests 是一个为人们制作的一个Python库，用于优雅且简单的HTTP BeautifulSoup Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 Beautiful Soup自动将输入文档转换为Unicode编码，输出文档转换为utf-8编码。你不需要考虑编码方式，除非文档没有指定一个编码方式，这时，Beautiful Soup就不能自动识别编码方式了。然后，你仅仅需要说明一下原始编码方式就可以了。 Beautiful Soup已成为和lxml、html6lib一样出色的python解释器，为用户灵活地提供不同的解析策略或强劲的速度。 Requests 与 BeautifulSoup一个负责请求页面，获得页面，一个负责解析页面内容，取出需要的数据 官方文档 Requests官方文档 BeautifulSoup官方文档 二、安装Request与Beautiful如果已经安装pip，那么安装就很简单 12$ pip insatall requests$ pip install BeautifulSoup4 三、代码解析完整的代码在这里 首先需要找到一个合适的网页并分析它的网页结构，我找到的一个网站结构是这样的： 打开开发者工具，可以发现网页的分页的链接是从index~index44 所以可以先将要爬取的网页以模版的形式装入 1234567891011#抓取的网页地址模版，所有分页的目录listURL = 'http://www.cnair.com/city/Japan/index&#123;&#125;.htm'lists = [listURL.format('')]# lists = []for i in range(1, 45): lists.append(listURL.format(str(i)))#打开一个文件用于append抓到的信息f = open("gpsmap.json", "a")# print(lists)#存储爬取的数据dic = &#123;&#125; 对于每一页中的所有城市的电子地图，我们通过开发者工具可以发现它的结构是这样的： 所以请求相应的页面后，我们需要找到存着相应子页面链接标签，发现他们位于class=‘mainListTitle’的&lt;span&gt;标签下的&lt;a&gt;标签下，所以可以使用BeautifulSoup进行提取 12345678for item in lists: #使用Requests请求页面 res = requests.get(item) # print(res.text) #解析html文本 soup = BeautifulSoup(res.text, 'html.parser') #选取出页面中mainNewsTitle类下的&lt;a&gt;标签 urls = soup.select('.mainNewsTitle a') 访问相应的子页面，观察页面的结构 发现地名、经纬度等信息被放在了同一个class=’NewsContent’的&lt;div&gt;标签下，在同一个字符串中。所以我们需要从中提取出字符串，并以&lt;br&gt;作为分隔符，提取出他们。 123456789101112131415for u in urls: # print(u['href']) #取出每个&lt;a&gt;标签下的href属性并请求该页面 tmpres = requests.get(u['href']) #解析需要使用utf8编码 tmpres.encoding = 'utf_8' tmpsoup = BeautifulSoup(tmpres.text, 'html.parser') text = tmpsoup.select('.NewsContent') textarr = str(text[0]).split('&lt;br/&gt;') #取出城市名称 name = textarr[1].split(' : ')[1] #取出经度 lng = textarr[6].split(' : ')[1] #取出纬度 lat = textarr[5].split(' : ')[1] 单位转换并保存到python的字典中，并最后保存到json文件中。这里有个小trick，爬取每个子页面后，可以让程序休眠1秒，爬取一个大页面后，可以停止10秒。这样做的目的是防止过于频繁的访问，导致服务器的拒绝访问。 123456789101112131415 #存下刚刚抓取的信息 tmpdic = &#123;&#125; tmpdic['lng'] = lng tmpdic['lat'] = lat dic[name] = tmpdic print('&#123;&#125; &#123;&#125; &#123;&#125;'.format(name, lng, lat), file=f) print('&#123;&#125; : &#123;&#125;: &#123;&#125;: &#123;&#125;'.format(item, name, lng, lat)) #停顿1秒 time.sleep(1) time.sleep(10)#存储抓取的结构化信息jsonStr = json.dumps(dic)f = open("gpsmap.json", "w")print(jsonStr, file=f)f.close()]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>BeautifulSoup</tag>
        <tag>网络爬虫</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LSTM(Long Short Term Memory)与GRU(Gated Recurrent Unit)]]></title>
    <url>%2F2018%2F02%2F23%2FLSTM%2F</url>
    <content type="text"><![CDATA[循环神经网络(RNN)是深度神经网络最重要的的形式之一，其被广泛运用于时序形数据的处理上、例如文字、音频、视频等等；而RNN在训练的过程中同样也会发生梯度不稳定的情况，同时还面临着新的数据不断加入循环而旧的数据不断被冲淡的情况，导致一个句子中开始的部分在最终结果的影响程度中较低，于是LSTM模型就诞生并用于改善这种情况 一、循环神经网络(Recurrent Neural Networks)人在阅读文章、观看视频时，理解当前看到的东西，不会仅仅依靠当前的内容就作出理解，还要对上文进行综合理解，比如翻译The NBA player Kevin Love，当翻译Love时，应当翻译为乐福而不是喜欢，这是因为前面提到了NBA、player这些词。所以当使用深度神经网络进行翻译的时候就需要网络拥有对前文的记忆，这就是RNN出现的原因； 这是RNN的结构 我们可以看到RNN是同一个单元的重复循环出现，每一次单元计算后都会产生一个记忆，传入下一个单元的计算，每一个单元都会接收当前的输入，并且考虑前面的记忆，作出当前的输出； 二、长短时记忆LSTM前面说到了普通的RNN单元会有Long-Term Dependencies的问题，就是每部所产生的记忆，可能只会对较近的几个输出产生影响，而随着网络加深，记忆将会消退，例如翻译“The NBA …(此处省略10000字)…Kevin Love”时，如果用普通的的RNN，那么Kevin Love依然有可能会被翻译为凯文喜欢，就如下图： 这时候就要请出我们今天的主角LSTM了，传统的RNN之所以不能够拥有很好的长时记忆是因为每个单元都是经过简单的线性变换加上tanh激活函数，如下图： 而LSTM则要复杂很多： LSTM的记忆干流就是Ct，上一个单元的输入作用于它，并且与它一起形成这个单元的输出： LSTM则包含了一个叫遗忘门的单元，用来判断上一单元传过来的记忆中哪些是可以忘记的，而哪些比较重要，需要记下 对本单元的输入信息进行提取 调整当前的记忆 完成本单元的输出 三、LSTM变体——GRULSTM还拥有许多的变体，其中最常用的就是GRU，它是LSTM的一种简化，将C与h合二为一，拥有更好的效率，在某些任务上也有更好的效果 四、参考Understanding LSTM Networks]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>RNN</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xavier方法用于神经网络参数初始化]]></title>
    <url>%2F2018%2F02%2F22%2FXavier%2F</url>
    <content type="text"><![CDATA[之前我们学习了使用RBM对深度置信网络进行逐层训练初始化，或用类似的方法对多层深度神经网络进行预训练(pretraining)，以求最终收敛的结果接近最优且加快收敛速度，同时还能避免梯度消失(gradient vanishing)和梯度爆炸(gradient explosion)的问题。今天介绍一个更加方便快速的初始化方法，来近似达到相同的目的。 一、梯度消失与梯度爆炸这是一个深度学习领域遇到的老问题了，即使是现在，任何一个新提出的模型，无论是MLP、CNN、还是RNN，随着深度的加深，这两个问题变得尤为严重。 梯度消失是指在深度学习训练的过程中，梯度随着链式求导逐层传递逐层减小，最后趋近于0，导致对某些层的训练失效； 梯度爆炸与梯度消失相反，梯度随着链式求导逐层传递逐层增大，最后趋于无穷，导致某些层无法收敛； 出现梯度消失和梯度爆炸的问题主要是因为参数初始化不当以及激活函数选择不当造成的，这在之后我会做相应的笔记来讨论batch normalization与激活函数 二、Xavier方法接下来的推导基于假设: 激活函数在0周围的导数接近1(比如tanh); 偏置项b初始化为0，期望为0 参数初始化期望均为0 显然，在初始化参数的时候不能全部初始化为0，这样无论是什么输入，输出都是0，无法训练，但也不能随意去初始值，否则就会造成梯度不稳定的问题。那么什么样的初始值才是合适的呢？ 答案就是使每层的分布都尽量相等，RBM就是为了这个目的而训练的，但是Xavier做了进一步的简化：保留均值(可以在下一层开始的时候再做调整)与方差 对于每一个输出的神经元 都要使 又 根据假设E(w)与E(x)均等0且所有w与x同分布，则： 要满足所以: 其中nin与nout分别是输入层与输出层的神经元个数 如果W服从正态分布，那么这就是所需要的参数，但如果假设W服从均匀分布，那么 但是之前有假设激活函数在0周围的导数接近1，所以忽略了激活函数的作用，不同激活函数在0周围的导数不同，需要给方差乘上导数的倒数 Activation Function Uniform Distribution sigmoid tanh ReLU 三、代码实现tensorflow的实现 1234def xavier_init(fan_in, fan_out, constant = 1): low = -constant * np.sqrt(6.0 / (fan_in + fan_out)) high = constant * np.sqrt(6.0 / (fan_in + fan_out)) return tf.random_uniform((fan_in, fan_out), minval=low, maxval=high, dtype=tf.float32) 完整代码里实现了一个使用Xavier方法初始化的单层自编码器]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[受限制玻尔兹曼机(RBM)的能量函数及其梯度求解]]></title>
    <url>%2F2018%2F02%2F21%2FRBM_energy%2F</url>
    <content type="text"><![CDATA[在前面的一篇文章 受限制玻尔兹曼机(Restricted Bolzmann Machine)以及自编码器(Autoencoder)中我们提到了RBM的能量函数这一概念以及对比散度(CD)的快速采样的训练方法，但我一直纠结与为何Hinton大神能够从能量函数和Gibbs Sampling中获得CD-k采样算法，两个式子看似没有关联。于是我花了几天的时间，终于对RBM这个结构有了更深一步的了解。 一、能量函数与概率分布之前讲到受限制玻尔兹曼机时，我们提到，RBM是由一个可见层(visible, v)与隐藏层(hiddenm, h)组成，如下图，W在物理中表示系统内部能量转换，比如分子间碰撞产生的能量传递，同时有a, b两个偏置项，在物理中表示外来因素的影响，与外界的能量交换： 能量函数的定义是： 用矩阵来表示就是 能量函数具体的含义涉及物理领域，在本文不会具体介绍，具体请阅读Ising Model的相关文章，本文具体介绍如何从能量函数中推倒出Gibbs Sampling和CD-k v, h联合概率分布是 其中Z是所有[v, h]对对应的能量的总和，称为归一化因子或配分函数(Partition Function) v与h的边缘概率分布如下 条件分布 同理 由于RBM层内无连接，所以同一层内的变量还具有相互独立性，即 二、对数似然函数上面定义了那么多，然而要开始正式的梯度优化，我们还差一个优化目标，现在就要正式地定义损失函数： 之前曾经提到过，受限制玻尔兹曼机的训练目的是让原始数据的分布得到最大的保留，用最大似然估计来表示就是让P(v)最大。采用对数似然函数，则式子如下： 对参数求梯度： 所以只要能求得 就可以求出最终的梯度,RBM每层有W, a, b三个不同的参数，则需要分别对三个参数分别求导： W b与W的推导过程类似，结果为： a的推导更加的简单 把上面三个式子带回到梯度的公式中，就可以得到 这就是Gibbs采样和CD-k采样的来源，只是采用了不同的估计方法来确定概率分布。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deep Learning</tag>
        <tag>RBM</tag>
        <tag>contrastive divergence</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[受限制玻尔兹曼机(Restricted Bolzmann Machine)以及自编码器(Autoencoder)]]></title>
    <url>%2F2018%2F02%2F15%2FRBM%2F</url>
    <content type="text"><![CDATA[受限制玻尔兹曼机(Restricted Bolzmann Machine, RBM)与自编码器(Autoencoder, AE)是神经网络的两种基本结构，两个结构都能起到降维的作用，都可以用来对神经网络进行预训练（pre-training），这种预训练都是无监督的。由于RBM与MLP及其相似，一直以来我就困惑于他们两者，终于花了几天时间来搞清楚他们的区别和训练方法，发现他们甚至不是并列的关系。。 一、知识脉络受限制玻尔兹曼机 -&gt; 深度信念网络(Deep Blief Network, DBN) 自编码器 -&gt; 堆叠自编码器(Stacked Autoencoderm, SAE) 二、自编码器自编码器的输入维度与输出维度相等，训练目的是使数据的特征得到最大的保留，去除冗余信息，一个单层的自编码器结构如下图 当然一个自编码器也可以有很多层： 简化来看就是输入层-&gt;隐藏层-&gt;输出层，自编码器的目的就是使重建(reconstruction)的输出层能尽量还原输入层，同时获得中间隐藏层(最窄的橙色那层)既是降维的结果。若输入层到隐藏层间的部分称为编码器(灰色)，记号为f(x)，隐藏层到输出层之间的部分称为解码器(黄色)，记号为g(x)，那么自编码器的数学训练目标就是 三、受限制玻尔兹曼机受限制玻尔兹曼机是一个双层结构，可见层(visible)与隐藏层(hidden)，图结构为一个二分图，即可见层只与隐藏层之间有连接，但是层内是无连接的，因此RBM的性质：当给定可见层神经元的状态时，各隐藏层神经元的激活条件独立；反之当给定隐藏层神经元的状态时，可见层神经元的激活也条件独立。基本结构如下 受限制玻尔兹曼机的训练目的是为了最大程度的保留概率分布，定义了一个能量函数的概念 用矩阵来表示就是 a与b分别是可视层与隐藏层的偏置项(bias) v, h联合概率分布是 其中Z是所有[v, h]对对应的能量的总和，v的边缘概率分布如下，h同理 由于受限玻尔兹曼机结构上的特点，所以各隐藏层之间的神经元条件概率独立，即 可见层v同理 能量函数的具体推导过程将会在后面的文章中详细解释 四、训练方法就像RBM是由物理模型转化过来一样，训练方法与传统的反向传播(BP)也不一样 RBM最早的训练方法有Gibbs sampling，通过不断地来回采样来训练，如下图 然而这样的方法太慢，所以Hinton大神又提出了CD-k(contrastive divergence)算法，即只需要来回重复k次就可以，以CD-1为例: 就可以完成一次迭代，这就像是两种不同温度的液体进行混合，如果两者的温度差距较大，在混合的过程中就会产生较大的梯度，而受限制玻尔兹曼机的训练目标就是使得两边的“温度”能够尽量的相近，而在数据中这个“温度”的体现就是数据分布。也就是说，使用RBM进行模型的初始化训练能够最大程度的保留数据分布，防止梯度爆炸和梯度消失问题的出现。 五、深度信念网络与逐层训练由多层受限制玻尔兹曼机堆叠起来的网络叫作深度信念网络(DBN)。深度信念网络在最后一层接入一个Softmax层用作分类，训练的时候采取逐层训练+微调的方式 逐层训练就是从输入层开始将网络的相邻两层当作一个受限制玻尔兹曼机进行无监督训练，训练方法见上一节，训练后将上一个RBM的隐藏层当作下一个RBM的可见层继续 逐层无监督训练完毕后，将进行反向传播训练对模型进行微调，从输入端输入数据，最后从输出端开始进行反向传播 自编码器虽然只是要保证输出端与输入端尽量接近，但是随着自编码器堆叠深度的加深，就会出现类似梯度弥散与梯度爆炸等问题，Hinton大神同样也使用了类似RBM的训练方法对深度自编码器进行逐层训练，使模型的得到了很好的初始化，加快了模型的解的最优性和收敛速度。 六、参考 受限玻尔兹曼机与深度置信网络 Hinton G E. A practical guide to training restricted Boltzmann machines[M]//Neural networks: Tricks of the trade. Springer, Berlin, Heidelberg, 2012: 599-619. Bengio Y, Lamblin P, Popovici D, et al. Greedy layer-wise training of deep networks[C]//Advances in neural information processing systems. 2007: 153-160. Hinton G E, Osindero S, Teh Y W. A fast learning algorithm for deep belief nets[J]. Neural computation, 2006, 18(7): 1527-1554. Hinton G E, Salakhutdinov R R. Reducing the dimensionality of data with neural networks[J]. science, 2006, 313(5786): 504-507.]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Deep Learning</tag>
        <tag>RBM</tag>
        <tag>contrastive divergence</tag>
        <tag>Autoencoder</tag>
        <tag>DBN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fcitx下全角中括号无法输入的问题]]></title>
    <url>%2F2018%2F02%2F15%2Ffcitx%2F</url>
    <content type="text"><![CDATA[本篇文章将会介绍如何修复ubuntu下Fcitx输入法无法输入全角（中文）中括号【】并使用[]来切换候选字的方法 操作步聚： 打开fcitx字符映射文件 1sudo gedit /usr/share/fcitx/data/punc.mb.zh_CN ​ 修改 将 12[ ·] 「 」 修改为 12[ 【] 】 重启输入法完成修改]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Fcitx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu下安装Nvidia最新驱动]]></title>
    <url>%2F2018%2F02%2F09%2Fubuntu_nvidia%2F</url>
    <content type="text"><![CDATA[众所周知Nvidia和Ubuntu向来不对付，Nvidia不会将自己的驱动开源，而Ubuntu社区开发的nouveau开源驱动又极大的限制了Nvidia显卡驱动原有的性能，给基于深度学习的研究造成了不小的麻烦。而有的时候由于Windows的种种原因，深度学习的开发又不得不在Linux上完成。这篇笔记将会记录一种安装Nvidia最新驱动的简便方法(不过当然不是直接用系统给的那个选项直接改)，使用官方PPA源来安装最新驱动。 禁用nouveau驱动 打开黑名单文件blacklist.conf加入nouveau驱动 1sudo gedit /etc/modprobe.d/blacklist.conf 如果有权限问题请自行chmod调整权限 在文件末尾添加 12345blacklist vga16fbblacklist nouveaublacklist rivafbblacklist rivatvblacklist nvidiafb ​ 刷新内核 1sudo update-initramfs -u ​ 重启系统后检查是否禁用成功 1lsmod | grep nouveau ​ 添加Nvidia官方PPA 12sudo add-apt-repository ppa:graphics-drivers/ppasudo apt update 并查看可以使用的驱动版本号(到官网上查看也可以) 1ubuntu-drivers devices ​ ctrl + alt + F1进入tty并登录 关闭图形界面 1sudo service lightdm stop ​ apt安装驱动并重启 12sudo apt install nvidia-390sudo reboot 390是刚才查看到的版本号的第一个部分 ​ 重启后查看显卡是否安装成功 12sudo nvidia-smisudo nvidia-settings 按照上面说的方法安装完成，打开关于计算机界面，应该就能看到，显卡被改变成了你的Nvidia显卡型号。（原先是Intel显卡） 注意如果是双系统，需要关闭BIOS的安全启动(Secure Boot) 安装后使用Nvidia驱动不出意外应该显示的时候会出现画面撕裂、卡顿的情况。这我暂时没找到方法解决，只能不使用Nvidia显卡的时候切换成Intel显卡，这样还省电 还有一种方法是编译官方的二进制文件，这种方法应该是最好的，但是每次升级内核就要重新编译一次，本着不折腾的原则，还是选择了这种方法 自己编译源码的方法，只需要把第7步替换成运行从英伟达官网上下载的安装包，然后根据提示安装就可以了 ​]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Nvidia</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Importance Sampling (重要性采样)]]></title>
    <url>%2F2018%2F02%2F08%2Fimportance_sampling%2F</url>
    <content type="text"><![CDATA[重要性采样是我在学习强化学习的过程中遇到的一种采样方法，是为了应对当要进行采样的样本分布难以获得时的问题。重要性采样使用另一个采样来代替当前的采样 什么是采样的常见问题 抛硬币问题，通过无限多次的抛硬币实验来估计硬币正面朝上的概率 面积问题，通过向特定区域撒豆子，通过计算豆子的数量和区域总面积，来计算某一个子区域的面积 蒙特卡罗法求积分 通过在[a, b]区间内按均匀分布来进行采样求得f(x)在[a, b]区间内的平均值，然后乘上b-a得到积分 蒙特卡洛法求期望期望就相当于在求积分的时候加入一个重要性的概念，即变量服从一个概率分布，则上述公式变为 按照p(x)的分布来产生随机数进行采样 这时，如果p(x)未知，那就无法针对p(x)进行采样来估计期望值，那怎么办呢？这时候就要借助这篇笔记的主角——重要性采样 重要性采样这时候需要引入一个新的已知的分布q(x)然后把原来的公式更改为 这样我们就可以针对q(x)来对p(x)/q(x)*f(x)来进行采样了 这就是重要性采样。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforce 920C Swap Adjacent Elements]]></title>
    <url>%2F2018%2F02%2F07%2Fcodeforce920C%2F</url>
    <content type="text"><![CDATA[You have an array a consisting of n integers. Each integer from 1 to n appears exactly once in this array. For some indices i (1 ≤ i ≤ n - 1) it is possible to swap i-th element with (i + 1)-th, for other indices it is not possible. You may perform any number of swapping operations any order. There is no limit on the number of times you swap i-th element with (i + 1)-th (if the position is not forbidden). Can you make this array sorted in ascending order performing some sequence of swapping operations? Input The first line contains one integer n (2 ≤ n ≤ 200000) — the number of elements in the array. The second line contains n integers a1, a2, …, a**n (1 ≤ a**i ≤ 200000) — the elements of the array. Each integer from 1 to n appears exactly once. The third line contains a string of n - 1 characters, each character is either 0 or 1. If i-th character is 1, then you can swap i-th element with (i + 1)-th any number of times, otherwise it is forbidden to swap i-th element with (i + 1)-th. Output If it is possible to sort the array in ascending order using any sequence of swaps you are allowed to make, print YES. Otherwise, print NO. Examples input 12361 2 5 3 4 601110 output 1YES input 12361 2 5 3 4 601010 output 1NO Note In the first example you may swap a3 and a4, and then swap a4 and a5. 每段连续的1以及最后一个1右边的位置的数都是可以相互交换的，但是和其他的部分之间不能互换，所以每段区间[l, r]不能出现超出区间[l+1, r+1]范围的数 剩余的部分就是不能进行交换的部分，即数必须等于下标+1 C++ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#define N 200001using namespace std;int arr[N];char str[N];int main()&#123; int num; bool flag = true; while(~scanf("%d", &amp;num)) &#123; flag = true; for(int i = 0; i &lt; num; i++) &#123; scanf("%d", &amp;arr[i]); &#125; scanf("%s", str); getchar(); for(int i = 0; i &lt; num; i++) &#123; int l = i; while(str[i] == '1' &amp;&amp; i &lt; num-1) i++; int r = i; if(l == r &amp;&amp; arr[l] != l+1) &#123;// cout &lt;&lt; "sdf: " &lt;&lt; l &lt;&lt; endl; flag = false; break; &#125; for(int j = l; j &lt;= r; j++) &#123; if(arr[j] &gt; r+1 || arr[j] &lt; l+1) &#123;// cout &lt;&lt; l &lt;&lt; ' ' &lt;&lt; r &lt;&lt; endl; flag = false; break; &#125; &#125; &#125; if(flag) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux发行版Firefox下安装最新版Flash]]></title>
    <url>%2F2018%2F02%2F07%2Ffirefox_flash%2F</url>
    <content type="text"><![CDATA[虽然在Windows上Chrome浏览器占据着霸主地位，但是在Linux上，明显面向开源社区的Firefox对各种发行版例如Ubuntu等优化得更棒。虽然Html5是趋势，但是Flash在日常浏览网页中依旧不能少。Ubuntu中的Firefox没有像Chrome一样内置Pepper Flash插件，而Adobe早已对Ubuntu停更。那么要如何为Ubuntu下的Firefox安装最新的Flash插件呢？ 进入 Download Adobe Flash Player 选择.tar.gz 适用于Linux下载 下载后解压flash_player_npapi_linux.x86_64.tar.gz，进入flash_player_npapi_linux.x86_64中复制libflashplayer.so 在~/.mozilla下新建文件夹plugins 把libflashplayer.so粘贴到plugins下 重启Firefox，完成最新Flash安装]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>Firefox</tag>
        <tag>Flash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforce 920B Tea Queue]]></title>
    <url>%2F2018%2F02%2F06%2Fcodeforce920B%2F</url>
    <content type="text"><![CDATA[Recently n students from city S moved to city P to attend a programming camp. They moved there by train. In the evening, all students in the train decided that they want to drink some tea. Of course, no two people can use the same teapot simultaneously, so the students had to form a queue to get their tea. i-th student comes to the end of the queue at the beginning of l**i-th second. If there are multiple students coming to the queue in the same moment, then the student with greater index comes after the student with lesser index. Students in the queue behave as follows: if there is nobody in the queue before the student, then he uses the teapot for exactly one second and leaves the queue with his tea; otherwise the student waits for the people before him to get their tea. If at the beginning of r**i-th second student i still cannot get his tea (there is someone before him in the queue), then he leaves the queue without getting any tea. For each student determine the second he will use the teapot and get his tea (if he actually gets it). Input The first line contains one integer t — the number of test cases to solve (1 ≤ t ≤ 1000). Then t test cases follow. The first line of each test case contains one integer n (1 ≤ n ≤ 1000) — the number of students. Then n lines follow. Each line contains two integer l**i, r**i (1 ≤ l**i ≤ r**i ≤ 5000) — the second i-th student comes to the end of the queue, and the second he leaves the queue if he still cannot get his tea. It is guaranteed that for every condition l**i - 1 ≤ l**i holds. The sum of n over all test cases doesn’t exceed 1000. Note that in hacks you have to set t = 1. Output For each test case print n integers. i-th of them must be equal to the second when i-th student gets his tea, or 0 if he leaves without tea. Example input 12345678221 31 431 51 12 3 output 121 2 1 0 2 Note The example contains 2 tests: During 1-st second, students 1 and 2 come to the queue, and student 1 gets his tea. Student 2 gets his tea during 2-nd second. During 1-st second, students 1 and 2 come to the queue, student 1 gets his tea, and student 2 leaves without tea. During 2-nd second, student 3 comes and gets his tea. C++ Code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int t; int cur = 0; int num; int l, r; int arr[1005]; scanf("%d", &amp;t); while(t--) &#123; scanf("%d", &amp;num); cur = 0; for(int i = 0; i &lt; num; i++) &#123; scanf("%d%d", &amp;l, &amp;r); if(l &lt;= cur) &#123; if(cur &gt;= r) arr[i] = 0; else &#123; arr[i] = ++cur; &#125; &#125; else &#123; cur = l; arr[i] = l; &#125; &#125; for(int i = 0; i &lt; num; i++) printf("%d ", arr[i]); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforce 920A Water The Garden]]></title>
    <url>%2F2018%2F02%2F06%2Fcodeforce920A%2F</url>
    <content type="text"><![CDATA[It is winter now, and Max decided it’s about time he watered the garden. The garden can be represented as n consecutive garden beds, numbered from 1 to n. k beds contain water taps (i-th tap is located in the bed x**i), which, if turned on, start delivering water to neighbouring beds. If the tap on the bed x**i is turned on, then after one second has passed, the bed x**i will be watered; after two seconds have passed, the beds from the segment [x**i - 1, x**i + 1] will be watered (if they exist); after j seconds have passed (j is an integer number), the beds from the segment [x**i - (j - 1), x**i + (j - 1)] will be watered (if they exist). Nothing changes during the seconds, so, for example, we can’t say that the segment [x**i - 2.5, x**i + 2.5] will be watered after 2.5seconds have passed; only the segment [x**i - 2, x**i + 2] will be watered at that moment. The garden from test 1. White colour denotes a garden bed without a tap, red colour — a garden bed with a tap. The garden from test 1 after 2 seconds have passed after turning on the tap. White colour denotes an unwatered garden bed, blue colour — a watered bed. Max wants to turn on all the water taps at the same moment, and now he wonders, what is the minimum number of seconds that have to pass after he turns on some taps until the whole garden is watered. Help him to find the answer! Input The first line contains one integer t — the number of test cases to solve (1 ≤ t ≤ 200). Then t test cases follow. The first line of each test case contains two integers n and k(1 ≤ n ≤ 200, 1 ≤ k ≤ n) — the number of garden beds and water taps, respectively. Next line contains k integers x**i (1 ≤ x**i ≤ n) — the location of i-th water tap. It is guaranteed that for each condition x**i - 1 &lt; x**i holds. It is guaranteed that the sum of n over all test cases doesn’t exceed 200. Note that in hacks you have to set t = 1. Output For each test case print one integer — the minimum number of seconds that have to pass after Max turns on some of the water taps, until the whole garden is watered. Example input 123456735 133 31 2 34 11 output 123314 Note The first example consists of 3 tests: There are 5 garden beds, and a water tap in the bed 3. If we turn it on, then after 1second passes, only bed 3 will be watered; after 2 seconds pass, beds [1, 3] will be watered, and after 3 seconds pass, everything will be watered. There are 3 garden beds, and there is a water tap in each one. If we turn all of them on, then everything will be watered after 1 second passes. There are 4 garden beds, and only one tap in the bed 1. It will take 4 seconds to water, for example, bed 4. C++ Code 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int t, n, k, tmp = 0, pretmp; int mi = 0; while(~scanf("%d", &amp;t)) &#123; for(int i = 0; i &lt; t; i++) &#123; scanf("%d%d", &amp;n, &amp;k); for(int j = 0; j &lt; k; j++) &#123; pretmp = tmp; scanf("%d", &amp;tmp); if(j == 0) mi = tmp; if(j &gt; 0 &amp;&amp; j &lt; k-1) mi = max(mi, (tmp-pretmp+2)/2); if(j == k-1) &#123; mi = max(mi, (tmp-pretmp+2)/2); mi = max(mi, n-tmp+1); &#125; &#125; printf("%d\n", mi); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 30 Substring with Concatenation of All Words]]></title>
    <url>%2F2018%2F02%2F05%2Fleetcode30%2F</url>
    <content type="text"><![CDATA[You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters. For example, given: s: &quot;barfoothefoobarman&quot; words: [&quot;foo&quot;, &quot;bar&quot;] You should return the indices: [0,9]. (order does not matter). 利用滑动窗口搜索的方式 计算每个word在words中出现的次数 设置窗口，l为窗口左端点，r为窗口右端点，左闭右开，window记录窗口中每个单词的数量wordmap 从0~len(word)-1开始枚举左端点的起点 扩展窗口，r不断的右移一个len(word) 如果当前最右边的单词不在words中，则清理窗口 l = r 如果在，window[word] += 1 window[word] &lt; wordmap[word]继续扩展 window[word] == wordmap[word]检查是不是一个解，即r-l == len(word)*len(words) window[word] &gt; wordmap[word]进入步骤2 收缩窗口，l不断右移一个len(word)，window[l] -= 1，检查window[s[r-len:r]] == wordmap[s[r-len:r]] 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution: def findSubstring(self, s, words): """ :type s: str :type words: List[str] :rtype: List[int] """ wordmap = &#123;&#125; res = [] if s == None or len(words) == 0: return res wordLen = len(words[0]) for word in words: if wordmap.__contains__(word): wordmap[word] += 1 else: wordmap[word] = 1 for i in range(wordLen): window = &#123;&#125; l = r = i while r &lt; len(s): while r &lt; len(s): word = s[r:r+wordLen] r += wordLen if word not in words: window = &#123;&#125; l = r else: if window.__contains__(word): window[word] += 1 else: window[word] = 1 if window[word] &gt;= wordmap[word]: break while l &lt; r: word = s[r-wordLen: r] if window[word] == wordmap[word]: break tmpWord = s[l : l+wordLen] window[tmpWord] -= 1 l += wordLen if r-l == wordLen*len(words): res.append(l) return res]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git介绍以及基本命令]]></title>
    <url>%2F2018%2F02%2F01%2Fgit%2F</url>
    <content type="text"><![CDATA[介绍git的结构、作用以及基本常用命令 一、git简介git是目前最流行、最好用的分布式版本控制系统，主要的作用就是帮助进行版本控制以及分布式的分支管理。其基本结构如下 其中橙色的部分都在我们自己的计算机上，蓝色的是远程仓库，比如github、gitosc等等 图中几个部分的含义 Workspace：工作区，就是电脑里的一个目录，一般带有.git文件 Stage/Index：暂存区位于工作区目录里的一个.git隐藏目录中，里面存储这个项目的master分支和HEAD指针 Repository：本地仓库，用于与远程仓库同步 Remote：远程仓库 ​ 下面将会把主要的过程的命令一一展示，建议分支部分可以阅读官方文档进行学习 git中文文档 二、新建与配置123456789101112131415# 在当前目录新建一个Git代码库$ git init [project-name]# 克隆$ git clone [url]# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name "[name]"$ git config [--global] user.email "[email address]" 三、往暂存区add/rm/mv123456789101112131415# 添加所有/目录/文件到暂存区$ git add [.]/[dir]/[file1] [file2] ...# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、向本地仓库commit123456789101112131415# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区(显示变动)$ git commit [-a|-v]# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、向远程仓库push/pull/fetch/remote1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [name]# 增加一个新的目标远程仓库，并命名为name$ git remote add [name] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库，不指定默认master$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 六、分支branch官方文档 123456789101112131415161718192021222324252627282930313233343536# 列出本地、远程、所有分支，带*号的是当前分支$ git branch [-r|-a]# 创建[并切换]到该分支$ git checkout [-b] [branch]# 新建一个分支(指向指定commit)$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# push分支到远程仓库(默认是master)$ git push origin [branch]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 七、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 八、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat "@&#123;0 day ago&#125;"# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 九、撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 参考：git中文文档 阮一峰的网络日志廖雪峰的git教程]]></content>
      <categories>
        <category>实战技能</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown常用语法总结]]></title>
    <url>%2F2018%2F01%2F27%2Fmarkdown_conclusion%2F</url>
    <content type="text"><![CDATA[Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。[4]这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。 个人使用markdown编写博客的编辑器是Typora，它不像传统编辑器那样并排展示，而是一个即时渲染的编辑器，所见即所得，让习惯word编辑的人编辑markdown更加的方便。至于好不好用就见仁见智了。毕竟有的人喜欢Jetbrain，而有的人以用Vim为荣。 换行在行尾添加两个空格加回车表示换行： 如果使用Typora则不用担心此问题，换行时会自动加两个空格 标题1、用#标记 在 标题开头 #，加几个就代表是几级标题 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 2、用=和-标记 在 标题底下 加上任意个=代表一级标题，-代表二级标题 12345一级标题======二级标题------ 效果： 一级标题二级标题三级标题四级标题五级标题六级标题 ###### 列表无序列表 *后面加一个空格： 123* 无序列表项目* 无序列表项目* 无序列表项目 效果（-和+是一样的）： 无序列表项目 无序列表项目 无序列表项目 有序列表则 数字加英文句点.： 1231. 有序列表项12. 有序列表项23. 有序列表项3 效果如下： 有序列表项1 有序列表项2 有序列表项3 代码代码分为行内代码和代码块。 行内代码使用 一个`符号标识 ，可嵌入文字中 代码块使用```标识（还有一种4个空格的不推荐，会和缩进弄混） ```这里是代码``` 代码语法高亮在 ```后面加上 空格和语言名称即可 ``` 语言这里是代码``` 例如： `这是一段高亮代码` ``` c++ long long multi(long long a, long long b, long long mod){ long long ret = 1;while(b &gt; 0){​ if(b &amp; 1)​ ret = (reta)%mod;​ a = (a a) % mod;​ b /= 2;}return ret; }//pow(a, b) mod m ``` 效果: 这是一段高亮代码 123456789101112long long multi(long long a, long long b, long long mod)&#123; long long ret = 1; while(b &gt; 0) &#123; if(b &amp; 1) ret = (ret*a)%mod; a = (a * a) % mod; b /= 2; &#125; return ret;&#125;//pow(a, b) mod m 分隔线在一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。 12345***---___* * * 效果均为一条分割线： 引用引用以&gt;加空格来表示，引用中支持多级引用，引用中的常用语法不会受到影响。 常见的引用写法： 12345&gt; 这是一段引用&gt; 一级引用&gt; &gt; 二级引用&gt; &gt; &gt; 三级引用 效果： 这是一段引用 一级引用 二级引用 三级引用 强调两个*或-代表加粗，一个*或-代表斜体，~~已删除的横线。 12345**加粗** or __加粗__*斜体* or _斜体_~~横线~~ 效果： 加粗 or 加粗 斜体 or _斜体_ 横线 图片&amp;链接图片有一个 ! 号，链接没有，而在Typora中可以直接插入图片： 12图片：![image description](url) 链接：[link description](url) 链接以及图片又分为行内式、参考式和 自动链接 上面的格式就是行内式。一般我使用行内式，使用参考室只是方便更新图片： 123456链接行内式：[Ph0en1x Notebook](https://ph0en1xgseek.github.io/)。自动链接：&lt;https://ph0en1xgseek.github.io/&gt;图片参考式：![typora][1][1]: https://typora.io/img/new/lists.png 效果如下： 链接行内式：Ph0en1x Notebook。 自动链接：https://ph0en1xgseek.github.io/ 图片参考式：![typora][1][1]: https://typora.io/img/new/lists.png 表格表格对齐格式，Typora中也可以直接插入表格 左对齐：:---- 中线对齐：:----:或----- 右对齐：----: 例子： 123456|标题|标题|标题||:---|:---:|---:||左对齐|中线对齐|右对齐||左对齐|中线对齐|右对齐||左对齐|中线对齐|右对齐||左对齐|中线对齐|右对齐| 效果： 标题 标题 标题 左对齐 中线对齐 右对齐 左对齐 中线对齐 右对齐 左对齐 中线对齐 右对齐 左对齐 中线对齐 右对齐 脚注[^]来定义脚注： 123Ph0en1x Notebook[^1][^1]: https://ph0en1xgseek.github.io/ 效果： Ph0en1x Notebook^1]]></content>
      <categories>
        <category>实战技能</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforce 915A Garden]]></title>
    <url>%2F2018%2F01%2F26%2Fcodeforce915A%2F</url>
    <content type="text"><![CDATA[Luba thinks about watering her garden. The garden can be represented as a segment of length k. Luba has got n buckets, the i-th bucket allows her to water some continuous subsegment of garden of length exactly a**i each hour. Luba can’t water any parts of the garden that were already watered, also she can’t water the ground outside the garden. Luba has to choose one of the buckets in order to water the garden as fast as possible (as mentioned above, each hour she will water some continuous subsegment of length a**i if she chooses the i-th bucket). Help her to determine the minimum number of hours she has to spend watering the garden. It is guaranteed that Luba can always choose a bucket so it is possible water the garden. See the examples for better understanding. Input The first line of input contains two integer numbers n and k (1 ≤ n, k ≤ 100) — the number of buckets and the length of the garden, respectively. The second line of input contains n integer numbers a**i (1 ≤ a**i ≤ 100) — the length of the segment that can be watered by the i-th bucket in one hour. It is guaranteed that there is at least one bucket such that it is possible to water the garden in integer number of hours using only this bucket. Output Print one integer number — the minimum number of hours required to water the garden. Examples input 123 62 3 5 output 12 input 126 71 2 3 4 5 6 output 17 Note In the first test the best option is to choose the bucket that allows to water the segment of length 3. We can’t choose the bucket that allows to water the segment of length 5 because then we can’t water the whole garden. In the second test we can choose only the bucket that allows us to water the segment of length 1. C++ Code 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int n, k; int tmp; int mi; while(~scanf("%d%d", &amp;n, &amp;k)) &#123; mi = 1000; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tmp); if(k % tmp == 0) &#123; mi = min(k / tmp, mi); &#125; &#125; printf("%d\n", mi); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforce 915C Permute Digits]]></title>
    <url>%2F2018%2F01%2F26%2Fcodeforce915C%2F</url>
    <content type="text"><![CDATA[You are given two positive integer numbers a and b. Permute (change order) of the digits of a to construct maximal number not exceeding b. No number in input and/or output can start with the digit 0. It is allowed to leave a as it is. Input The first line contains integer a (1 ≤ a ≤ 1018). The second line contains integer b (1 ≤ b ≤ 1018). Numbers don’t have leading zeroes. It is guaranteed that answer exists. Output Print the maximum possible number that is a permutation of digits of a and is not greater than b. The answer can’t have any leading zeroes. It is guaranteed that the answer exists. Examples input 12123222 output 1213 input 12392110000 output 19321 input 1249405000 output 14940 b一定不短于a 如果b比a长，直接降序排列a 如果一样长 先统计a中数字的个数 对于每一位b，都找不比b大的匹配，一旦有一位匹配后小于b的那位，之后就可以从最大的开始降序匹配 如果有一位无法匹配小于等于b的那位，那么就回退一位，匹配小于b的，这样后面就可以不受约束 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;iomanip&gt;using namespace std;bool cmp(char a, char b)&#123; return a &gt; b;&#125;int main()&#123; char str1[20]; char str2[20]; char tmp; int arr[15]; while(~scanf("%s", str1)) &#123; memset(arr, 0, sizeof(arr)); getchar(); scanf("%s", str2); getchar(); int len1 = strlen(str1); int len2 = strlen(str2); if(len2 &gt; len1) &#123; sort(str1, str1+len1, cmp); &#125; else &#123; bool flag = false; for(int i = 0; i &lt; len1; i++) &#123; arr[str1[i] - '0']++; str1[i] = str2[i]; &#125; for(int i = 0; i &lt; len2; i++) &#123; int j; if(flag == false) j = str1[i] - '0'; else j = 9; for(; j &gt;= 0; j--) &#123; if(arr[j] &gt; 0) &#123; arr[j]--; str1[i] = j+'0'; if(j &lt; str2[i] - '0') flag = true; break; &#125; &#125; if(j == -1 &amp;&amp; flag == false) &#123; i--; arr[str1[i]-'0']++; str1[i]--; i--; &#125; &#125; &#125; printf("%s\n", str1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforce 915B Browser]]></title>
    <url>%2F2018%2F01%2F26%2Fcodeforce915B%2F</url>
    <content type="text"><![CDATA[Luba is surfing the Internet. She currently has n opened tabs in her browser, indexed from 1 to n from left to right. The mouse cursor is currently located at the pos-th tab. Luba needs to use the tabs with indices from l to r (inclusive) for her studies, and she wants to close all the tabs that don’t belong to this segment as fast as possible. Each second Luba can either try moving the cursor to the left or to the right (if the cursor is currently at the tab i, then she can move it to the tab max(i - 1, a) or to the tab min(i + 1, b)) or try closing all the tabs to the left or to the right of the cursor (if the cursor is currently at the tab i, she can close all the tabs with indices from segment [a, i - 1] or from segment [i + 1, b]). In the aforementioned expressions a and b denote the minimum and maximum index of an unclosed tab, respectively. For example, if there were 7 tabs initially and tabs 1, 2and 7 are closed, then a = 3, b = 6. What is the minimum number of seconds Luba has to spend in order to leave only the tabs with initial indices from l to r inclusiveopened? Input The only line of input contains four integer numbers n, pos, l, r (1 ≤ n ≤ 100, 1 ≤ pos ≤ n, 1 ≤ l ≤ r ≤ n) — the number of the tabs, the cursor position and the segment which Luba needs to leave opened. Output Print one integer equal to the minimum number of seconds required to close all the tabs outside the segment [l, r]. Examples input 16 3 2 4 output 15 input 16 3 1 3 output 11 input 15 2 1 5 output 10 Note In the first test Luba can do the following operations: shift the mouse cursor to the tab 2, close all the tabs to the left of it, shift the mouse cursor to the tab 3, then to the tab 4, and then close all the tabs to the right of it. In the second test she only needs to close all the tabs to the right of the current position of the cursor. In the third test Luba doesn’t need to do anything. 不要漏考虑情况 左右贴边 左贴边 pos在r右边 pos在r左边 右贴边 pos在l右边 pos在l左边 都不贴边 pos在l左边 pos在r右边 pos在l和r中间 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int n, pos, l, r; while(~scanf("%d%d%d%d", &amp;n, &amp;pos, &amp;l, &amp;r)) &#123; if(l == 1 &amp;&amp; r == n) &#123; printf("0\n"); &#125; else if(l == 1) &#123; if(pos &gt; r) &#123; printf("%d\n", pos-r+1); &#125; else &#123; printf("%d\n", r-pos+1); &#125; &#125; else if(r == n) &#123; if(pos &lt; l) &#123; printf("%d\n", l-pos+1); &#125; else &#123; printf("%d\n", pos-l+1); &#125; &#125; else &#123; if(pos &gt; r) &#123; printf("%d\n", pos-l+2); &#125; else if(pos &lt; l) &#123; printf("%d\n", r-pos+2); &#125; else &#123; printf("%d\n", (r-l) + 2 + min(r-pos, pos-l)); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>codeforce</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 25 Reverse Nodes in k-Group]]></title>
    <url>%2F2018%2F01%2F25%2Fleetcode25%2F</url>
    <content type="text"><![CDATA[Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. For example,Given this linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5 For k = 2, you should return: 2-&gt;1-&gt;4-&gt;3-&gt;5 For k = 3, you should return: 3-&gt;2-&gt;1-&gt;4-&gt;5 Leetcode 24的扩展版，k个一组进行翻转，最后不到k个的不翻转 没轮一共翻转k-1次，每次都将后一个node连到已经连好的链的最前面，已经连好的链首节点之前的一个节点和尾节点两个节点标记为root、head Python Code 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseKGroup(self, head, k): """ :type head: ListNode :type k: int :rtype: ListNode """ res = root = ListNode(-1) root.next = head tmp = head cnt = 0 while(tmp != None): tmp = tmp.next cnt += 1 while(cnt &gt;= k): for i in range(k-1): node = root.next root.next = head.next head.next = root.next.next root.next.next = node root = head head = head.next cnt -= k return res.next]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 29 Divide Two Integers]]></title>
    <url>%2F2018%2F01%2F25%2Fleetcode29%2F</url>
    <content type="text"><![CDATA[Divide two integers without using multiplication, division and mod operator. If it is overflow, return MAX_INT. overflow特殊情况：-2147483648 / (-1) = MAX_INT = 2147483647 12345678910111213141516171819202122232425class Solution: def divide(self, dividend, divisor): """ :type dividend: int :type divisor: int :rtype: int """ if dividend == -2147483648 and divisor == -1: return 2147483647 a = abs(dividend) b = abs(divisor) arr = [] while(b &lt;= a): arr.append(b) b &lt;&lt;= 1 sum = 0 ret = 0 for i in range(len(arr)-1, -1, -1): if sum + arr[i] &lt;= a: sum += arr[i] ret += (1&lt;&lt;i) if(((dividend &gt; 0) and (divisor &lt; 0)) or ((dividend &lt; 0) and (divisor &gt; 0))): return -ret else: return ret]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下配置Git免密码]]></title>
    <url>%2F2018%2F01%2F24%2Fgit_password%2F</url>
    <content type="text"><![CDATA[本篇文章将会介绍如何在Linux下配置使Git在push/pull时免密码 操作步聚： 进入当前用户目录下； 创建并打开.git-credentials 按照以下格式输入内容： 1 https://&#123;username&#125;：&#123;password&#125;@github.com 其中username，password，github.com 都替换成你自己的内容 保存退出后执行 1git config --global credential.helper store 执行完后 /home/用户名/.gitconfig 会新增一项 helper = store 这时再执行git push/pull的时候就不会在要求你输入密码了。]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 23 Merge k Sorted Lists]]></title>
    <url>%2F2018%2F01%2F24%2Fleetcode23%2F</url>
    <content type="text"><![CDATA[Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype: ListNode """ heap = [] i = 0 for node in lists: if node != None: heap.append((node.val, i, node)) i += 1 heapq.heapify(heap) cur = head = ListNode(0) while heap: pop = heapq.heappop(heap) cur.next = ListNode(pop[0]) cur = cur.next if pop[2].next != None: heapq.heappush(heap, (pop[2].next.val, i, pop[2].next)) i += 1 return head.next]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux提升物理内存的使用率]]></title>
    <url>%2F2018%2F01%2F24%2Fubuntu_improve%2F</url>
    <content type="text"><![CDATA[介绍如何在Linux下调整交换分区swap的使用条件 在UBUNTU系统里面，并不是你的物理内存全部耗尽之后，系统才使用swap分区！系统的swappiness设定值，对如何使用swap分区是有着很大的联系。 swappiness=0 的时候表示最大限度使用物理内存，然后才是 swap空间swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面 上面2个设置是极端设置，对于UBUNTU系统的默热值来说，这个值=60，如果想最佳化，可以修改为10-20左右！ 在ubuntu17以后移除了交换分区这一概念，改为交换文件 打开终端，输入查看 swappiness 的当前参数（默认应该看到的是60） 1cat /proc/sys/vm/swappiness 输入下面内容，修改这个参数为10（执行这一步只是临时修改，如果重启又会恢复60） 1sudo sysctl vm.swappiness=10 若要持久化配置，可以打开/etc/sysctl.conf文件 1sudo gedit /etc/sysctl.conf 添加一行 1vm.swappiness=10 ​]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 10 Regular Expression Matching]]></title>
    <url>%2F2018%2F01%2F23%2Fleetcode10%2F</url>
    <content type="text"><![CDATA[动态规划 Implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;. 123456789101112131415161718&gt; &apos;.&apos; Matches any single character.&gt; &apos;*&apos; Matches zero or more of the preceding element.&gt;&gt; The matching should cover the entire input string (not partial).&gt;&gt; The function prototype should be:&gt; bool isMatch(const char *s, const char *p)&gt;&gt; Some examples:&gt; isMatch(&quot;aa&quot;,&quot;a&quot;) → false&gt; isMatch(&quot;aa&quot;,&quot;aa&quot;) → true&gt; isMatch(&quot;aaa&quot;,&quot;aa&quot;) → false&gt; isMatch(&quot;aa&quot;, &quot;a*&quot;) → true&gt; isMatch(&quot;aa&quot;, &quot;.*&quot;) → true&gt; isMatch(&quot;ab&quot;, &quot;.*&quot;) → true&gt; isMatch(&quot;aab&quot;, &quot;c*a*b&quot;) → true&gt;&gt; 动态规划问题dp[i][j]代表s[i]之前（不算i）与p[j]之前的字符串是否能够匹配 初始化： dp[0][0] = true dp[i][0] = false when i &gt;= 1 dp[0][j] = j &gt; 1 &amp;&amp; p[j-1] == &#39;*&#39; &amp;&amp; dp[0][j-2] 即只有都可以用*来代替掉的情况才能是true 两种更新情况： p[j-1] == &#39;*&#39; dp[i][j] = dp[i][j - 2] // i与j-2可以匹配的情况下，这个*代表0次 dp[i][j] = (s[i - 1] == p[j - 2] || p[j - 2] == &#39;.&#39;) &amp;&amp; dp[i - 1][j] // 在i-1 与 j可以匹配的情况下 这个*代表一次或多次 p[j-1] != &#39;*&#39; dp[i][j] = (p[j - 1] == &#39;.&#39; || s[i - 1] == p[j - 1]) &amp;&amp; dp[i - 1][j - 1] //在i-1与j-1可以匹配的情况下 i 与 j 能够匹配 由于这题Python直接就有函数可以解决，所以改用C++来练习 C++ Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: bool isMatch(string s, string p) &#123; int lens = s.length(); int lenp = p.length(); bool **dp = new bool *[lens+1]; for(int i = 0; i &lt;= lens; i++) dp[i] = new bool [lenp+1]; bool res = false; dp[0][0] = true; for(int i = 1; i &lt;= lens; i++) &#123; dp[i][0] = false; &#125; for(int j = 1; j &lt;= lenp; j++) &#123; if(j &gt; 1 &amp;&amp; p[j-1] == '*' &amp;&amp; dp[0][j-2]) dp[0][j] = true; else dp[0][j] = false; &#125; for(int i = 1; i &lt;= lens; i++) &#123; for(int j = 1; j &lt;= lenp; j++) &#123; if(p[j-1] == '*') &#123; dp[i][j] = dp[i][j-2] || ((s[i-1] == p[j-2] || p[j-2] == '.') &amp;&amp; dp[i-1][j]); &#125; else &#123; dp[i][j] = dp[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == '.'); &#125; &#125; &#125; res = dp[lens][lenp]; for(int i = 0; i &lt;= lens; i++) delete [] dp[i]; delete [] dp; return res; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 15 3Sum]]></title>
    <url>%2F2018%2F01%2F20%2Fleetcode15%2F</url>
    <content type="text"><![CDATA[T Sum问题的O(n)解决方法； N Sum类的问题的一般解决方法； Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. 123456789&gt; For example, given array S = [-1, 0, 1, 2, -1, -4],&gt;&gt; A solution set is:&gt; [&gt; [-1, 0, 1],&gt; [-1, -1, 2]&gt; ]&gt;&gt; Two sum类问题，找两个数的和为一个定值的问题，如果直接使用二分查找，排序+查找或者在有序数组中直接查找的复杂度都是O(nlogn)，有的题卡复杂度的就过不去 Two Sum问题的一般做法对无序数组进行排序后（若数组已经是有序的化则不需要排序），设置两个指针left、right指向数组的首尾，target是要查找的目标 如果arr[left] + arr[right] == target，查找到了 如果arr[left] + arr[right] &gt; target，按照遍历的方式right往左移，right -= 1 如果arr[left] + arr[right] &lt; target，很显然right不需要再往左移动了，直接进入下一轮迭代，即left += 1，right不动 right不用像遍历一样回到最右边吗？不用。因为现在的arr[left]与right右边的数相加都是大于target的（不然right不会向左移），那么left再向右移动arr[left]只会更大，right也就不用再回到右边了 最后注意下重复数字答案重复的问题 Two Sum问题的这种解决方法排序+查找复杂度依然是O(nlogn)，但是主要是因为排序的消耗。如果题目已经给了有序的数列，那么复杂度将会降为O(n) N Sum 问题 对前几位进行遍历，对最后两维做Two Sum Python Code 1234567891011121314151617181920212223242526272829303132class Solution(object): def threeSum(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ ans = [] if len(nums) &lt; 3: return [] nums.sort() for i in range(len(nums) - 2): if nums[i] &gt; 0: break if i &gt; 0 and nums[i] == nums[i-1]: continue l = i+1 r = len(nums)-1 while l &lt; r: if nums[i] + nums[l] + nums[r] &gt; 0: r -= 1 elif nums[i] + nums[l] + nums[r] &lt; 0: l += 1 else: ans.append([nums[i], nums[l], nums[r]]) l += 1 while l &lt; r and nums[l] == nums[l-1]: l += 1 r -= 1 while l &lt; r and nums[r] == nums[r+1]: r -= 1 return ans]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 24 Swap Nodes in Pairs]]></title>
    <url>%2F2018%2F01%2F20%2Fleetcode24%2F</url>
    <content type="text"><![CDATA[Given a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. Python Code 123456789101112131415161718192021222324252627282930# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def swapPairs(self, head): """ :type head: ListNode :rtype: ListNode """ if head == None or head.next == None: return head ret = head.next i = head j = head.next pre = None while j != None: i.next = j.next j.next = i if pre != None: pre.next = j if i.next != None: pre = i i = i.next j = i.next else: break return ret]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow 共享变量理解]]></title>
    <url>%2F2018%2F01%2F19%2Ftensorflow_variable%2F</url>
    <content type="text"><![CDATA[本文主要通过一些例子介绍tensorflow中两种变量的声明方式和两种scope 参考概述: https://www.tensorflow.org/programmers_guide/variables tf.Variable(): https://www.tensorflow.org/api_docs/python/tf/Variable tf.get_variable(): https://www.tensorflow.org/api_docs/python/tf/get_variable tf.variable_scope(): https://www.tensorflow.org/api_docs/python/tf/variable_scope tf.name_scope(): https://www.tensorflow.org/api_docs/python/tf/name_scope 简介本文主要通过一些例子介绍tensorflow中两种变量的声明方式 tf.Variable() tf.get_variable() 以及两种scope: tf.name_scope() tf.variable_scope() tf.name_scope() 和 tf.variable_scope() 例子1 1234567891011import tensorflow as tfwith tf.name_scope("Ph0en1x_name_scope"): initializer = tf.constant_initializer(value=1) var1 = tf.get_variable(name='var1', shape=[1], dtype=tf.float32, initializer=initializer) var2 = tf.Variable(name='var2', initial_value=[2], dtype=tf.float32) var3 = var2*2 with tf.Session() as sess: sess.run(tf.initialize_all_variables()) print(var1.name) print(var2.name) 输出1 123var1:0Ph0en1x_name_scope/var2:0Ph0en1x_name_scope/mul 可以看出使用tf.Variable()创建的变量和算子op受到name_scope的控制，而使用tf.get_variable()的则不会 ​ 例子2 1234567891011import tensorflow as tfwith tf.variable_scope("Ph0en1x_variable_scope"): initializer = tf.constant_initializer(value=1) var1 = tf.get_variable(name='var1', shape=[1], dtype=tf.float32, initializer=initializer) var2 = tf.Variable(name='var2', initial_value=[2], dtype=tf.float32) var3 = var2*2 with tf.Session() as sess: sess.run(tf.initialize_all_variables()) print(var1.name) print(var2.name) 输出2 123Ph0en1x_variable_scope/var1:0Ph0en1x_variable_scope/var2:0Ph0en1x_variable_scope/mul:0 如果使用variable_scope 则都会受到控制 tf.Variable() 和 tf.get_variable() 例子3 12345678910import tensorflow as tfwith tf.variable_scope("Ph0en1x_variable_scope"): initializer = tf.constant_initializer(value=1) var1 = tf.Variable(name='var1', initial_value=[2], dtype=tf.float32) var1_1 = tf.Variable(name='var1', initial_value=[2], dtype=tf.float32) with tf.Session() as sess: sess.run(tf.initialize_all_variables()) print(var1.name) print(var1_1.name) 输出3 12Ph0en1x_variable_scope/var1:0Ph0en1x_variable_scope/var1_1:0 当在同一个scope中使用tf.Variable()声明同名的变量时，tensorflow会自动将其重命名，但是， 例子4 1234567891011import tensorflow as tfwith tf.variable_scope("Ph0en1x_variable_scope"): initializer = tf.constant_initializer(value=1) var2 = tf.get_variable(name='var2', shape=[1], dtype=tf.float32, initializer=initializer) var2_2 = tf.get_variable(name='var2', shape=[1], dtype=tf.float32, initializer=initializer) with tf.Session() as sess: sess.run(tf.initialize_all_variables()) print(var2.name) print(var2_2.name) 结果4 1ValueError: Variable Ph0en1x_variable_scope/var2 already exists, disallowed. Did you mean to set reuse=True or reuse=tf.AUTO_REUSE in VarScope? Originally defined at: 使用tf.get_variable()时则没有自动重命名，而是直接抛出异常，询问是否想要把reuse值设为True reuse参数通过tf.get_variable() tf.variable_scope() 以及reuse参数的配合使用，就可以使用共享变量。 为什么要用共享变量？​ 举一个栗子，当我们搭建对抗生成网络进行判别器的训练的时候，对判别器是有真实图像和生成图像两组输入的，即 判别器定义 12345678910def get_discriminator(img, n_units, reuse=False, alpha=0.01): with tf.variable_scope('discriminator', reuse=reuse): hidden1 = tf.layers.dense(img, n_units) hidden1 = tf.maximum(alpha*hidden1, hidden1) logits = tf.layers.dense(hidden1, 1) outputs = tf.sigmoid(logits) return logits, outputs 判别器实例 12d_logits_real, d_outputs_real = get_discriminator(real_img, d_units)d_logits_fake, d_outputs_fake = get_discriminator(g_outputs, d_units, reuse=True) 两组图像使用的都是同一组判别器的变量，但是他们分两次调用get_discriminator()时，如果不将reuse设置成为True,显然就会产生上面出现的异常。 例子5 123456import tensorflow as tfwith tf.variable_scope("foo"): v = tf.get_variable("var", [1])with tf.variable_scope("foo", reuse=True): v1 = tf.get_variable("var", [1])print(v1 is v) 或 12345with tf.variable_scope("foo"): v = tf.get_variable("var", [1]) tf.get_variable_scope().reuse_variables() v1 = tf.get_variable("var", [1])print(v1 is v) 结果5 1True 但是一旦设置为True，就无法再次修改回去]]></content>
      <categories>
        <category>tensorflow</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5802 Windows 10]]></title>
    <url>%2F2018%2F01%2F14%2Fhdu5802%2F</url>
    <content type="text"><![CDATA[Problem Description Long long ago, there was an old monk living on the top of a mountain. Recently, our old monk found the operating system of his computer was updating to windows 10 automatically and he even can’t just stop it !!With a peaceful heart, the old monk gradually accepted this reality because his favorite comic LoveLive doesn’t depend on the OS. Today, like the past day, he opens bilibili and wants to watch it again. But he observes that the voice of his computer can be represented as dB and always be integer.Because he is old, he always needs 1 second to press a button. He found that if he wants to take up the voice, he only can add 1 dB in each second by pressing the up button. But when he wants to take down the voice, he can press the down button, and if the last second he presses the down button and the voice decrease x dB, then in this second, it will decrease 2 * x dB. But if the last second he chooses to have a rest or press the up button, in this second he can only decrease the voice by 1 dB.Now, he wonders the minimal seconds he should take to adjust the voice from p dB to q dB. Please be careful, because of some strange reasons, the voice of his computer can larger than any dB but can’t be less than 0 dB. Input First line contains a number T (1≤T≤300000),cases number.Next T line,each line contains two numbers p and q (0≤p,q≤109) Output The minimal seconds he should take Sample Input 12321 57 3 Sample Output 1244 Code 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;using namespace std;int p, q;int dfs(int cur, int step, int stop)///现在位置，已走步数，停顿次数&#123; int cnt = 0; while(cur - (1&lt;&lt;cnt) + 1 &gt; q) cnt++; step += cnt; if(cur - (1&lt;&lt;cnt) + 1 == q) return step; int up = q - max(0, cur - (1&lt;&lt;cnt) + 1);///需要往回走多少步 int tmp = step + max(up-stop, 0);///通过把之前的停顿换成向上一步来减少之后向上的步数 return min(tmp, dfs(cur - (1&lt;&lt;(cnt-1))+1, step, stop + 1));&#125;int main()&#123; int ca; int ans; scanf("%d", &amp;ca); while(ca--) &#123; scanf("%d%d", &amp;p, &amp;q); if(p &lt;= q) ans = q - p; else ans = dfs(p, 0, 0); printf("%d\n", ans); &#125; return 0;&#125; ​]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5754 Life Winner Bo]]></title>
    <url>%2F2018%2F01%2F14%2Fhdu5754%2F</url>
    <content type="text"><![CDATA[Problem Description Bo is a “Life Winner”.He likes playing chessboard games with his girlfriend G.The size of the chessboard is N×M.The top left corner is numbered(1,1) and the lower right corner is numberd (N,M).For each game,Bo and G take turns moving a chesspiece(Bo first).At first,the chesspiece is located at (1,1).And the winner is the person who first moves the chesspiece to (N,M).At one point,if the chess can’t be moved and it isn’t located at (N,M),they end in a draw.In general,the chesspiece can only be moved right or down.Formally,suppose it is located at (x,y),it can be moved to the next point (x′,y′) only if x′≥x and y′≥y.Also it can’t be moved to the outside of chessboard.Besides,There are four kinds of chess(They have movement rules respectively).1.king.2.rook(castle).3.knight.4.queen.(The movement rule is as same as the chess.)For each type of chess,you should find out that who will win the game if they both play in an optimal strategy.Print the winner’s name(“B” or “G”) or “D” if nobody wins the game. Input In the first line,there is a number T as a case number.In the next T lines,there are three numbers type,N and M.“type” means the kind of the chess.T≤1000,2≤N,M≤1000,1≤type≤4 Output For each question,print the answer. Sample Input 1234541 5 52 5 53 5 54 5 5 Sample Output 1234GGDB Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;int dp1[1005][1005];int dp3[1005][1005];int dp4[1005][1005];void init()&#123; for(int i = 0; i &lt;= 1000; i++) &#123; dp1[i][1001] = dp1[1001][i] = 1; dp3[i][1000] = dp3[1000][i] = 3; dp3[i][1001] = dp3[1001][i] = 1; dp4[i][i] = dp4[i][1000] = dp4[1000][i] = 1; dp4[i][1001] = dp4[1001][i] = 1; &#125; dp3[1000][1000] = 0; dp3[999][999] = 3; dp1[1000][1000] = dp4[1000][1000] = 0; dp1[1001][1001] = dp4[1001][1001] = 1; for(int i = 1000; i &gt;= 0; i--) &#123; for(int j = 1000; j &gt;= 0; j--) &#123; if(dp1[i+1][j] == 1 &amp;&amp; (dp1[i][j+1] == 1 &amp;&amp; dp1[i+1][j+1] == 1)) dp1[i][j] = 0; else dp1[i][j] = 1; &#125; &#125; for(int i = 999; i &gt;= 0; i--) &#123; for(int j = 999; j &gt;= 0; j--) &#123; if(i == 999 &amp;&amp; j == 999)&#123;&#125; else if((i == 999 || dp3[i+2][j+1] == 1) &amp;&amp; (j == 999 || dp3[i+1][j+2] == 1)) dp3[i][j] = 0; else if(dp3[i+2][j+1] == 0 || dp3[i+1][j+2] == 0) dp3[i][j] = 1; else dp3[i][j] = 3; if(dp4[i][j]) continue; if(!dp4[i][j]) &#123; for(int ii = i - 1; ii &gt;= 0; ii--) dp4[ii][j] = 1; for(int ii = j - 1; ii &gt;= 0; ii--) dp4[i][ii] = 1; for(int ii = 1; i-ii &gt;= 0 &amp;&amp; j-ii &gt;= 0; ii++) dp4[i-ii][j-ii] = 1; &#125; &#125; &#125;&#125;int main()&#123; int ca; int t, n, m; memset(dp1, 0, sizeof(dp1)); memset(dp3, 0, sizeof(dp3)); memset(dp4, 0, sizeof(dp4)); init(); scanf("%d", &amp;ca); while(ca--) &#123; scanf("%d%d%d", &amp;t, &amp;n, &amp;m); if(t == 1) &#123; if(dp1[1000-n+1][1000-m+1]) printf("B\n"); else printf("G\n"); &#125; else if(t == 2) &#123; if((n-1) ^ (m-1)) printf("B\n"); else printf("G\n"); &#125; else if(t == 3) &#123; if(dp3[1000-n+1][1000-m+1] == 1) printf("B\n"); else if(dp3[1000-n+1][1000-m+1] == 0) printf("G\n"); else if(dp3[1000-n+1][1000-m+1] == 3) printf("D\n"); &#125; else &#123; if(dp4[1000-n+1][1000-m+1] == 1) printf("B\n"); else printf("G\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>hdu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse中Junit与Eclemma插件安装与使用]]></title>
    <url>%2F2018%2F01%2F03%2Fjunit%2F</url>
    <content type="text"><![CDATA[本篇文章将会介绍Eclipse中Junit与Eclemma插件安装与使用 完整代码 1.Install Junit and Eclemma 1.1. Install Junit Download necessary JARs packages Click right key on the project – Properties – Java Build Path – Libraries – Add External JARs Add Junit and harmcrest-all-* 1.2. Install Eclemma Help –- Install New Software –Add Input the name eclemma and the Location with http://update.eclemma.org. Select the eclemma and complete click Next Reboot the eclipse to complete the installation 2.Using Junit and eclemma Under src folder, create com.Triangle package Write Triangle.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081package com.Triangle;public class Triangle &#123; int a, b, c; public Triangle(int x, int y, int z)&#123; a = x; b = y; c = z; &#125; public String isPositive()&#123; String msg = ""; if(a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; c &gt; 0)&#123; msg = "positive"; &#125;else&#123; if(a &lt;= 0) msg += "a is negative"; if(b &lt;= 0) msg += "b is negative"; if(c &lt;= 0) msg += "c is negative"; &#125; //System.out.println(msg); return msg; &#125; public String isTriangle()&#123; String msg = ""; if(a+b &gt; c &amp;&amp; a+c &gt; b &amp;&amp; b+c &gt; a)&#123; msg = "triangle"; &#125;else&#123; msg = "not a triangle"; &#125; //System.out.println(msg); return msg; &#125; public String isIsosceles()&#123; String msg = ""; if(a == b || b == c || c == a)&#123; msg = "isosceles"; &#125;else&#123; msg = "not isosceles"; &#125; //System.out.println(msg); return msg; &#125; public String isEquilateral()&#123; String msg = ""; if(a == b &amp; b == c)&#123; msg = "equilateral"; &#125;else&#123; msg = "not equilateral"; &#125; //System.out.println(msg); return msg; &#125; public String judge()&#123; String msg = ""; msg = this.isPositive(); if(msg.equals("positive"))&#123; msg = this.isTriangle(); if(msg.equals("triangle"))&#123; msg = this.isIsosceles(); if(msg.equals("isosceles"))&#123; msg = this.isEquilateral(); if(!msg.equals("equilateral"))&#123; return "isosceles"; &#125; &#125;else&#123; return "triangle"; &#125; &#125; &#125; return msg; &#125;&#125; Create new source folder test and create com.Triangle package similarly Write several classes for test 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.Triangle;import static org.junit.Assert.*; import java.util.Arrays;import java.util.Collection;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters; import com.Triangle.Triangle;@RunWith(Parameterized.class)public class JudgeTest &#123; private int a; private int b; private int c; private String expected; private Triangle triangle; public JudgeTest(int a, int b, int c, String expected)&#123; this.a = a; this.b = b; this.c = c; this.expected = expected; &#125; @Before public void setUp()&#123; System.out.println("Before Judge Test"); this.triangle = new Triangle(this.a, this.b, this.c); &#125; @After public void tearDown()&#123; System.out.println("After Judge Test"); &#125; @Parameters public static Collection&lt;Object[]&gt; getData()&#123; return Arrays.asList(new Object[][]&#123; &#123;3,3,3,"equilateral"&#125;, &#123;3,4,3, "isosceles"&#125;, &#123;2,3,4, "triangle"&#125;, &#123;1,2,3, "not a triangle"&#125;, &#123;-1,1,2, "a is negative"&#125;, &#123;1,-2,1, "b is negative"&#125;, &#123;1,1,-2, "c is negative"&#125; &#125;); &#125; @Test public void testAdd()&#123; assertEquals(this.expected, triangle.judge()); &#125;&#125; In order to practice @Runwith(Suite.class), I also write some other test classes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.Triangle;import static org.junit.Assert.*; import java.util.Arrays;import java.util.Collection;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters; import com.Triangle.Triangle;@RunWith(Parameterized.class)public class PositiveTest &#123; private int a; private int b; private int c; private String expected; private Triangle triangle; public PositiveTest(int a, int b, int c, String expected)&#123; this.a = a; this.b = b; this.c = c; this.expected = expected; &#125; @Before public void setUp()&#123; System.out.println("Before Positive Test"); this.triangle = new Triangle(this.a, this.b, this.c); &#125; @After public void tearDown()&#123; System.out.println("After Positive Test"); &#125; @Parameters public static Collection&lt;Object[]&gt; getData()&#123; return Arrays.asList(new Object[][]&#123; &#123;3,3,3,"positive"&#125; &#125;); &#125; @Test public void testAdd()&#123; assertEquals(this.expected, triangle.isPositive()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.Triangle;import static org.junit.Assert.*; import java.util.Arrays;import java.util.Collection; import org.junit.Before;import org.junit.After;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters; import com.Triangle.Triangle;@RunWith(Parameterized.class)public class TriangleTest &#123; private int a; private int b; private int c; private String expected; private Triangle triangle; public TriangleTest(int a, int b, int c, String expected)&#123; this.a = a; this.b = b; this.c = c; this.expected = expected; &#125; @Before public void setUp()&#123; System.out.println("Before Triangle Test"); this.triangle = new Triangle(this.a, this.b, this.c); &#125; @After public void tearDown()&#123; System.out.println("After Triangle Test"); &#125; @Parameters public static Collection&lt;Object[]&gt; getData()&#123; return Arrays.asList(new Object[][]&#123; &#123;3,3,3,"triangle"&#125; &#125;); &#125; @Test public void testAdd()&#123; assertEquals(this.expected, triangle.isTriangle()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.Triangle;import static org.junit.Assert.*; import java.util.Arrays;import java.util.Collection;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters; import com.Triangle.Triangle;@RunWith(Parameterized.class)public class IsoscelesTest &#123; private int a; private int b; private int c; private String expected; private Triangle triangle; public IsoscelesTest(int a, int b, int c, String expected)&#123; this.a = a; this.b = b; this.c = c; this.expected = expected; &#125; @Before public void setUp()&#123; System.out.println("Before Isosceles Test"); this.triangle = new Triangle(this.a, this.b, this.c); &#125; @After public void tearDown()&#123; System.out.println("After Isosceles Test"); &#125; @Parameters public static Collection&lt;Object[]&gt; getData()&#123; return Arrays.asList(new Object[][]&#123; &#123;3,3,3,"isosceles"&#125; &#125;); &#125; @Test public void testAdd()&#123; assertEquals(this.expected, triangle.isIsosceles()); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.Triangle;import static org.junit.Assert.*; import java.util.Arrays;import java.util.Collection;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters; import com.Triangle.Triangle;@RunWith(Parameterized.class)public class EquilateralTest &#123; private int a; private int b; private int c; private String expected; private Triangle triangle; public EquilateralTest(int a, int b, int c, String expected)&#123; this.a = a; this.b = b; this.c = c; this.expected = expected; &#125; @Before public void setUp()&#123; System.out.println("Before Equilateral Test"); this.triangle = new Triangle(this.a, this.b, this.c); &#125; @After public void tearDown()&#123; System.out.println("After Equilateral Test"); &#125; @Parameters public static Collection&lt;Object[]&gt; getData()&#123; return Arrays.asList(new Object[][]&#123; &#123;3,3,3,"equilateral"&#125; &#125;); &#125; @Test public void testAdd()&#123; assertEquals(this.expected, triangle.isEquilateral()); &#125;&#125; SuiteTest.java 1234567891011package com.Triangle;import org.junit.runner.RunWith;import org.junit.runners.Suite;import org.junit.runners.Suite.SuiteClasses;@RunWith(Suite.class)@SuiteClasses(&#123; PositiveTest.class, TriangleTest.class , IsoscelesTest.class, EquilateralTest.class, JudgeTest.class&#125;)public class SuiteTest &#123;&#125; Result Click right key on SuiteTest.java -&gt; Coverage as -&gt; JUnit Test Except SuiteTest.java itself hasn’t been covered, other classes have been covered already. If run PositiveTest.java individually, there will be more paths that won’t be covered Green: All Covered Red: All Missed Yellow: Some Branches Missed]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
        <tag>软件测试</tag>
        <tag>Junit</tag>
        <tag>Eclemma</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium脚本的录制和导出]]></title>
    <url>%2F2018%2F01%2F02%2Fselenium%2F</url>
    <content type="text"><![CDATA[本篇文章将会介绍Eclipse中Junit与Eclemma插件安装与使用 完整代码 一、打开Selenium IDE附加组件 选择较老版本的Firefox浏览器到应用商店下载Selenium IDE，安装后打开如图所示： 配置Selenium WebDriver环境 向工程内导入如下的jar包（可以准备一个javacsv来辅助后面的实验） 录制脚本 使用Selenium IDE录制脚本后可以很方便的导出，可以直接在导出的代码上进行修改。 打开Selenium IDE 点击右上角的红点开始录制 进入网页输入账号密码登陆，其他网站类似 点击登录跳转后，选择页面内的github地址，右键选择assertText 再次点击红点完成录制 导出脚本 点击Optinons-&gt;Options，勾选Enable experimental features 通过Options–&gt;Format选择要导出成的相应格式。 选择Java / JUnit 4/ WebDriver 得到生成的Java文件，复制到工程中完成脚本导出 编写完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package com.WebDriveTest;import java.util.regex.Pattern;import java.io.IOException;import java.nio.charset.Charset;import java.util.Arrays;import java.util.Collection;import java.util.concurrent.TimeUnit;import org.junit.*;import org.junit.runner.RunWith;import org.junit.runners.Parameterized;import org.junit.runners.Parameterized.Parameters;import static org.junit.Assert.*;import static org.hamcrest.CoreMatchers.*;import org.openqa.selenium.*;import org.openqa.selenium.firefox.FirefoxDriver;import org.openqa.selenium.support.ui.Select;import com.csvreader.CsvReader;@RunWith(Parameterized.class)public class WebDriveTest &#123; private WebDriver driver; private String baseUrl; private boolean acceptNextAlert = true; private StringBuffer verificationErrors = new StringBuffer(); private String id, pwd,address; public WebDriveTest(String id, String address) &#123; this.id = id; this.pwd = id.substring(4); this.address = address; &#125; @Before public void setUp() throws Exception &#123; driver = new FirefoxDriver(); baseUrl = "http://121.193.130.195:8080"; driver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS); &#125; @Parameters public static Collection&lt;Object[]&gt; getData() throws IOException &#123; Object[][] obj = new Object[118][]; CsvReader r = new CsvReader("D:\\CIA\\大三下\\软测\\inputgit.csv", ',', Charset.forName("GBK")); int count = 0; r.readHeaders(); while(r.readRecord())&#123; obj[count] = new Object[]&#123;r.get(0), r.get(2)&#125;; count++; &#125; return Arrays.asList(obj); &#125; @Test public void testUntitled2() throws Exception &#123; driver.get(baseUrl + "/"); driver.findElement(By.id("name")).clear(); driver.findElement(By.id("name")).sendKeys(this.id); driver.findElement(By.id("pwd")).clear(); driver.findElement(By.id("pwd")).sendKeys(this.pwd); driver.findElement(By.id("submit")).click(); assertEquals(this.address, driver.findElement(By.xpath("//tbody[@id='table-main']/tr[3]/td[2]")).getText()); &#125; @After public void tearDown() throws Exception &#123; driver.quit(); String verificationErrorString = verificationErrors.toString(); if (!"".equals(verificationErrorString)) &#123; fail(verificationErrorString); &#125; &#125; private boolean isElementPresent(By by) &#123; try &#123; driver.findElement(by); return true; &#125; catch (NoSuchElementException e) &#123; return false; &#125; &#125; private boolean isAlertPresent() &#123; try &#123; driver.switchTo().alert(); return true; &#125; catch (NoAlertPresentException e) &#123; return false; &#125; &#125; private String closeAlertAndGetItsText() &#123; try &#123; Alert alert = driver.switchTo().alert(); String alertText = alert.getText(); if (acceptNextAlert) &#123; alert.accept(); &#125; else &#123; alert.dismiss(); &#125; return alertText; &#125; finally &#123; acceptNextAlert = true; &#125; &#125;&#125; 实验结果]]></content>
      <categories>
        <category>软件测试</category>
      </categories>
      <tags>
        <tag>软件测试</tag>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo快速搭建自己的博客]]></title>
    <url>%2F2018%2F01%2F01%2Fhexo%2F</url>
    <content type="text"><![CDATA[本篇文章将会介绍如何使用hexo来搭建静态页面博客，并套用目前最多人使用的NexT模版 一、需要准备的工具 Node.js Hexo使用node.js进行静态页面的生成，到 https://nodejs.org/zh-cn/ 下载当前最新的node.js进行安装 hexo hexo官网：https://hexo.io/ 上面有非常完整的文档 安装node.js完成后在控制台应该就能够直接使用npm，如果不能使用，可以在环境变量中系统变量中的Path添加npm 安装hexo的命令如下： 1234$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install 分别为安装hexo、创建博客的根目录、进入博客根目录、初始化目录 二、配置博客打开博客根目录下的_config.yml文件进行修改，这里先讲几个最主要的修改，在之后的配置过程中会进一步对这个文件进行修改 123456title: 博客名subtitle: 博客子标题description: 博客的一段描述author: 作者language: zh-CNtimezone: Asia/Shanghai 这里要注意一点，每项设置冒号: 后面一定要留一个空格 如果使用git pages来作为博客的托管，并且已经创建好githubname.github.io的仓库的话，按下面这么改 1234deploy: type: git repo: https://github.com/YourName/YourName.github.io.git branch: master 然后 1npm install --save hexo-deployer-git 三、编写并部署博客 创建博客 在博客根目录，控制台中输入 1$ hexo new "new" 在/source/_post下创建名为new的新博客 清除缓存 每次重新生成博客之前最好要进行这一步操作 1$ hexo clean 生成博客 123$ hexo generateor$ hexo g 开启服务器 123$ hexo serveror$ hexo s 默认会打开在http://localhost:4000/ 部署博客 123$ hexo deployor$ hexo d hexo将会将生成的博客push到之前配置文件中定义好的repo中 四、套用模版hexo有非常多的模版，其中最常见的模版之一就是nexT模版，也是文档相对完善的一套主题 官网：http://theme-next.iissnan.com/ 到官网上下载，或者到作者的github上下载相应主题文件后，在/themes下创建一个文件夹next并将下载的子文件拷贝到其下 然后修改博客的配置文件_config.yml（注意：下载的主题文件中也有同名的配置文件，以后会以主题的配置文件加以区分） 重新清理–&gt;生成–&gt;查看–&gt;部署，然后登录自己博客的主页看看效果吧！ 五、SEO 安装sitemap 进入根目录，输入 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在站点配置文件 _condig.yml中添加 12345##自动生成sitemapsitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml 在站点配置文件 _condig.yml中修改url为首页地址 重新生成并部署 提交sitemap 在百度站长工具中链接提交中选择sitemap提交方式，输入 1https://yoursite.com/baidusitemap.xml 谷歌也可以以类似的方式 1https://yoursite.com/sitemap.xml 如果是新网站，可能需要验证网站所有权，谷歌可以使用Google Analyze直接验证，或者百度和谷歌都可以提交HTML标签来验证。 将提供的&lt;meta&gt;标签加入\themes\next\layout\_partials下的head.swig中最上方重新生成上传，然后在百度谷歌中点验证就可以了 六、Fancybox开启图片放大缩小 安装与更新 123$ rm -rf themes/next/source/lib/fancybox$ cd themes/next$ git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox 七、添加分享功能主题配置文件 12345678910111213141516needmoreshare2: enable: true postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone float: enable: true options: iconStyle: box boxForm: vertical position: middleRight networks: Weibo,Wechat,Douban,QQZone see more 在站点配置文件 _config.yml中修改 1fancybox: true]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
